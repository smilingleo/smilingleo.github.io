{"version":3,"sources":["webpack:///path---3-12baebfdc0ab68f484ae.js","webpack:///./.cache/json/3.json"],"names":["webpackJsonp","421","module","exports","data","allMarkdownRemark","totalCount","edges","node","id","frontmatter","title","date","path","tags","excerpt","pathContext","group","html","pathPrefix","first","last","index","pageCount"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,mBAAqBC,WAAA,GAAAC,QAA0BC,MAAQC,GAAA,sHAAAC,aAA0IC,MAAA,yBAAAC,KAAA,mBAAAC,KAAA,sDAAAC,MAAA,yCAAAC,QAAA,6CAAgOP,MAAQC,GAAA,2HAAAC,aAA+IC,MAAA,iCAAAC,KAAA,iBAAAC,KAAA,0CAAAC,MAAA,6CAAAC,QAAA,uCAAwNP,MAAQC,GAAA,wHAAAC,aAA4IC,MAAA,2BAAAC,KAAA,gBAAAC,KAAA,iCAAAC,MAAA,QAAAC,QAAA,OAAmIP,MAAQC,GAAA,qHAAAC,aAAyIC,MAAA,0BAAAC,KAAA,iBAAAC,KAAA,8DAAAC,MAAA,eAAAC,QAAA,6BAA6LP,MAAQC,GAAA,6GAAAC,aAAiIC,MAAA,gBAAAC,KAAA,iBAAAC,KAAA,kDAAAC,MAAA,mCAAAC,QAAA,oCAAkMP,MAAQC,GAAA,+GAAAC,aAAmIC,MAAA,kBAAAC,KAAA,iBAAAC,KAAA,2CAAAC,MAAA,iBAAAC,QAAA,yFAAgOP,MAAQC,GAAA,iHAAAC,aAAqIC,MAAA,oBAAAC,KAAA,iBAAAC,KAAA,wCAAAC,MAAA,QAAAC,QAAA,gEAA6LP,MAAQC,GAAA,4GAAAC,aAAgIC,MAAA,0BAAAC,KAAA,iBAAAC,KAAA,yBAAAC,MAAA,0BAAAC,QAAA,sBAA4JP,MAAQC,GAAA,mHAAAC,aAAuIC,MAAA,wBAAAC,KAAA,iBAAAC,KAAA,oCAAAC,MAAA,mCAAAC,QAAA,yCAAiMP,MAAQC,GAAA,0GAAAC,aAA8HC,MAAA,gBAAAC,KAAA,iBAAAC,KAAA,WAAAC,MAAA,oBAAAC,QAAA,uIAA+OP,MAAQC,GAAA,2GAAAC,aAA+HC,MAAA,gBAAAC,KAAA,oBAAAC,KAAA,yCAAAC,MAAA,kCAAAC,QAAA,oGAA2PP,MAAQC,GAAA,8GAAAC,aAAkIC,MAAA,uBAAAC,KAAA,kBAAAC,KAAA,8BAAAC,MAAA,gDAAAC,QAAA,kJAAiTP,MAAQC,GAAA,yGAAAC,aAA6HC,MAAA,YAAAC,KAAA,iBAAAC,KAAA,+BAAAC,MAAA,4BAAAC,QAAA,qKAAqSP,MAAQC,GAAA,wHAAAC,aAA4IC,MAAA,2CAAAC,KAAA,iBAAAC,KAAA,oCAAAC,MAAA,kBAAAC,QAAA,mDAA6MP,MAAQC,GAAA,4GAAAC,aAAgIC,MAAA,eAAAC,KAAA,eAAAC,KAAA,yCAAAC,MAAA,uDAAAC,QAAA,+FAAqQP,MAAQC,GAAA,oGAAAC,aAAwHC,MAAA,mCAAAC,KAAA,mBAAAC,KAAA,kCAAAC,MAAA,6CAAAC,QAAA,wCAAqNP,MAAQC,GAAA,+GAAAC,aAAmIC,MAAA,4BAAAC,KAAA,oBAAAC,KAAA,wBAAAC,MAAA,kCAAAC,QAAA,kDAAoMP,MAAQC,GAAA,sGAAAC,aAA0HC,MAAA,eAAAC,KAAA,oBAAAC,KAAA,aAAAC,MAAA,yCAAAC,QAAA,0EAA2MP,MAAQC,GAAA,qGAAAC,aAAyHC,MAAA,QAAAC,KAAA,oBAAAC,KAAA,cAAAC,MAAA,0CAAAC,QAAA,sHAAkPP,MAAQC,GAAA,oGAAAC,aAAwHC,MAAA,OAAAC,KAAA,oBAAAC,KAAA,4BAAAC,MAAA,wDAAAC,QAAA,uDAA8MP,MAAQC,GAAA,iHAAAC,aAAqIC,MAAA,2BAAAC,KAAA,oBAAAC,KAAA,sCAAAC,MAAA,kCAAAC,QAAA,8GAA6QP,MAAQC,GAAA,8HAAAC,aAAkJC,MAAA,qCAAAC,KAAA,oBAAAC,KAAA,uCAAAC,MAAA,gCAAAC,QAAA,+GAAuRP,MAAQC,GAAA,mHAAAC,aAAuIC,MAAA,6BAAAC,KAAA,oBAAAC,KAAA,sCAAAC,MAAA,8BAAAC,QAAA,uCAAoMP,MAAQC,GAAA,gIAAAC,aAAoJC,MAAA,mCAAAC,KAAA,oBAAAC,KAAA,iCAAAC,MAAA,yBAAAC,QAAA,sCAA+LP,MAAQC,GAAA,kHAAAC,aAAsIC,MAAA,uBAAAC,KAAA,oBAAAC,KAAA,+BAAAC,MAAA,mBAAAC,QAAA,oFAAyNP,MAAQC,GAAA,kGAAAC,aAAsHC,MAAA,KAAAC,KAAA,mBAAAC,KAAA,cAAAC,QAAAC,QAAA,aAA4FC,aAAgBC,QAAUT,MAAQU,KAAA,y6EAA+yET,GAAA,iHAAAC,aAAwQE,KAAA,2BAAAC,KAAA,sCAAAF,MAAA,2BAAAI,QAAA,0GAAAD,MAAA,sCAAoRN,MAAQU,KAAA,irSAAmwRT,GAAA,8HAAAC,aAAqnBE,KAAA,2BAAAC,KAAA,uCAAAF,MAAA,qCAAAI,QAAA,2GAAAD,MAAA,oCAA8RN,MAAQU,KAAA,wzGAA2mGT,GAAA,mHAAAC,aAAqWE,KAAA,2BAAAC,KAAA,sCAAAF,MAAA,6BAAAI,QAAA,mCAAAD,MAAA,kCAA2MN,MAAQU,KAAA,2tGAAg7FT,GAAA,gIAAAC,aAAwcE,KAAA,2BAAAC,KAAA,iCAAAF,MAAA,mCAAAI,QAAA,kCAAAD,MAAA,6BAAsMN,MAAQU,KAAA;AAA0qHT,GAAA,kHAAAC,aAAuXE,KAAA,2BAAAC,KAAA,+BAAAF,MAAA,uBAAAI,QAAA,gFAAAD,MAAA,uBAAgON,MAAQU,KAAA,0kCAAAT,GAAA,kGAAAC,aAAusCE,KAAA,2BAAAC,KAAA,cAAAF,MAAA,KAAAI,QAAA,OAAAD,YAAiGK,WAAA,GAAAC,OAAA,EAAAC,MAAA,EAAAC,MAAA,EAAAC,UAAA","file":"path---3-12baebfdc0ab68f484ae.js","sourcesContent":["webpackJsonp([182981024786761],{\n\n/***/ 421:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"allMarkdownRemark\":{\"totalCount\":26,\"edges\":[{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2020/如何打造一个serverless的微信小程序.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"如何打造一个serverless的微信小程序\",\"date\":\"January 11, 2020\",\"path\":\"/2020/how-to-build-a-serverless-wechat-mini-program\",\"tags\":[\"serverless\",\"微信小程序\",\"AWS\",\"Anki\",\"背单词\"],\"excerpt\":\"本文介绍了一个完全serverless的应用开发过程以及所用技术的简单介绍。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2019/Tokio Future.poll返回NotReady.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"自定义Tokio Future.poll返回NotReady\",\"date\":\"March 01, 2019\",\"path\":\"/2019/rust-tokio-futures-poll-not-ready\",\"tags\":[\"rust\",\"tokio\",\"Future\",\"async programming\"],\"excerpt\":\"如何在Future.poll中返回Async::NotReady\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/How To Read Rust API Doc.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"How To Read Rust API Doc\",\"date\":\"June 01, 2018\",\"path\":\"/2018/how-to-read-rust-api-doc\",\"tags\":[\"rust\"],\"excerpt\":\"\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/简单比较下http2和http1.1的性能.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"简单比较下http/2和http/1.1的性能\",\"date\":\"March 19, 2018\",\"path\":\"/2018/simple-performance-comparison-between-http2-and-http1\",\"tags\":[\"http/2\",\"测试\"],\"excerpt\":\"简单对比http/1.1和http/2的性能\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/微服务架构下的开发环境问题.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"微服务架构下的开发环境问题\",\"date\":\"March 16, 2018\",\"path\":\"/2018/development-environment-for-microservices\",\"tags\":[\"微服务\",\"架构\",\"开发环境\",\"microservices\"],\"excerpt\":\"本文介绍如何在微服务架构下解决开发环境的搭建、共享的问题。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/为Gatsby博客添加分页功能.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"为Gatsby博客添加分页功能\",\"date\":\"March 12, 2018\",\"path\":\"/2018/support-pagination-for-gatsby-blog\",\"tags\":[\"blog\",\"gatsby\"],\"excerpt\":\"根据Egghead上的教程，做出的博客站点有个缺陷，那就是没有分页功能，对于勤奋的博主来说，在一个页面上显示所有文章列表有点不完美，这里我们改造一下，加入分页功能。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/为你的Gatsby博客添加评论功能.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"为你的Gatsby博客添加评论功能\",\"date\":\"March 12, 2018\",\"path\":\"/2018/enable-comments-for-gatsby-blog\",\"tags\":[\"blog\"],\"excerpt\":\"Gatsby打造的博客已经很不错了，但是缺少一个评论功能。本文简单介绍如何集成Disqus评论服务到你的博客站点。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/转用Gatsby搭建博客.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"转用Gatsby打造基于github的博客站点\",\"date\":\"March 08, 2018\",\"path\":\"/2018/blog-with-gatsby\",\"tags\":[\"blog\",\"github\",\"gatsby\"],\"excerpt\":\"如何用Gatsby打造一个博客\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/一则奇怪的Toubleshooting.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"记一次奇怪的troubleshooting\",\"date\":\"March 08, 2018\",\"path\":\"/2018/skipper-sni-domain-fronting\",\"tags\":[\"skipper\",\"SNI\",\"domain fronting\"],\"excerpt\":\"在Skipper转发请求到一个https站点的时候，返回莫名404.\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2016/JSON解析利器JQ.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"JSON解析利器---JQ\",\"date\":\"March 25, 2016\",\"path\":\"/2016/jq\",\"tags\":[\"bash\",\"jq\",\"json\"],\"excerpt\":\"在API first的时代，json作为最常用的格式，充斥着程序猿的屏幕各个角落，掌握一门解析、过滤、转换json输出的工具，已经成为程序猿们安身立命的必要技能。 这里隆重向大家介绍[jq](https://stedolan.github.io/jq/).\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2016/Function的协变.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Function的协、逆变\",\"date\":\"February 04, 2016\",\"path\":\"/2016/function-covariant-contravariant\",\"tags\":[\"scala\",\"functional programming\"],\"excerpt\":\"泛型编程的时候，协变(covariant)还是逆变(contravariant)很重要，在设计上层API接口的时候，正确的使用协变、逆变可以更好地约束程序员的行为，让实现变得安全、一致。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/如何在Scala中实现AOP.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"用Mixin组合实现Scala中的AOP\",\"date\":\"August 13, 2015\",\"path\":\"/2015/aop-by-mixin-in-scala\",\"tags\":[\"scala\",\"functional programming\",\"AOP\",\"mixin\"],\"excerpt\":\"在Java世界，AOP（Aspect Oriented Programming， 面向方面编程)是很多框架的基础。这种将关注点按照“方面”来切分的编程模型极大地简化了编程的复杂度，尤其是在多维度因子交织在一起的时候的各种场景。对于代码的可读性、可维护性、可重用性都是极大的帮助。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Scala雾里看花.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Scala雾里看花\",\"date\":\"April 23, 2015\",\"path\":\"/2015/scala-trouble-shooting\",\"tags\":[\"scala\",\"trouble shooting\"],\"excerpt\":\"Scala的学习过程中，经常会碰到一些莫名其妙的现象，很多时候，这些语言层面的“怪象”都与scala编译器或者scala的类型系统有关。本文不是对编译器和类型系统的介绍，而是重点介绍遇到这些现象的时候，用什么样的方式，拨开云雾见蓝天，通过这些工具获取一些细节帮你了解编译器和类型系统如何工作。工欲善其事，必先利其器。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Docker创建MySQL主从复制以及CDC测试.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"MySQL Master/Slave Replication on Docker\",\"date\":\"April 21, 2015\",\"path\":\"/2015/mysql-replication-on-docker\",\"tags\":[\"docker\",\"mysql\"],\"excerpt\":\"How to setup Mysql master/slave replication.\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2014/Scala函数式异常处理.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Scala函数式异常处理\",\"date\":\"May 04, 2014\",\"path\":\"/2014/scala-error-handling-in-fp-style\",\"tags\":[\"scala\",\"functional programming\",\"exception handling\"],\"excerpt\":\"经常看到很多示例代码，简洁的让人爱不释手，可是真正自己实现的时候，不得不添加各种各样的异常处理逻辑，最后发现代码总量的80%都是再做异常处理，而真正的代码逻辑只有很少的一部分。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2014/高种泛型.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"高种泛型 (Generics of a Higher Kind)\",\"date\":\"January 08, 2014\",\"path\":\"/2014/generics-of-a-higher-kind\",\"tags\":[\"scala\",\"functional programming\",\"Generics\"],\"excerpt\":\"Generics of a Higher Kind翻译加自我理解。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/map-flatMap-for.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"map/flatMap/for in Action\",\"date\":\"December 01, 2013\",\"path\":\"/2013/map-flatmap-for\",\"tags\":[\"scala\",\"functional programming\"],\"excerpt\":\"前文说过了，高阶函数式函数式语言中的基石，而`map`, `flatMap`更是重要。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/fold编程.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"折纸的艺术：fold编程\",\"date\":\"November 27, 2013\",\"path\":\"/2013/fold\",\"tags\":[\"scala\",\"functional programming\",\"fold\"],\"excerpt\":\"Eric Meijer说：递归是函数式编程的GOTO，应该尽可能避免。如何避免，OO中我们用while循环，FP中我们用`fold`。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Monad.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Monad\",\"date\":\"November 26, 2013\",\"path\":\"/2013/monad\",\"tags\":[\"scala\",\"functional programming\",\"monad\"],\"excerpt\":\"函数式语言与OO（确切地讲是指令式编程）的思维方式是完全不同的，很多OO中的经验在函数式语言中不是很匹配，比如设计模式，那就是一个OO中的特定术语，而在FP中，大家常谈的是对于习惯OO思维的程序员来说玄而又玄的Monad。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/高阶函数.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"高阶函数\",\"date\":\"November 21, 2013\",\"path\":\"/2013/high-order-function\",\"tags\":[\"scala\",\"functional programming\",\"high order function\"],\"excerpt\":\"所谓高阶函数（high order function），其实就是可以接受其他函数作为参数的函数。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Actor协调并发场景下的集合操作.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"边建边学-3：Actor协调并发场景下的集合操作\",\"date\":\"November 17, 2013\",\"path\":\"/2013/actor-collection-collabration\",\"tags\":[\"scala\",\"functional programming\"],\"excerpt\":\"很多时候为了提高性能，减少IO操作，都会将数据load出来之后缓存在内存中。本站的实现过程中也遇到类似的问题，不希望每次有人访问的时候就读取一次md文件，或者从MongoDB中查一次，而是直接在内存中读取。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Enumerator-Iteratee-Enumeratee.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Enumerator / Iteratee / Enumeratee\",\"date\":\"November 11, 2013\",\"path\":\"/2013/enumerator-iteratee-enumeratee\",\"tags\":[\"scala\",\"playframework\",\"blog\"],\"excerpt\":\"Stream对于指令式编程已经比较成熟了，有大量的类库，丰富的API。但是对于强调不可变量，尽可能无副作用的FP来说，要考虑语言适配的问题，而目前，流行的解决方案就是：Enumerator/Iteratee。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/集成PlantUML和Markdown.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"边建边学-2：集成PlantUML和Markdown\",\"date\":\"November 07, 2013\",\"path\":\"/2013/markdown-plantuml-integration\",\"tags\":[\"markdown\",\"plantuml\",\"blog\"],\"excerpt\":\"如何用Markdown+PlantUML结合来写图文并茂的博客。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/EssentialAction-in-Playframework.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"EssentialAction in Playframework\",\"date\":\"November 05, 2013\",\"path\":\"/2013/essential-action-in-play\",\"tags\":[\"scala\",\"playframework\"],\"excerpt\":\"Playframework中EssentialAction理解\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/用markdown写博客.markdown absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"边建边学-1: 用Markdown写博文\",\"date\":\"November 01, 2013\",\"path\":\"/2013/blogging-with-markdown\",\"tags\":[\"markdown\",\"blog\"],\"excerpt\":\"本文将是一个系列文章，循序渐进地介绍本站的构建过程，不只是简单的技术介绍，重点是建站过程遇到的问题分析，以及解决的过程，所以起名**“边建边学”**系列。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/开篇.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"开篇\",\"date\":\"October 25, 2013\",\"path\":\"/2013/start\",\"tags\":[],\"excerpt\":\"网络博客\"}}}]}},\"pathContext\":{\"group\":[{\"node\":{\"html\":\"<h2>上下文</h2>\\n<p>很多时候为了提高性能，减少IO操作，都会将数据load出来之后缓存在内存中。本站的实现过程中也遇到类似的问题，不希望每次有人访问的时候就读取一次md文件，或者从MongoDB中查一次，而是直接在内存中读取。</p>\\n<p>带来因减少IO而提升性能的好处的同时，也出现一个人和“缓存”解决方案都会遇到的问题：数据一致性。</p>\\n<p>简单来说，就是你有同样的一份数据，冗余存放在两个地方，如何确保这两个地方的数据是一致的？再具体一点，可能的问题有：</p>\\n<ul>\\n<li>\\n<p>数据更新的原子性</p>\\n<p>更新数据的时候，同时将两个地方的数据都同步更新，任何一个地方更新失败，则整体更新失败。</p>\\n</li>\\n<li>\\n<p>缓存线程安全的问题</p>\\n<p>如果缓存既可以被读取，又可能被更新，那么就又线程安全问题：多个线程同时操作同一个值的时候怎么协调？</p>\\n</li>\\n</ul>\\n<h2>具体问题</h2>\\n<p>开始的时候，我将所有的文章列表放在一个<code>scala.collection.mutable.ListBuffer</code>中：</p>\\n<!-- language:lang-scala -->\\n<pre><code>object Application extends Controller {\\n  lazy val allPosts: ListBuffer[Post] = ...\\n\\n}\\n</code></pre>\\n<p>因为新发布博客会增加集合内数据，所以这里用ListBuffer比较自然。当然用<code>var</code> + immutable collection也可以。</p>\\n<p>对<code>allPost</code>的操作主要有三个：</p>\\n<ol>\\n<li>\\n<p>在线编写一个博客的时候需要添加到集合中</p>\\n</li>\\n<li>\\n<p>该集合本身是无序的，因为排序的规则可能有多种，展现的时候再排序</p>\\n</li>\\n<li>\\n<p>更新一篇博文的时候同时更新集合中内容。</p>\\n</li>\\n</ol>\\n<p>因为本身Application Object是单例的，多个线程共同运行的场景下就会出现线程安全的问题，类似Servlet中instance级别变量的问题。</p>\\n<h2>解决方案</h2>\\n<p>直观地想，理想的解决方案就是将所有对<code>allPost</code>的写操作都串行起来，这样即使有多个线程同时操作，也没问题了。但是如何将实现串行呢？</p>\\n<p>在指令式编程的世界里，这个问题比较难于解答，一般需要通过加锁来解决。而一般的程序员看到<code>lock</code>, <code>synchronized</code>这些关键字就头疼了，即使经过无数次盲试之后侥幸实现了，也会在产品上线的时候出现这样那样、莫名其妙、让你大呼“这不科学”，“WTF”的惊呼！</p>\\n<p>但是在scala中，我们却不用担心，因为我们有<code>Akka Actor</code>。</p>\\n<p>Actor是另外一种并行计算方式，不同于线程共享内存的并发模型，Actor是基于消息的，强调不同Actor之间不共享数据。有了Actor，问题就迎刃而解了。</p>\\n<p>具体思路是：重建一个单例Actor，由该Actor来维护ListBuffer变量，所有的写操作，全部通过该消息提交任务交给其处理，这样就将并发的多个写请求串行起来了。</p>\\n<p>代码片段：</p>\\n<!-- language:lang-scala -->\\n<pre><code>object PostManager {\\n  // 单例manager actor\\n  lazy val manager = Akka.system.actorOf(Props[PostManager])\\n  case class NewPost(post: Post)\\n  \\n  def saveOrUpdate(unsavedPost: Post) = {\\n    manager ! NewPost(unsavedPost)\\n  }\\n}\\n\\nclass PostManager extends Actor {\\n  import PostManager._\\n  // actor是单例的，所以文章集合也是单例的。\\n  // all posts, but not ordered.\\n  lazy val allPosts: ListBuffer[Post] = Post.allPosts\\n  \\n  def receive = {\\n    case NewPost(newPost) =>\\n      // 先更新数据库，这样如果更新失败，就不会运行之后代码。一定程度上实现原子性。\\n      Post.upsert(newPost)\\n      \\n      val idx = allPosts.indexWhere( _.fileName == newPost.fileName )\\n      \\n      if (idx == -1){\\n        allPosts += newPost\\n      } else {\\n        allPosts.update(idx, newPost)\\n      }\\n  }\\n}\\n</code></pre>\\n<p>全站一个文章集合变量感觉有点\\\"玩具\\\"的感觉，不过这个模型其实是可以扩展的，比如将来如果支持多用户、多博客系统，我们可以每个用户创建一个Actor、维护该用户自己的文章列表。这个Actor模型还是可以重用的。</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Actor协调并发场景下的集合操作.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-17T14:16:45.000Z\",\"path\":\"/2013/actor-collection-collabration\",\"title\":\"边建边学-3：Actor协调并发场景下的集合操作\",\"excerpt\":\"很多时候为了提高性能，减少IO操作，都会将数据load出来之后缓存在内存中。本站的实现过程中也遇到类似的问题，不希望每次有人访问的时候就读取一次md文件，或者从MongoDB中查一次，而是直接在内存中读取。\",\"tags\":[\"scala\",\"functional programming\"]}}},{\"node\":{\"html\":\"<h2>Context</h2>\\n<p>插曲：前不久微博上看到一技术“牛人”大V评论Java8的一些特性，引入lambada但没有扩展能力，集合的查询都得靠新stream api而不是Enumerator / Iterator云云。一时手欠回复了下“似乎应该是Enumerator / Iteratee“, 结果引来一身骚，被该大V泼口大骂了一个下午，没错就是像网吧里面无聊的小青年一样无营养地谩骂，实在没搞懂到底是为什么，说我说的Iteratee和他说的没”鸡毛“关系，不懂，也不想搞懂了，还是他玩他的Iterator我介绍我的Iteratee吧。</p>\\n<p>因为我们的内存、磁盘等资源还是有限的，对于一个大的Stream，Collection，我们在处理的时候不应该将其作为整体进行处理，因为这样会带来潜在的风险，比如：内存溢出，降低系统吞吐量等等。</p>\\n<p>正确的方式是将大的不可预见（unpredictable）的stream，Collection进行分解，将其分解为小的，可预见（predictable）的块进行处理。这是流模式的思想，也是Iteratee的设计目标之一。</p>\\n<p>Stream对于指令式编程已经比较成熟了，有大量的类库，丰富的API。但是对于强调不可变量，尽可能无副作用的FP来说，要考虑语言适配的问题，而目前，流行的解决方案就是：Enumerator/Iteratee。</p>\\n<p>另外，就是需要用统一的API来处理所有类型的Stream，就像指令式编程中的<code>InputStream.read</code>, <code>OutputStream.write</code>，无论什么Stream都需要支持这些基本方法。</p>\\n<h2>High Level Concept Model</h2>\\n<p>Enumerator / Iteratee说起来很复杂，其实就是一个生产者 / 消费者模型。 Enumerator是生产者，创建诸多个可控的chunk，Iteratee是消费者，消费任意类型的Input Chunk。</p>\\n<!-- language:lang-scala -->\\n<pre><code>trait Enumerator {\\n  def |>>[A](i: Iteratee[E, A]): Future[Iteratee[E, A]] = apply(i)\\n}\\n</code></pre>\\n<p>Enumerator驱动一个Iteratee，Iteratee处理一个Chunk之后，返回下一个状态的Iteratee. 在构造Enumerator的时候不会真正读取数据，只有在真正消费时才产生IO。</p>\\n<p>而且多个Enumerator之间可以组合，不同类型的消费者（Iteratee）也可以进行组合、变换，简言之，组合的概念就是将每个Enumerator / Iteratee都看成是一个可组合的积木，每个积木相对独立可复用，写代码就是将这些积木组合达成你想要形状的过程。这个说法很常见，OO里提倡“组合优于继承”也是一样的思想，其中的关键是如何找到最小的可复用的component，然后是通过什么样的方式进行灵活地组合。</p>\\n<p>Enumerator / Iteratee / Enumeratee就是一个非常好的例子。</p>\\n<h2>消费者 Iteratee</h2>\\n<!-- language:lang-scala -->\\n<pre><code>class Iteratee &#x3C;&#x3C; (T, #00FF00) >> {\\n  Future[B] fold[B](folder: Step[E, A] => Future[B])\\n}\\nclass ImmediateIteratee &#x3C;&#x3C; (T, #00FF00) >>\\nclass Done &#x3C;&#x3C; (O, #FF0000) >>\\nclass Cont &#x3C;&#x3C; (O, #FF0000) >>\\nclass Error &#x3C;&#x3C; (O, #FF0000) >>\\nclass Step &#x3C;&#x3C; (T, #00FF00) >>\\nclass Input &#x3C;&#x3C; (T, #00FF00) >>\\n\\nIteratee &#x3C;|-- ImmediateIteratee\\nIteratee &#x3C;|-- FutureIteratee\\nIteratee &#x3C;.left.> Step\\nStep .left.> Input\\n\\nImmediateIteratee &#x3C;|-- DoneIteratee\\nDoneIteratee .. Done\\nImmediateIteratee &#x3C;|-- ContIteratee\\nContIteratee .. Cont\\nImmediateIteratee &#x3C;|-- ErrorIteratee\\nErrorIteratee .. Error\\n\\nnote \\\"company objects\\\" as oNote\\nDone .. oNote\\nCont .. oNote\\nError .. oNote\\n</code></pre>\\n<p>Iteratee是一个Input的消费者，注意：这里的Input不是全部输入，而是a chunk of input，这个很重要，没有一个Iteratee来消费所有输入数据，而是每块一个消费者，然后通过函数组合的方式将所有块穿起来。</p>\\n<ul>\\n<li>\\n<p>为什么不是一个完整输入对应一个消费者呢？\\n这是指令式编程的思维方式，因为你需要自己考虑实现细节，设计一些游标，每次读取步进的长度，判断游标的位置来判断下一步如何操作。</p>\\n</li>\\n<li>\\n<p>为什么不是所有的输入chunk共享一个消费者呢？\\n嗯，这个问题我不是很确定，应该是有一部分上面的原因，另外就是副作用的问题，每个Step自己维护自己的状态，可以比较容易地实现“懒加载”，在最后一步（调用<code>run</code>）的时候才真正发生IO，而之前，可以通过函数组合任意对每一步进行transform等操作。</p>\\n</li>\\n</ul>\\n<p>Iteratee还有一个需要注意的地方，fold函数是一个<code>curried function</code>，有一个implicit的参数ExecutionContext，也就是在哪个线程池中执行，这个现象在Play中很普遍。</p>\\n<p>ImmediateIteratee描述了一个已经预先知道其state的Iteratee，而FutureIteratee当然就是未来才能知道其State的Iteratee。[个人感觉这个地方设计有点怪，FutureIteratee似乎应该用Future[Iteratee]更好。] </p>\\n<!-- language:uml -->\\n<pre><code>class Step &#x3C;&#x3C; (T, #00FF00) >> {\\n  Iteratee[E, A] it\\n}\\nclass Iteratee &#x3C;&#x3C; (T, #00FF00) >>\\nclass Input &#x3C;&#x3C; (T, #00FF00) >>\\nStep .left.> Input\\nStep &#x3C;-right-> Iteratee\\nStep &#x3C;|-- Done\\nStep &#x3C;|-- Cont\\nStep &#x3C;|-- Error\\n</code></pre>\\n<p>Step描述的是一个Iteratee的状态，其本身包含一个Iteratee不变量<code>it</code>，而Done、Cont、Error也是简单的<code>case class</code>，所以构造也很简单。</p>\\n<!-- language:uml -->\\n<pre><code>class Input &#x3C;&#x3C; (T, #00FF00) >>\\nInput &#x3C;|-- El\\nInput &#x3C;|-- Empty\\nInput &#x3C;|-- EOF\\n</code></pre>\\n<p>Input[E]描述的是<code>一块</code>输入(a chunk of input，不是全部输入)，构造其实很简单，就是一个简单的case class，可以按照你熟悉的方式来构造。</p>\\n<h2>生产者 Enumerator</h2>\\n<p>先来看看Enumerator的定义：</p>\\n<!-- language:lang-scala -->\\n<pre><code>trait Enumerator[E] {\\n\\n  /**\\n   * Apply this Enumerator to an Iteratee\\n   */\\n  def apply[A](i: Iteratee[E, A]): Future[Iteratee[E, A]]\\n  def |>>[A](i: Iteratee[E, A]): Future[Iteratee[E, A]] = apply(i)\\n  ...\\n\\n}\\n</code></pre>\\n<p>由上面定义可以看到，一个<code>Enumerator</code>接受一个<code>Iteratee[E, A]</code>，并返回一个<code>Future[Iteratee[E, A]]</code>，翻译一下就是：Enumerator驱动一个消费者，消费数据之后产生一个下个状态的消费者。</p>\\n<p>Enumerator提供了大量的工厂方法（在scala中是通过伴生对象来实现），比如，你可以从一个数组创建一个Enumerator:</p>\\n<!-- language:lang-scala -->\\n<pre><code>val enumerateCountries = Enumerator[String] = Enumerator(\\\"China\\\", \\\"America\\\", \\\"Japan\\\", \\\"Russia\\\", \\\"England\\\")\\n</code></pre>\\n<p>可以从一个文件中创建：</p>\\n<!-- language:lang-scala -->\\n<pre><code>val enumerateFile: Enumerator[Array[Byte]] = Enumerator.fromFile(new File(\\\"path/to/some/big/file\\\"))\\n</code></pre>\\n<p>或者从一个Stream中创建：</p>\\n<!-- language:lang-scala -->\\n<pre><code>val enumerateFile: Enumerator[Array[Byte]] = Enumerator.fromStream(new java.io.FileInputStream(new File(\\\"path/to/some/big/file\\\")))    \\n</code></pre>\\n<p>更加通用的方式是从一个<code>e: ()=>Future[Option[E]]</code>函数来创建，因为这个函数声明了：未来可能会产生一个<code>E</code>:</p>\\n<!-- language:lang-scala -->\\n<pre><code>def generateM[E](e: => Future[Option[E]])(implicit ec: ExecutionContext): Enumerator[E] = {\\n    ...\\n}\\n</code></pre>\\n<p>发挥一下你的想象，很多事情都可以看成是Stream，比如时间：</p>\\n<!-- language:lang-scala -->\\n<pre><code>import play.api.libs.concurrent.Promise\\nimport play.api.libs.iteratee._\\nimport scala.concurrent.duration._\\nimport scala.concurrent.ExecutionContext.Implicits.global\\nimport java.util.Date\\n\\n// 截止时间\\nval alertTo = new Date(System.currentTimeMillis + 1000*60)\\n\\n// 一个时间流，截止到alertTo\\nval timeStream = Enumerator.generateM {\\n    Promise.timeout(\\n      if (new Date before alertTo) Some(new Date) else None, \\n      1 seconds)\\n}\\n\\nval printlnSink = Iteratee.foreach[Date](date => println(date))\\n// 每隔一秒钟打印一次，直到alertTo\\ntimeStream |>> printlnSink\\n</code></pre>\\n<p>如果你想再play console里面运行上面的代码，可能会失败，说什么:no application started之类的，这时你需要前面加上：</p>\\n<!-- language:lang-scala -->\\n<pre><code>val app = new play.core.StaticApplication(new java.io.File(\\\".\\\"))\\n</code></pre>\\n<p>创建一个测试用的application，再试一下就OK了。</p>\\n<p>除了这个例子，我觉得也可以将数据库中的游标查询用Enumerator来实现。</p>\\n<p>在Play框架中，还有一个实际的例子是<code>WebSocket</code>，有机会我们再单独介绍。</p>\\n<h2>适配器 Enumeratee</h2>\\n<p>对应OO Design Pattern中的Adaptor模式，<code>Enumeratee</code>就是一个Adaptor，将不同规格的组件适配在一起。比如下面这个例子：</p>\\n<p>我们有一个String类型的Enumerator, <code>Enumerator(\\\"123\\\", \\\"456\\\", \\\"789\\\", \\\"222\\\", \\\"333\\\", \\\"444\\\")</code>，还有一个累加器，<code>Iteratee.fold[Long, Long](0:Long) { (acc, el) => acc + el }</code>，两者的“规格”是不同的，一个是String， 但另外一个是Long，当然我们可以再定义一个新的Iteratee，比如：<code>Iteratee.fold[String, Long](0:Long) { (acc, el) => acc + el.toLong }</code>，但是显然，这里面有重复代码的臭味道。更加合理的方式是做一个适配，用一个适配器来讲两个已经存在的component转接后一起工作。</p>\\n<!-- language:lang-scala run -->\\n<pre><code>import play.api.libs.iteratee._\\nimport scala.concurrent.ExecutionContext.Implicits.global\\n\\nval strings = Enumerator(\\\"123\\\", \\\"456\\\", \\\"789\\\", \\\"222\\\", \\\"333\\\", \\\"444\\\")\\nval sum = Iteratee.fold[Long, Long](0:Long) { (acc, el) => acc + el }\\nval toLong = Enumeratee.map[String]( x => x.toLong )\\n\\nstrings |>> toLong &#x26;>> sum flatMap { x => x.run } onSuccess { case s => println(s) }\\n// Or, transform the Enumerator first.\\nstrings &#x26;> toLong |>> sum flatMap { x => x.run } onSuccess { case s => println(s) }\\n</code></pre>\\n<p>上面例子可以看到，<code>Enumeratee</code>不但可以适配<code>Iteratee</code>，还可以转换<code>Enumerator</code>。</p>\\n<p>留个问题：<code>strings &#x26;> toLong</code>会不会产生memory的问题？ </p>\\n<h2>指令式 VS. 函数式</h2>\\n<p>这里用一个很无聊的例子：遍历一个大文件来统计文件大小。</p>\\n<h3>指令式风格</h3>\\n<p>Use Java FileInputStream, more imperative style:</p>\\n<!-- language:lang-scala -->\\n<pre><code>val fis = new java.io.FileInputStream(new java.io.File(\\\"/Users/leo/Movies/big_file.mkv\\\"))\\n\\n// mutable variables\\nvar readLength = 0\\nvar fileSize: Long = 0\\nvar buf = new Array[Byte](1024 * 8) // chunk size used in Enumerator\\nval begin = System.currentTimeMillis\\ndo {\\n  readLength = fis.read(buf)\\n  if (readLength != -1)\\n    fileSize = fileSize + readLength\\n}while(readLength != -1)\\n\\nprintln(s\\\"File Size: $fileSize, and it took ${System.currentTimeMillis - begin} ms\\\")\\n</code></pre>\\n<p>And output like <code>File Size: 4003885806, and it took 54701 ms</code>, the memory usage is about <code>78Mb</code>.</p>\\n<h3>函数式风格</h3>\\n<p>Use Enumerator / Iteratee to get file size:</p>\\n<!-- language:lang-scala -->\\n<pre><code>import play.api.libs.iteratee._\\n// construct an Enumerator from a file\\nval fileEnum = Enumerator.fromFile(new java.io.File(\\\"/Users/leo/Movies/big_file.mkv\\\")) \\n// create a consumer\\nval counter = Iteratee.fold[Array[Byte], Long](0: Long){ (acc, ele) => ele.size + acc }\\n\\nval begin = System.currentTimeMillis\\n// where the IO really happens.\\nIteratee.flatten(fileEnum |>> counter).run.onSuccess { case x => println(s\\\"File Size: $x, and it took ${System.currentTimeMillis - begin} ms\\\") }\\n</code></pre>\\n<p>Here's the output: <code>File Size: 4003885806, and it took 57213 ms</code>, and max memory usage is about <code>120Mb</code>. </p>\\n<p>Note: If you are running above code with Scala version &#x3C; 2.10.3, you'll run into <code>OutOfMemory</code> Error, it's so funny right? Enumerator / Iteratee suppose to be designed to solve the OutOfMemory issue, actually, it's not Enumerator/Iteratee 's problem, it's a bug of scala, see <a href=\\\"https://issues.scala-lang.org/browse/SI-7336\\\">SI-7336</a></p>\\n<h3>对比</h3>\\n<p>从上面的两种实现来看，从执行时间上，两种方式没有太大差异，但是指令式编程在内存占用方面要优于函数式编程，毕竟var变量可以复用，val变量需要重新生成。但是差别并没有想象中那么大，处理一个4G的文件，差别只是40M左右。但是带来的好处是显而易见的：因为没有mutable变量，没有副作用，并发、代码可读性有提高。</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Enumerator-Iteratee-Enumeratee.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-11T14:16:45.000Z\",\"path\":\"/2013/enumerator-iteratee-enumeratee\",\"title\":\"Enumerator / Iteratee / Enumeratee\",\"excerpt\":\"Stream对于指令式编程已经比较成熟了，有大量的类库，丰富的API。但是对于强调不可变量，尽可能无副作用的FP来说，要考虑语言适配的问题，而目前，流行的解决方案就是：Enumerator/Iteratee。\",\"tags\":[\"scala\",\"playframework\",\"blog\"]}}},{\"node\":{\"html\":\"<p>Markdown是一个很爽的写作格式（或者说语言更合适一点），我们不再需要复杂的富文本编辑器，用纯文本就可以编写出布局漂亮的文章。</p>\\n<p>不过Markdown对于技术类文章来说还有一个不足：我们经常需要画一些图来阐述自己的思路，但是Markdown只能引用已经存在的图。</p>\\n<p>有没有可能用Plain Text来画图呢？AscII艺术图？太原始了。试试PlantUML吧。</p>\\n<h2>PlantUML介绍</h2>\\n<p>从某个角度说，<a href=\\\"http://plantuml.sourceforge.net\\\">PlantUML</a>简直就是Markdown的绝配，也只需要纯文本就可以实现漂亮的效果，只是这里变成更炫的UML图。</p>\\n<p>比如我想画一个类图，Cat和Dog继承Animal，用PlantUML来实现就是：</p>\\n<pre><code>@startuml\\nAnimal &#x3C;|-- Cat\\nAnimal &#x3C;|-- Dog\\n@enduml\\n</code></pre>\\n<p>是不是很简单？来看看效果：</p>\\n<!-- language:uml -->\\n<pre><code>Animal &#x3C;|-- Cat\\nAnimal &#x3C;|-- Dog\\n</code></pre>\\n<p>怎么样？不错吧，这个图片哪里来的？其实在我发布这篇文章的时候，这个类图还不存在，只有在你访问这篇文章的时候才自动生成的。PlantUML有一个jQuery插件，可以在运行时生成图片。</p>\\n<p>PlantUML的jQuery插件用法很简单，你只需要在html中编辑：</p>\\n<!-- language:lang-html -->\\n<pre><code>&#x3C;img uml=\\\"\\n  Animal &#x3C;|-- Cat\\n  Animal &#x3C;|-- Dog\\n\\\">\\n</code></pre>\\n<p>jQuery插件会自动增强这个img元素，具体实现还挺有意思，这里不细说了。</p>\\n<p>可这还不够，怎么在Markdown中写<code>img</code>呢？如果你照抄上面的img代码，pegdown解析器会抛错，'&#x3C;'不匹配云云。</p>\\n<h2>解决方案</h2>\\n<p>基本上这种问题可以从两个方面想办法，一个是服务器端，实现一个markdown parser plugin，来定制一个特殊语法，另一个方向是从浏览器端想办法。</p>\\n<p>从上面的介绍中我们知道，已经有jQuery插件了，那从前端做似乎更加容易一些。此外，从<a href=\\\"http://www.learn-scala.net/blogs/2013-11-01_14.md\\\">上一篇</a>我们已经知道，在<code>pre code</code>前面加上一个<code>&#x3C;!-- language:lang-scala --></code>来实现语法高亮显示问题。</p>\\n<p>PlantUML的内容也可以认为是一种code，很自然地，我们可以用<code>pre code</code>来封装。比如我们可以用：</p>\\n<!-- language:lang-html -->\\n<pre><code>&#x3C;!-- language:uml -->\\n    Animal &#x3C;|-- Cat\\n    Animal &#x3C;|-- Dog\\n</code></pre>\\n<p>这里我们自定义了一种language类型<code>uml</code>，在前端解析的时候，就能知道这个代码块是用来画图的了。</p>\\n<p>好，我们来看前端JS代码的实现：</p>\\n<!-- language:lang-javascript -->\\n<pre><code>function init() {\\n  var plantuml = false;\\n  var blocks = document.querySelectorAll('pre code');\\n  // 遍历所有pre code\\n  for (var i = 0; i &#x3C; blocks.length; i += 1) {\\n    var code = blocks[i];\\n    //code.className += ' prettyprint';\\n    var pre = code.parentNode;\\n    var above = pre;\\n    do {\\n      above = above.previousSibling;\\n    } while (above.nodeType == Node.TEXT_NODE)\\n    // 检查注释元素据\\n    if (above.nodeType == Node.COMMENT_NODE) {\\n      var comment = above.data;\\n      // 正则表达式，获取语言类型\\n      var pattern = /^\\\\s*language:\\\\s*([\\\\w\\\\-]+)\\\\s*(\\\\w+)?\\\\s*$/i;\\n      var match = pattern.exec(comment);\\n      if (match != null) {\\n        var lang = match[1];\\n        // 如果是uml，动态生成一个img元素，并设置uml属性值为pre code的内容。\\n        if (lang &#x26;&#x26; lang == \\\"uml\\\") {\\n          var container = document.createElement(\\\"div\\\");          \\n          var img = document.createElement(\\\"img\\\");\\n          img.setAttribute(\\\"uml\\\", code.innerText || code.textContent);\\n\\n          container.appendChild(img);\\n          container.className = \\\"text-center\\\";\\n\\n          pre.insertAdjacentElement('afterEnd', container);\\n          // 将pre code隐藏起来，只显示图片\\n          pre.style.display = \\\"none\\\";\\n          plantuml = true;\\n        }\\n      }\\n    }\\n  }\\n  // 调用jQuery插件生成图片。\\n  if (plantuml) {\\n    plantuml_runonce();\\n  }\\n}\\n</code></pre>\\n<p>然后，在html中调用：</p>\\n<!-- language:lang-html -->\\n<pre><code>&#x3C;script type='text/javascript'>\\n  window.onload = init;    \\n&#x3C;/script>  \\n</code></pre>\\n<p>搞定，收工！！写作、布局编排、画图全部纯文本，爽！</p>\\n<p>附上一个PlantUML的参考文档，原本上sourceforge网站就可以了，可惜被墙了，点击<a href=\\\"http://www.learn-scala.net/assets/ebooks/PlantUML_Language_Reference_Guide.pdf.zip\\\">这里</a>下载吧。</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/集成PlantUML和Markdown.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-07T19:16:45.000Z\",\"path\":\"/2013/markdown-plantuml-integration\",\"title\":\"边建边学-2：集成PlantUML和Markdown\",\"excerpt\":\"如何用Markdown+PlantUML结合来写图文并茂的博客。\",\"tags\":[\"markdown\",\"plantuml\",\"blog\"]}}},{\"node\":{\"html\":\"<h2>Play!框架的核心</h2>\\n<p>Play!的内核其实非常简单，简单地说，Play框架所实现的可以用一个函数表达式来描述：</p>\\n<p><code>RequestHeader -> Array[Byte] -> Result</code></p>\\n<p>具体讲，就是接受一个<code>RequestHeader</code>，然后读入类型为<code>Array[Byte]</code>的Request Body，计算完毕之后返回一个<code>Result</code>。</p>\\n<p>注：函数式语言的表达就是高度抽象，但异常简洁。</p>\\n<h2>问题及优化</h2>\\n<h3>文件上传</h3>\\n<p>上面的描述有一个问题：我们假定要把请求内容<em>全部</em>读入内存（或者写入磁盘），对于简单应用不是什么问题，但是对于文件上传等场景，这肯定是有问题的，所以，Play开发者做了优化。</p>\\n<p>注：此处可以看出函数式语言的一个优点：仅需要了解你的函数定义，就能分析出潜在的问题。而如果面向对象的方式一般关注在对象之间的通信、方法调用，从方法签名上往往会忽略这些细节。</p>\\n<p>优化的思路当然是将请求内容一部分一部分地读入（chunk），所以这个函数就变成了：</p>\\n<p><code>RequestHeader -> Iteratee[Array[Byte], Result]</code></p>\\n<p><code>Iteratee</code>是个什么东东？简单讲就是一个<code>Monad</code>，什么是Monad？可以类比为OO世界中的设计模式：专门为了解决某类问题的特定方法。Iteratee可以将输入（Input）分步(Step)读入，而且可以进行精细控制遇到EOF、Empty、El(chunk)的时候应该如何处理，是继续（Cont），结束（Done）还是抛错（Error）。这里不做详细介绍。有兴趣的可以参见：<a href=\\\"http://apocalisp.wordpress.com/2010/10/17/scalaz-tutorial-enumeration-based-io-with-iteratees/\\\">这篇博客</a></p>\\n<p>Iteratee本身也是一个<code>Arrow</code>（简单理解为函数），所以如果我们定义一个新类型：</p>\\n<!-- language:lang-scala -->\\n<pre><code>type ==>[E, R] = Iteratee[E, R]\\n</code></pre>\\n<p>上面的函数用scala来写就会变为：</p>\\n<!-- language:lang-scala -->\\n<pre><code>RequestHeader => Array[Byte] ==> Result\\n</code></pre>\\n<p>注：<code>==>[E, R]</code>和<code>E ==> R</code>是等价的，是scala的一个语法糖。</p>\\n<p>上面的表达式看上去更简洁，更有趣了。</p>\\n<h3>文件下载</h3>\\n<p>有了<code>Iteratee</code>我们就可以分块处理请求了，但是响应呢？同样地，如果响应中的数据量很大，比如文件下载，从上面的函数定义看，依旧会把文件完全读入到内存中，同样的问题。</p>\\n<p>解决的思路也是一样的。我们可以将<code>Result</code>看做下面的数据结构：</p>\\n<!-- language:lang-scala -->\\n<pre><code>case class Result(header: ResponseHeader, body: Array[Byte])\\n</code></pre>\\n<p>问题主要在<code>body</code>上，类型是Array[Byte]，需要有一个新的数据类型将起封装，可以分块地处理输出内容，这就是<code>Enumerator</code>，一个用来将响应数据分块(chunk)的东东。</p>\\n<p>所以最终Play框架核心可以看做下面的API：</p>\\n<!-- language:lang-scala -->\\n<pre><code>case class Result[E](headers:ResponseHeaders, body:Enumerator[E])(implicit writeable:Writeable[E])\\ntype ==>[E, R] = Iteratee[E, R]\\nRequestHeader => Array[Byte] ==> Result\\n</code></pre>\\n<p>下面我们来看看Request和Result各自的类图，了解一下都有哪些实现。</p>\\n<!-- language:uml -->\\n<pre><code>title Request Class Hierarchy\\nclass RequestHeader &#x3C;&#x3C; (T, #00FF00)>>\\nclass Request &#x3C;&#x3C; (T, #00FF00)>>\\n\\nRequestHeader &#x3C;|-- Request\\nRequest &#x3C;|-- WrappedRequest\\nRequest &#x3C;|-- FakeRequest\\nWrappedRequest &#x3C;|-- AuthenticatedRequest\\n\\ncenter footer 图一：Request 类图\\n</code></pre>\\n<p>真简单啊，比OO世界里面的一些MVC框架中的类层次结构少多了。</p>\\n<!-- language:uml -->\\n<pre><code>title Result Class Hierarchy\\nclass WithHeaders &#x3C;&#x3C; (T, #00FF00) >>\\nclass Result &#x3C;&#x3C; (T, #00FF00) >>\\n\\nclass PlainResult &#x3C;&#x3C; (T, #FF0000) deprecated>>\\nclass AsyncResult &#x3C;&#x3C; (C, #FF0000) deprecated>>\\nclass ChunkedResult &#x3C;&#x3C; (D, #FF0000) deprecated>>\\n\\nWithHeaders &#x3C;|-- Result\\nResult &#x3C;|-- PlainResult\\nResult &#x3C;|-- AsyncResult\\nPlainResult &#x3C;|-- SimpleResult\\nSimpleResult &#x3C;|-- ChunkedResult\\nSimpleResult &#x3C;|-- Status\\n\\ncenter footer 图二：Result 类图\\n</code></pre>\\n<p>目前Play2.2中Result有两个子类：PlainResult和AsyncResult，但这两个Result已经被标记为deprecated了，从2.3开始，Play将只支持SimpleResult。为什么呢？ 想想其实很简单：单一职责原则。所谓<code>AsyncResult</code>其实本身职责不单一，有异步和Result两个，而直接使用：<code>Future[SimpleResult]</code>则清晰很多。另外ChunkedResult被废弃的原因也一样。</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/EssentialAction-in-Playframework.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-05T09:16:45.000Z\",\"path\":\"/2013/essential-action-in-play\",\"title\":\"EssentialAction in Playframework\",\"excerpt\":\"Playframework中EssentialAction理解\",\"tags\":[\"scala\",\"playframework\"]}}},{\"node\":{\"html\":\"<p>本文将是一个系列文章，循序渐进地介绍本站的构建过程，不只是简单的技术介绍，重点是建站过程遇到的问题分析，以及解决的过程，所以起名<strong>“边建边学”</strong>系列。</p>\\n<p>希望对学习<code>Scala</code>+<code>Playframework</code>的童鞋有所启发。</p>\\n<p>本篇重点介绍如何用markdown来写技术文章，以及如何优化代码片段。</p>\\n<h2>需求</h2>\\n<ul>\\n<li>用markdown来写博客，对不同代码类型能够进行美化</li>\\n<li>技术博客一般会在文中包含部分代码片段，在看文章的时候，如果能运行一下这个代码片段，看看执行结果是什么，会对理解技术有所帮助，所以这里需要一个Web REPL (Read Eval Print Loop)</li>\\n<li>博文列表中只显示博文头</li>\\n</ul>\\n<h2>实现</h2>\\n<h3>markdown</h3>\\n<p>用Markdown写文章的流程是这样的：</p>\\n<ol>\\n<li>\\n<p>在本地创建md文件，用markdown语法写文章</p>\\n<p>markdown语法不是本文的介绍重点，需要温习的童鞋请查看<a href=\\\"http://zh.wikipedia.org/zh-cn/Markdown\\\">维基百科</a>，编辑工具可以考虑使用：<a href=\\\"http://mouapp.com\\\">Mou</a>，或者chrome插件stackedit。</p>\\n</li>\\n<li>\\n<p>将文章发布到网站。</p>\\n<p>发布的最终目的是将文章上传到网站，可以是存到数据库中，可以是上传为一个文件，因为文章的特殊性，创作过程需要跟踪记录，而且md文章本身也是一个文件，所以直接将文件上传搞定。</p>\\n<p>具体上传途径是通过git。其实从版本管理的角度，md文件和其他源代码文件没有什么不同。</p>\\n</li>\\n<li>\\n<p>mardkown解析成为HTML</p>\\n<p>这个解析有两种选择，一个是在服务器端解析，另外一个是在浏览器端通过javascript来解析。个人觉得没有太大不同，这里选择一个github上开源的工具来实现：<a href=\\\"https://github.com/sirthias/pegdown\\\">Pegdown</a>。</p>\\n<p>具体代码非常简单：</p>\\n</li>\\n</ol>\\n<!-- language:lang-scala -->\\n<pre><code>val processor = new PegDownProcessor()\\nval markdownContent = \\\"##title2\\\\n*item1\\\"\\nval htmlContent = processor.markdownToHtml(markdownContent)\\n</code></pre>\\n<ol start=\\\"4\\\">\\n<li>\\n<p>代码美化</p>\\n<p>将MD转换为html之后，代码片段只是被转换为：<code>&#x3C;pre>&#x3C;code> .... &#x3C;/code>&#x3C;/pre></code>，但是如何按照相应语言的语法进行高亮显示呢？其实任何Web效果的东西都没有什么神秘的，只是应用CSS而已。</p>\\n<p>这里我们选用的是<a href=\\\"https://code.google.com/p/google-code-prettify/\\\">prettify.js</a>，当然，还可以选择其他方案，比如<a href=\\\"http://highlightjs.org\\\">highlight.js</a>.</p>\\n<p>具体方案如下：</p>\\n</li>\\n</ol>\\n<!-- language:lang-javascript -->\\n<pre><code>&#x3C;script type='text/javascript'>\\n    function init() {\\n        var prettify = false;\\n        var blocks = document.querySelectorAll('pre code')\\n        for (var i = 0; i &#x3C; blocks.length ; i++) {\\n            blocks[i].className += 'prettyprint';\\n            prettify = true;\\n        }\\n        if (prettify) {\\n          prettyPrint();\\n        }\\n    }\\n    window.onload = init;\\n&#x3C;/script>\\n</code></pre>\\n<p>简单说，就是在页面（dom）加载完成之后，查找所有的pre+code元素，然后给该元素class添加<code>prettyprint</code>，这样有了预定义的样式表，代码语法高亮特性就实现了。\\n<br>\\n代码片段执行的部分将有专门的章节介绍，此处略过。\\n</p>\\n<h3>博文列表只显示文章头</h3>\\n<p>在列表页面，将在一个页面列出大量的内容，如果将每篇文章都完整地列出来，那么页面将变得很长，而且也不方便用户查找，而如果能够只显示文章的开头部分，就可以让读者快速地了解文章大致内容，并且快速浏览近期文章，有选择性地查看文章。</p>\\n<p>这个说起来其实很简单，展示部分内容逻辑上也很简单，只是简单截取文章开头的前N个字符而已。总体上是这个思路，可实际上会比这个稍微复杂一些。原因在于博文不是简单的plain text，而是HTML代码，如果只简单截取前面N个字符，极有可能会造成HTML片段不完整导致页面错误。</p>\\n<p>知道问题所在之后，解决办法其实也就简单了。我们可以简单分析一下markdown转换为html之后的代码结构，比如：</p>\\n<!-- language:lang-html -->\\n<pre><code>&#x3C;h1>手工打造博客站点-1: 用Markdown写博文&#x3C;/h1>\\n&#x3C;p>本文将是一个系列文章，循序渐进地介绍本站的构建过程，不只是简单的技术介绍，重点是建站过程遇到的问题分析，以及解决的过程。&#x3C;/p>\\n&#x3C;p>希望对学习&#x3C;code>Scala&#x3C;/code>+&#x3C;code>Playframework&#x3C;/code>的童鞋有所启发。&#x3C;/p>\\n&#x3C;p>本篇重点介绍如何用markdown来写技术文章，以及如何优化代码片段。&#x3C;/p>\\n&#x3C;h2>需求&#x3C;/h2>\\n……\\n</code></pre>\\n<p>很明显，标题、段落等html元素都是同级的，所以我们只需要一次计算每个html元素所包含内容的长度，当叠加到超过阀值时，将前面元素内容输出就好了。具体的办法是：先将html字符串解析为XML DOM，然后迭代每个一级children节点。</p>\\n<!-- language:lang-scala -->\\n<pre><code>val content = Source.fromFile(file, \\\"UTF-8\\\", 1024).mkString\\nval htmlContent = \\\"&#x3C;article>\\\" + processor.markdownToHtml(content) + \\\"&#x3C;/article>\\\"\\n// only show part of the article\\nval xml = scala.xml.XML.loadString(htmlContent)\\nvar i: Long = 0L\\nval elemList = xml.child.takeWhile( el => { i += el.toString().length; i &#x3C; ConfigUtils.BLOG_HEAD_LENGTH } )\\nval part = \\\"&#x3C;article>\\\" + elemList.mkString + s\\\"\\\"\\\"&#x3C;p>&#x3C;a href=\\\"/blogs/${file.getName}\\\">[...]&#x3C;/a>&#x3C;/p>&#x3C;/article>\\\"\\\"\\\"\\n</code></pre>\\n<p>备注：</p>\\n<ul>\\n<li>在转换为html之后，需要在外面包一个<code>&#x3C;article></code>容器元素。</li>\\n<li>从一个Seq容器元素中截取前面部分元素用<code>takeWhile</code>，此处有一个<code>var</code>可变参数的使用，其实也可以不用，只是用在这里容易一些。</li>\\n<li>在最后添加一个指向文章全文的链接。</li>\\n</ul>\\n<h2>预告</h2>\\n<p>下篇，将介绍如何将网页中的代码片段提交到服务器端执行并返回执行结果，也就是Web GUI REPL，敬请关注。</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/用markdown写博客.markdown absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-01T14:06:45.000Z\",\"path\":\"/2013/blogging-with-markdown\",\"title\":\"边建边学-1: 用Markdown写博文\",\"excerpt\":\"本文将是一个系列文章，循序渐进地介绍本站的构建过程，不只是简单的技术介绍，重点是建站过程遇到的问题分析，以及解决的过程，所以起名**“边建边学”**系列。\",\"tags\":[\"markdown\",\"blog\"]}}},{\"node\":{\"html\":\"<h2>引子</h2>\\n<p>从有了博客这个东西开始，就一直开始找各种好用的博客站点，csdn、新浪、搜狐、博客大巴、点点、google site、Github，甚至自己定制内容管理系统（CMS）Liferay，来建立自己的博客站点。免费的、收费的，都尝试了，可总觉得这里或者那里有点不满意。</p>\\n<p>所以就有一个小心愿能实现一个自己喜欢的站点。</p>\\n<p>这个站点应该可以：</p>\\n<ul>\\n<li>用比较“极客”的方式来写，符合我们这种工科IT男的作风。</li>\\n<li>可以很灵活地定制，想加什么功能就加什么功能。</li>\\n<li>最好有个主题，不是一个记流水账的地方。</li>\\n</ul>\\n<p>近来学习scala这门语言，对于我这个多年在OO世界中打拼的程序员在思维方式上的触动很大，有了找一个地方写一些关于scala学习方面的专题文章。</p>\\n<p>两者一结合，就有了这个网站。</p>\\n<h2>站点简介</h2>\\n<p>这个网站是用下列技术构建的：</p>\\n<ul>\\n<li>Scala</li>\\n<li>Playframework</li>\\n<li>Markdown</li>\\n<li>Websockets</li>\\n<li>Redis</li>\\n<li>MongoDB</li>\\n<li>Twitter Bootstrap</li>\\n</ul>\\n<p>运行在Heroku上，除了域名，一切免费。</p>\\n<h2>博客内容预告</h2>\\n<p>这一系列文章将包括，但不限于：</p>\\n<ul>\\n<li>\\n<p>构建本站技术介绍\\n如何一步一步地搭建一个完整的网站。</p>\\n</li>\\n<li>\\n<p>Scala语言特性</p>\\n</li>\\n<li>\\n<p>一些Scala世界的常用工具，比如Akka、Scalaz的介绍等等。</p>\\n</li>\\n</ul>\\n<p>你可以方便地在网站上直接测试一些小的代码，比如：</p>\\n<!-- language:lang-scala run -->\\n<pre><code>val i = 10\\nprintln(i + 2)\\nval j = 10\\nprintln(j - i)\\n</code></pre>\\n<p>点击<code>Run</code>你就能看到执行结果。</p>\\n<h2>TODO LIST</h2>\\n<ul>\\n<li>简单的搜索</li>\\n<li>分页</li>\\n<li>评论功能</li>\\n</ul>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/开篇.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-10-25T17:06:45.000Z\",\"path\":\"/2013/start\",\"title\":\"开篇\",\"excerpt\":\"网络博客\",\"tags\":[]}}}],\"pathPrefix\":\"\",\"first\":false,\"last\":true,\"index\":3,\"pageCount\":3}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---3-12baebfdc0ab68f484ae.js","module.exports = {\"data\":{\"allMarkdownRemark\":{\"totalCount\":26,\"edges\":[{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2020/如何打造一个serverless的微信小程序.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"如何打造一个serverless的微信小程序\",\"date\":\"January 11, 2020\",\"path\":\"/2020/how-to-build-a-serverless-wechat-mini-program\",\"tags\":[\"serverless\",\"微信小程序\",\"AWS\",\"Anki\",\"背单词\"],\"excerpt\":\"本文介绍了一个完全serverless的应用开发过程以及所用技术的简单介绍。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2019/Tokio Future.poll返回NotReady.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"自定义Tokio Future.poll返回NotReady\",\"date\":\"March 01, 2019\",\"path\":\"/2019/rust-tokio-futures-poll-not-ready\",\"tags\":[\"rust\",\"tokio\",\"Future\",\"async programming\"],\"excerpt\":\"如何在Future.poll中返回Async::NotReady\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/How To Read Rust API Doc.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"How To Read Rust API Doc\",\"date\":\"June 01, 2018\",\"path\":\"/2018/how-to-read-rust-api-doc\",\"tags\":[\"rust\"],\"excerpt\":\"\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/简单比较下http2和http1.1的性能.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"简单比较下http/2和http/1.1的性能\",\"date\":\"March 19, 2018\",\"path\":\"/2018/simple-performance-comparison-between-http2-and-http1\",\"tags\":[\"http/2\",\"测试\"],\"excerpt\":\"简单对比http/1.1和http/2的性能\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/微服务架构下的开发环境问题.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"微服务架构下的开发环境问题\",\"date\":\"March 16, 2018\",\"path\":\"/2018/development-environment-for-microservices\",\"tags\":[\"微服务\",\"架构\",\"开发环境\",\"microservices\"],\"excerpt\":\"本文介绍如何在微服务架构下解决开发环境的搭建、共享的问题。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/为Gatsby博客添加分页功能.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"为Gatsby博客添加分页功能\",\"date\":\"March 12, 2018\",\"path\":\"/2018/support-pagination-for-gatsby-blog\",\"tags\":[\"blog\",\"gatsby\"],\"excerpt\":\"根据Egghead上的教程，做出的博客站点有个缺陷，那就是没有分页功能，对于勤奋的博主来说，在一个页面上显示所有文章列表有点不完美，这里我们改造一下，加入分页功能。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/为你的Gatsby博客添加评论功能.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"为你的Gatsby博客添加评论功能\",\"date\":\"March 12, 2018\",\"path\":\"/2018/enable-comments-for-gatsby-blog\",\"tags\":[\"blog\"],\"excerpt\":\"Gatsby打造的博客已经很不错了，但是缺少一个评论功能。本文简单介绍如何集成Disqus评论服务到你的博客站点。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/转用Gatsby搭建博客.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"转用Gatsby打造基于github的博客站点\",\"date\":\"March 08, 2018\",\"path\":\"/2018/blog-with-gatsby\",\"tags\":[\"blog\",\"github\",\"gatsby\"],\"excerpt\":\"如何用Gatsby打造一个博客\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/一则奇怪的Toubleshooting.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"记一次奇怪的troubleshooting\",\"date\":\"March 08, 2018\",\"path\":\"/2018/skipper-sni-domain-fronting\",\"tags\":[\"skipper\",\"SNI\",\"domain fronting\"],\"excerpt\":\"在Skipper转发请求到一个https站点的时候，返回莫名404.\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2016/JSON解析利器JQ.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"JSON解析利器---JQ\",\"date\":\"March 25, 2016\",\"path\":\"/2016/jq\",\"tags\":[\"bash\",\"jq\",\"json\"],\"excerpt\":\"在API first的时代，json作为最常用的格式，充斥着程序猿的屏幕各个角落，掌握一门解析、过滤、转换json输出的工具，已经成为程序猿们安身立命的必要技能。 这里隆重向大家介绍[jq](https://stedolan.github.io/jq/).\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2016/Function的协变.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Function的协、逆变\",\"date\":\"February 04, 2016\",\"path\":\"/2016/function-covariant-contravariant\",\"tags\":[\"scala\",\"functional programming\"],\"excerpt\":\"泛型编程的时候，协变(covariant)还是逆变(contravariant)很重要，在设计上层API接口的时候，正确的使用协变、逆变可以更好地约束程序员的行为，让实现变得安全、一致。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/如何在Scala中实现AOP.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"用Mixin组合实现Scala中的AOP\",\"date\":\"August 13, 2015\",\"path\":\"/2015/aop-by-mixin-in-scala\",\"tags\":[\"scala\",\"functional programming\",\"AOP\",\"mixin\"],\"excerpt\":\"在Java世界，AOP（Aspect Oriented Programming， 面向方面编程)是很多框架的基础。这种将关注点按照“方面”来切分的编程模型极大地简化了编程的复杂度，尤其是在多维度因子交织在一起的时候的各种场景。对于代码的可读性、可维护性、可重用性都是极大的帮助。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Scala雾里看花.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Scala雾里看花\",\"date\":\"April 23, 2015\",\"path\":\"/2015/scala-trouble-shooting\",\"tags\":[\"scala\",\"trouble shooting\"],\"excerpt\":\"Scala的学习过程中，经常会碰到一些莫名其妙的现象，很多时候，这些语言层面的“怪象”都与scala编译器或者scala的类型系统有关。本文不是对编译器和类型系统的介绍，而是重点介绍遇到这些现象的时候，用什么样的方式，拨开云雾见蓝天，通过这些工具获取一些细节帮你了解编译器和类型系统如何工作。工欲善其事，必先利其器。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Docker创建MySQL主从复制以及CDC测试.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"MySQL Master/Slave Replication on Docker\",\"date\":\"April 21, 2015\",\"path\":\"/2015/mysql-replication-on-docker\",\"tags\":[\"docker\",\"mysql\"],\"excerpt\":\"How to setup Mysql master/slave replication.\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2014/Scala函数式异常处理.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Scala函数式异常处理\",\"date\":\"May 04, 2014\",\"path\":\"/2014/scala-error-handling-in-fp-style\",\"tags\":[\"scala\",\"functional programming\",\"exception handling\"],\"excerpt\":\"经常看到很多示例代码，简洁的让人爱不释手，可是真正自己实现的时候，不得不添加各种各样的异常处理逻辑，最后发现代码总量的80%都是再做异常处理，而真正的代码逻辑只有很少的一部分。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2014/高种泛型.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"高种泛型 (Generics of a Higher Kind)\",\"date\":\"January 08, 2014\",\"path\":\"/2014/generics-of-a-higher-kind\",\"tags\":[\"scala\",\"functional programming\",\"Generics\"],\"excerpt\":\"Generics of a Higher Kind翻译加自我理解。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/map-flatMap-for.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"map/flatMap/for in Action\",\"date\":\"December 01, 2013\",\"path\":\"/2013/map-flatmap-for\",\"tags\":[\"scala\",\"functional programming\"],\"excerpt\":\"前文说过了，高阶函数式函数式语言中的基石，而`map`, `flatMap`更是重要。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/fold编程.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"折纸的艺术：fold编程\",\"date\":\"November 27, 2013\",\"path\":\"/2013/fold\",\"tags\":[\"scala\",\"functional programming\",\"fold\"],\"excerpt\":\"Eric Meijer说：递归是函数式编程的GOTO，应该尽可能避免。如何避免，OO中我们用while循环，FP中我们用`fold`。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Monad.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Monad\",\"date\":\"November 26, 2013\",\"path\":\"/2013/monad\",\"tags\":[\"scala\",\"functional programming\",\"monad\"],\"excerpt\":\"函数式语言与OO（确切地讲是指令式编程）的思维方式是完全不同的，很多OO中的经验在函数式语言中不是很匹配，比如设计模式，那就是一个OO中的特定术语，而在FP中，大家常谈的是对于习惯OO思维的程序员来说玄而又玄的Monad。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/高阶函数.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"高阶函数\",\"date\":\"November 21, 2013\",\"path\":\"/2013/high-order-function\",\"tags\":[\"scala\",\"functional programming\",\"high order function\"],\"excerpt\":\"所谓高阶函数（high order function），其实就是可以接受其他函数作为参数的函数。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Actor协调并发场景下的集合操作.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"边建边学-3：Actor协调并发场景下的集合操作\",\"date\":\"November 17, 2013\",\"path\":\"/2013/actor-collection-collabration\",\"tags\":[\"scala\",\"functional programming\"],\"excerpt\":\"很多时候为了提高性能，减少IO操作，都会将数据load出来之后缓存在内存中。本站的实现过程中也遇到类似的问题，不希望每次有人访问的时候就读取一次md文件，或者从MongoDB中查一次，而是直接在内存中读取。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Enumerator-Iteratee-Enumeratee.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Enumerator / Iteratee / Enumeratee\",\"date\":\"November 11, 2013\",\"path\":\"/2013/enumerator-iteratee-enumeratee\",\"tags\":[\"scala\",\"playframework\",\"blog\"],\"excerpt\":\"Stream对于指令式编程已经比较成熟了，有大量的类库，丰富的API。但是对于强调不可变量，尽可能无副作用的FP来说，要考虑语言适配的问题，而目前，流行的解决方案就是：Enumerator/Iteratee。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/集成PlantUML和Markdown.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"边建边学-2：集成PlantUML和Markdown\",\"date\":\"November 07, 2013\",\"path\":\"/2013/markdown-plantuml-integration\",\"tags\":[\"markdown\",\"plantuml\",\"blog\"],\"excerpt\":\"如何用Markdown+PlantUML结合来写图文并茂的博客。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/EssentialAction-in-Playframework.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"EssentialAction in Playframework\",\"date\":\"November 05, 2013\",\"path\":\"/2013/essential-action-in-play\",\"tags\":[\"scala\",\"playframework\"],\"excerpt\":\"Playframework中EssentialAction理解\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/用markdown写博客.markdown absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"边建边学-1: 用Markdown写博文\",\"date\":\"November 01, 2013\",\"path\":\"/2013/blogging-with-markdown\",\"tags\":[\"markdown\",\"blog\"],\"excerpt\":\"本文将是一个系列文章，循序渐进地介绍本站的构建过程，不只是简单的技术介绍，重点是建站过程遇到的问题分析，以及解决的过程，所以起名**“边建边学”**系列。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/开篇.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"开篇\",\"date\":\"October 25, 2013\",\"path\":\"/2013/start\",\"tags\":[],\"excerpt\":\"网络博客\"}}}]}},\"pathContext\":{\"group\":[{\"node\":{\"html\":\"<h2>上下文</h2>\\n<p>很多时候为了提高性能，减少IO操作，都会将数据load出来之后缓存在内存中。本站的实现过程中也遇到类似的问题，不希望每次有人访问的时候就读取一次md文件，或者从MongoDB中查一次，而是直接在内存中读取。</p>\\n<p>带来因减少IO而提升性能的好处的同时，也出现一个人和“缓存”解决方案都会遇到的问题：数据一致性。</p>\\n<p>简单来说，就是你有同样的一份数据，冗余存放在两个地方，如何确保这两个地方的数据是一致的？再具体一点，可能的问题有：</p>\\n<ul>\\n<li>\\n<p>数据更新的原子性</p>\\n<p>更新数据的时候，同时将两个地方的数据都同步更新，任何一个地方更新失败，则整体更新失败。</p>\\n</li>\\n<li>\\n<p>缓存线程安全的问题</p>\\n<p>如果缓存既可以被读取，又可能被更新，那么就又线程安全问题：多个线程同时操作同一个值的时候怎么协调？</p>\\n</li>\\n</ul>\\n<h2>具体问题</h2>\\n<p>开始的时候，我将所有的文章列表放在一个<code>scala.collection.mutable.ListBuffer</code>中：</p>\\n<!-- language:lang-scala -->\\n<pre><code>object Application extends Controller {\\n  lazy val allPosts: ListBuffer[Post] = ...\\n\\n}\\n</code></pre>\\n<p>因为新发布博客会增加集合内数据，所以这里用ListBuffer比较自然。当然用<code>var</code> + immutable collection也可以。</p>\\n<p>对<code>allPost</code>的操作主要有三个：</p>\\n<ol>\\n<li>\\n<p>在线编写一个博客的时候需要添加到集合中</p>\\n</li>\\n<li>\\n<p>该集合本身是无序的，因为排序的规则可能有多种，展现的时候再排序</p>\\n</li>\\n<li>\\n<p>更新一篇博文的时候同时更新集合中内容。</p>\\n</li>\\n</ol>\\n<p>因为本身Application Object是单例的，多个线程共同运行的场景下就会出现线程安全的问题，类似Servlet中instance级别变量的问题。</p>\\n<h2>解决方案</h2>\\n<p>直观地想，理想的解决方案就是将所有对<code>allPost</code>的写操作都串行起来，这样即使有多个线程同时操作，也没问题了。但是如何将实现串行呢？</p>\\n<p>在指令式编程的世界里，这个问题比较难于解答，一般需要通过加锁来解决。而一般的程序员看到<code>lock</code>, <code>synchronized</code>这些关键字就头疼了，即使经过无数次盲试之后侥幸实现了，也会在产品上线的时候出现这样那样、莫名其妙、让你大呼“这不科学”，“WTF”的惊呼！</p>\\n<p>但是在scala中，我们却不用担心，因为我们有<code>Akka Actor</code>。</p>\\n<p>Actor是另外一种并行计算方式，不同于线程共享内存的并发模型，Actor是基于消息的，强调不同Actor之间不共享数据。有了Actor，问题就迎刃而解了。</p>\\n<p>具体思路是：重建一个单例Actor，由该Actor来维护ListBuffer变量，所有的写操作，全部通过该消息提交任务交给其处理，这样就将并发的多个写请求串行起来了。</p>\\n<p>代码片段：</p>\\n<!-- language:lang-scala -->\\n<pre><code>object PostManager {\\n  // 单例manager actor\\n  lazy val manager = Akka.system.actorOf(Props[PostManager])\\n  case class NewPost(post: Post)\\n  \\n  def saveOrUpdate(unsavedPost: Post) = {\\n    manager ! NewPost(unsavedPost)\\n  }\\n}\\n\\nclass PostManager extends Actor {\\n  import PostManager._\\n  // actor是单例的，所以文章集合也是单例的。\\n  // all posts, but not ordered.\\n  lazy val allPosts: ListBuffer[Post] = Post.allPosts\\n  \\n  def receive = {\\n    case NewPost(newPost) =>\\n      // 先更新数据库，这样如果更新失败，就不会运行之后代码。一定程度上实现原子性。\\n      Post.upsert(newPost)\\n      \\n      val idx = allPosts.indexWhere( _.fileName == newPost.fileName )\\n      \\n      if (idx == -1){\\n        allPosts += newPost\\n      } else {\\n        allPosts.update(idx, newPost)\\n      }\\n  }\\n}\\n</code></pre>\\n<p>全站一个文章集合变量感觉有点\\\"玩具\\\"的感觉，不过这个模型其实是可以扩展的，比如将来如果支持多用户、多博客系统，我们可以每个用户创建一个Actor、维护该用户自己的文章列表。这个Actor模型还是可以重用的。</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Actor协调并发场景下的集合操作.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-17T14:16:45.000Z\",\"path\":\"/2013/actor-collection-collabration\",\"title\":\"边建边学-3：Actor协调并发场景下的集合操作\",\"excerpt\":\"很多时候为了提高性能，减少IO操作，都会将数据load出来之后缓存在内存中。本站的实现过程中也遇到类似的问题，不希望每次有人访问的时候就读取一次md文件，或者从MongoDB中查一次，而是直接在内存中读取。\",\"tags\":[\"scala\",\"functional programming\"]}}},{\"node\":{\"html\":\"<h2>Context</h2>\\n<p>插曲：前不久微博上看到一技术“牛人”大V评论Java8的一些特性，引入lambada但没有扩展能力，集合的查询都得靠新stream api而不是Enumerator / Iterator云云。一时手欠回复了下“似乎应该是Enumerator / Iteratee“, 结果引来一身骚，被该大V泼口大骂了一个下午，没错就是像网吧里面无聊的小青年一样无营养地谩骂，实在没搞懂到底是为什么，说我说的Iteratee和他说的没”鸡毛“关系，不懂，也不想搞懂了，还是他玩他的Iterator我介绍我的Iteratee吧。</p>\\n<p>因为我们的内存、磁盘等资源还是有限的，对于一个大的Stream，Collection，我们在处理的时候不应该将其作为整体进行处理，因为这样会带来潜在的风险，比如：内存溢出，降低系统吞吐量等等。</p>\\n<p>正确的方式是将大的不可预见（unpredictable）的stream，Collection进行分解，将其分解为小的，可预见（predictable）的块进行处理。这是流模式的思想，也是Iteratee的设计目标之一。</p>\\n<p>Stream对于指令式编程已经比较成熟了，有大量的类库，丰富的API。但是对于强调不可变量，尽可能无副作用的FP来说，要考虑语言适配的问题，而目前，流行的解决方案就是：Enumerator/Iteratee。</p>\\n<p>另外，就是需要用统一的API来处理所有类型的Stream，就像指令式编程中的<code>InputStream.read</code>, <code>OutputStream.write</code>，无论什么Stream都需要支持这些基本方法。</p>\\n<h2>High Level Concept Model</h2>\\n<p>Enumerator / Iteratee说起来很复杂，其实就是一个生产者 / 消费者模型。 Enumerator是生产者，创建诸多个可控的chunk，Iteratee是消费者，消费任意类型的Input Chunk。</p>\\n<!-- language:lang-scala -->\\n<pre><code>trait Enumerator {\\n  def |>>[A](i: Iteratee[E, A]): Future[Iteratee[E, A]] = apply(i)\\n}\\n</code></pre>\\n<p>Enumerator驱动一个Iteratee，Iteratee处理一个Chunk之后，返回下一个状态的Iteratee. 在构造Enumerator的时候不会真正读取数据，只有在真正消费时才产生IO。</p>\\n<p>而且多个Enumerator之间可以组合，不同类型的消费者（Iteratee）也可以进行组合、变换，简言之，组合的概念就是将每个Enumerator / Iteratee都看成是一个可组合的积木，每个积木相对独立可复用，写代码就是将这些积木组合达成你想要形状的过程。这个说法很常见，OO里提倡“组合优于继承”也是一样的思想，其中的关键是如何找到最小的可复用的component，然后是通过什么样的方式进行灵活地组合。</p>\\n<p>Enumerator / Iteratee / Enumeratee就是一个非常好的例子。</p>\\n<h2>消费者 Iteratee</h2>\\n<!-- language:lang-scala -->\\n<pre><code>class Iteratee &#x3C;&#x3C; (T, #00FF00) >> {\\n  Future[B] fold[B](folder: Step[E, A] => Future[B])\\n}\\nclass ImmediateIteratee &#x3C;&#x3C; (T, #00FF00) >>\\nclass Done &#x3C;&#x3C; (O, #FF0000) >>\\nclass Cont &#x3C;&#x3C; (O, #FF0000) >>\\nclass Error &#x3C;&#x3C; (O, #FF0000) >>\\nclass Step &#x3C;&#x3C; (T, #00FF00) >>\\nclass Input &#x3C;&#x3C; (T, #00FF00) >>\\n\\nIteratee &#x3C;|-- ImmediateIteratee\\nIteratee &#x3C;|-- FutureIteratee\\nIteratee &#x3C;.left.> Step\\nStep .left.> Input\\n\\nImmediateIteratee &#x3C;|-- DoneIteratee\\nDoneIteratee .. Done\\nImmediateIteratee &#x3C;|-- ContIteratee\\nContIteratee .. Cont\\nImmediateIteratee &#x3C;|-- ErrorIteratee\\nErrorIteratee .. Error\\n\\nnote \\\"company objects\\\" as oNote\\nDone .. oNote\\nCont .. oNote\\nError .. oNote\\n</code></pre>\\n<p>Iteratee是一个Input的消费者，注意：这里的Input不是全部输入，而是a chunk of input，这个很重要，没有一个Iteratee来消费所有输入数据，而是每块一个消费者，然后通过函数组合的方式将所有块穿起来。</p>\\n<ul>\\n<li>\\n<p>为什么不是一个完整输入对应一个消费者呢？\\n这是指令式编程的思维方式，因为你需要自己考虑实现细节，设计一些游标，每次读取步进的长度，判断游标的位置来判断下一步如何操作。</p>\\n</li>\\n<li>\\n<p>为什么不是所有的输入chunk共享一个消费者呢？\\n嗯，这个问题我不是很确定，应该是有一部分上面的原因，另外就是副作用的问题，每个Step自己维护自己的状态，可以比较容易地实现“懒加载”，在最后一步（调用<code>run</code>）的时候才真正发生IO，而之前，可以通过函数组合任意对每一步进行transform等操作。</p>\\n</li>\\n</ul>\\n<p>Iteratee还有一个需要注意的地方，fold函数是一个<code>curried function</code>，有一个implicit的参数ExecutionContext，也就是在哪个线程池中执行，这个现象在Play中很普遍。</p>\\n<p>ImmediateIteratee描述了一个已经预先知道其state的Iteratee，而FutureIteratee当然就是未来才能知道其State的Iteratee。[个人感觉这个地方设计有点怪，FutureIteratee似乎应该用Future[Iteratee]更好。] </p>\\n<!-- language:uml -->\\n<pre><code>class Step &#x3C;&#x3C; (T, #00FF00) >> {\\n  Iteratee[E, A] it\\n}\\nclass Iteratee &#x3C;&#x3C; (T, #00FF00) >>\\nclass Input &#x3C;&#x3C; (T, #00FF00) >>\\nStep .left.> Input\\nStep &#x3C;-right-> Iteratee\\nStep &#x3C;|-- Done\\nStep &#x3C;|-- Cont\\nStep &#x3C;|-- Error\\n</code></pre>\\n<p>Step描述的是一个Iteratee的状态，其本身包含一个Iteratee不变量<code>it</code>，而Done、Cont、Error也是简单的<code>case class</code>，所以构造也很简单。</p>\\n<!-- language:uml -->\\n<pre><code>class Input &#x3C;&#x3C; (T, #00FF00) >>\\nInput &#x3C;|-- El\\nInput &#x3C;|-- Empty\\nInput &#x3C;|-- EOF\\n</code></pre>\\n<p>Input[E]描述的是<code>一块</code>输入(a chunk of input，不是全部输入)，构造其实很简单，就是一个简单的case class，可以按照你熟悉的方式来构造。</p>\\n<h2>生产者 Enumerator</h2>\\n<p>先来看看Enumerator的定义：</p>\\n<!-- language:lang-scala -->\\n<pre><code>trait Enumerator[E] {\\n\\n  /**\\n   * Apply this Enumerator to an Iteratee\\n   */\\n  def apply[A](i: Iteratee[E, A]): Future[Iteratee[E, A]]\\n  def |>>[A](i: Iteratee[E, A]): Future[Iteratee[E, A]] = apply(i)\\n  ...\\n\\n}\\n</code></pre>\\n<p>由上面定义可以看到，一个<code>Enumerator</code>接受一个<code>Iteratee[E, A]</code>，并返回一个<code>Future[Iteratee[E, A]]</code>，翻译一下就是：Enumerator驱动一个消费者，消费数据之后产生一个下个状态的消费者。</p>\\n<p>Enumerator提供了大量的工厂方法（在scala中是通过伴生对象来实现），比如，你可以从一个数组创建一个Enumerator:</p>\\n<!-- language:lang-scala -->\\n<pre><code>val enumerateCountries = Enumerator[String] = Enumerator(\\\"China\\\", \\\"America\\\", \\\"Japan\\\", \\\"Russia\\\", \\\"England\\\")\\n</code></pre>\\n<p>可以从一个文件中创建：</p>\\n<!-- language:lang-scala -->\\n<pre><code>val enumerateFile: Enumerator[Array[Byte]] = Enumerator.fromFile(new File(\\\"path/to/some/big/file\\\"))\\n</code></pre>\\n<p>或者从一个Stream中创建：</p>\\n<!-- language:lang-scala -->\\n<pre><code>val enumerateFile: Enumerator[Array[Byte]] = Enumerator.fromStream(new java.io.FileInputStream(new File(\\\"path/to/some/big/file\\\")))    \\n</code></pre>\\n<p>更加通用的方式是从一个<code>e: ()=>Future[Option[E]]</code>函数来创建，因为这个函数声明了：未来可能会产生一个<code>E</code>:</p>\\n<!-- language:lang-scala -->\\n<pre><code>def generateM[E](e: => Future[Option[E]])(implicit ec: ExecutionContext): Enumerator[E] = {\\n    ...\\n}\\n</code></pre>\\n<p>发挥一下你的想象，很多事情都可以看成是Stream，比如时间：</p>\\n<!-- language:lang-scala -->\\n<pre><code>import play.api.libs.concurrent.Promise\\nimport play.api.libs.iteratee._\\nimport scala.concurrent.duration._\\nimport scala.concurrent.ExecutionContext.Implicits.global\\nimport java.util.Date\\n\\n// 截止时间\\nval alertTo = new Date(System.currentTimeMillis + 1000*60)\\n\\n// 一个时间流，截止到alertTo\\nval timeStream = Enumerator.generateM {\\n    Promise.timeout(\\n      if (new Date before alertTo) Some(new Date) else None, \\n      1 seconds)\\n}\\n\\nval printlnSink = Iteratee.foreach[Date](date => println(date))\\n// 每隔一秒钟打印一次，直到alertTo\\ntimeStream |>> printlnSink\\n</code></pre>\\n<p>如果你想再play console里面运行上面的代码，可能会失败，说什么:no application started之类的，这时你需要前面加上：</p>\\n<!-- language:lang-scala -->\\n<pre><code>val app = new play.core.StaticApplication(new java.io.File(\\\".\\\"))\\n</code></pre>\\n<p>创建一个测试用的application，再试一下就OK了。</p>\\n<p>除了这个例子，我觉得也可以将数据库中的游标查询用Enumerator来实现。</p>\\n<p>在Play框架中，还有一个实际的例子是<code>WebSocket</code>，有机会我们再单独介绍。</p>\\n<h2>适配器 Enumeratee</h2>\\n<p>对应OO Design Pattern中的Adaptor模式，<code>Enumeratee</code>就是一个Adaptor，将不同规格的组件适配在一起。比如下面这个例子：</p>\\n<p>我们有一个String类型的Enumerator, <code>Enumerator(\\\"123\\\", \\\"456\\\", \\\"789\\\", \\\"222\\\", \\\"333\\\", \\\"444\\\")</code>，还有一个累加器，<code>Iteratee.fold[Long, Long](0:Long) { (acc, el) => acc + el }</code>，两者的“规格”是不同的，一个是String， 但另外一个是Long，当然我们可以再定义一个新的Iteratee，比如：<code>Iteratee.fold[String, Long](0:Long) { (acc, el) => acc + el.toLong }</code>，但是显然，这里面有重复代码的臭味道。更加合理的方式是做一个适配，用一个适配器来讲两个已经存在的component转接后一起工作。</p>\\n<!-- language:lang-scala run -->\\n<pre><code>import play.api.libs.iteratee._\\nimport scala.concurrent.ExecutionContext.Implicits.global\\n\\nval strings = Enumerator(\\\"123\\\", \\\"456\\\", \\\"789\\\", \\\"222\\\", \\\"333\\\", \\\"444\\\")\\nval sum = Iteratee.fold[Long, Long](0:Long) { (acc, el) => acc + el }\\nval toLong = Enumeratee.map[String]( x => x.toLong )\\n\\nstrings |>> toLong &#x26;>> sum flatMap { x => x.run } onSuccess { case s => println(s) }\\n// Or, transform the Enumerator first.\\nstrings &#x26;> toLong |>> sum flatMap { x => x.run } onSuccess { case s => println(s) }\\n</code></pre>\\n<p>上面例子可以看到，<code>Enumeratee</code>不但可以适配<code>Iteratee</code>，还可以转换<code>Enumerator</code>。</p>\\n<p>留个问题：<code>strings &#x26;> toLong</code>会不会产生memory的问题？ </p>\\n<h2>指令式 VS. 函数式</h2>\\n<p>这里用一个很无聊的例子：遍历一个大文件来统计文件大小。</p>\\n<h3>指令式风格</h3>\\n<p>Use Java FileInputStream, more imperative style:</p>\\n<!-- language:lang-scala -->\\n<pre><code>val fis = new java.io.FileInputStream(new java.io.File(\\\"/Users/leo/Movies/big_file.mkv\\\"))\\n\\n// mutable variables\\nvar readLength = 0\\nvar fileSize: Long = 0\\nvar buf = new Array[Byte](1024 * 8) // chunk size used in Enumerator\\nval begin = System.currentTimeMillis\\ndo {\\n  readLength = fis.read(buf)\\n  if (readLength != -1)\\n    fileSize = fileSize + readLength\\n}while(readLength != -1)\\n\\nprintln(s\\\"File Size: $fileSize, and it took ${System.currentTimeMillis - begin} ms\\\")\\n</code></pre>\\n<p>And output like <code>File Size: 4003885806, and it took 54701 ms</code>, the memory usage is about <code>78Mb</code>.</p>\\n<h3>函数式风格</h3>\\n<p>Use Enumerator / Iteratee to get file size:</p>\\n<!-- language:lang-scala -->\\n<pre><code>import play.api.libs.iteratee._\\n// construct an Enumerator from a file\\nval fileEnum = Enumerator.fromFile(new java.io.File(\\\"/Users/leo/Movies/big_file.mkv\\\")) \\n// create a consumer\\nval counter = Iteratee.fold[Array[Byte], Long](0: Long){ (acc, ele) => ele.size + acc }\\n\\nval begin = System.currentTimeMillis\\n// where the IO really happens.\\nIteratee.flatten(fileEnum |>> counter).run.onSuccess { case x => println(s\\\"File Size: $x, and it took ${System.currentTimeMillis - begin} ms\\\") }\\n</code></pre>\\n<p>Here's the output: <code>File Size: 4003885806, and it took 57213 ms</code>, and max memory usage is about <code>120Mb</code>. </p>\\n<p>Note: If you are running above code with Scala version &#x3C; 2.10.3, you'll run into <code>OutOfMemory</code> Error, it's so funny right? Enumerator / Iteratee suppose to be designed to solve the OutOfMemory issue, actually, it's not Enumerator/Iteratee 's problem, it's a bug of scala, see <a href=\\\"https://issues.scala-lang.org/browse/SI-7336\\\">SI-7336</a></p>\\n<h3>对比</h3>\\n<p>从上面的两种实现来看，从执行时间上，两种方式没有太大差异，但是指令式编程在内存占用方面要优于函数式编程，毕竟var变量可以复用，val变量需要重新生成。但是差别并没有想象中那么大，处理一个4G的文件，差别只是40M左右。但是带来的好处是显而易见的：因为没有mutable变量，没有副作用，并发、代码可读性有提高。</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Enumerator-Iteratee-Enumeratee.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-11T14:16:45.000Z\",\"path\":\"/2013/enumerator-iteratee-enumeratee\",\"title\":\"Enumerator / Iteratee / Enumeratee\",\"excerpt\":\"Stream对于指令式编程已经比较成熟了，有大量的类库，丰富的API。但是对于强调不可变量，尽可能无副作用的FP来说，要考虑语言适配的问题，而目前，流行的解决方案就是：Enumerator/Iteratee。\",\"tags\":[\"scala\",\"playframework\",\"blog\"]}}},{\"node\":{\"html\":\"<p>Markdown是一个很爽的写作格式（或者说语言更合适一点），我们不再需要复杂的富文本编辑器，用纯文本就可以编写出布局漂亮的文章。</p>\\n<p>不过Markdown对于技术类文章来说还有一个不足：我们经常需要画一些图来阐述自己的思路，但是Markdown只能引用已经存在的图。</p>\\n<p>有没有可能用Plain Text来画图呢？AscII艺术图？太原始了。试试PlantUML吧。</p>\\n<h2>PlantUML介绍</h2>\\n<p>从某个角度说，<a href=\\\"http://plantuml.sourceforge.net\\\">PlantUML</a>简直就是Markdown的绝配，也只需要纯文本就可以实现漂亮的效果，只是这里变成更炫的UML图。</p>\\n<p>比如我想画一个类图，Cat和Dog继承Animal，用PlantUML来实现就是：</p>\\n<pre><code>@startuml\\nAnimal &#x3C;|-- Cat\\nAnimal &#x3C;|-- Dog\\n@enduml\\n</code></pre>\\n<p>是不是很简单？来看看效果：</p>\\n<!-- language:uml -->\\n<pre><code>Animal &#x3C;|-- Cat\\nAnimal &#x3C;|-- Dog\\n</code></pre>\\n<p>怎么样？不错吧，这个图片哪里来的？其实在我发布这篇文章的时候，这个类图还不存在，只有在你访问这篇文章的时候才自动生成的。PlantUML有一个jQuery插件，可以在运行时生成图片。</p>\\n<p>PlantUML的jQuery插件用法很简单，你只需要在html中编辑：</p>\\n<!-- language:lang-html -->\\n<pre><code>&#x3C;img uml=\\\"\\n  Animal &#x3C;|-- Cat\\n  Animal &#x3C;|-- Dog\\n\\\">\\n</code></pre>\\n<p>jQuery插件会自动增强这个img元素，具体实现还挺有意思，这里不细说了。</p>\\n<p>可这还不够，怎么在Markdown中写<code>img</code>呢？如果你照抄上面的img代码，pegdown解析器会抛错，'&#x3C;'不匹配云云。</p>\\n<h2>解决方案</h2>\\n<p>基本上这种问题可以从两个方面想办法，一个是服务器端，实现一个markdown parser plugin，来定制一个特殊语法，另一个方向是从浏览器端想办法。</p>\\n<p>从上面的介绍中我们知道，已经有jQuery插件了，那从前端做似乎更加容易一些。此外，从<a href=\\\"http://www.learn-scala.net/blogs/2013-11-01_14.md\\\">上一篇</a>我们已经知道，在<code>pre code</code>前面加上一个<code>&#x3C;!-- language:lang-scala --></code>来实现语法高亮显示问题。</p>\\n<p>PlantUML的内容也可以认为是一种code，很自然地，我们可以用<code>pre code</code>来封装。比如我们可以用：</p>\\n<!-- language:lang-html -->\\n<pre><code>&#x3C;!-- language:uml -->\\n    Animal &#x3C;|-- Cat\\n    Animal &#x3C;|-- Dog\\n</code></pre>\\n<p>这里我们自定义了一种language类型<code>uml</code>，在前端解析的时候，就能知道这个代码块是用来画图的了。</p>\\n<p>好，我们来看前端JS代码的实现：</p>\\n<!-- language:lang-javascript -->\\n<pre><code>function init() {\\n  var plantuml = false;\\n  var blocks = document.querySelectorAll('pre code');\\n  // 遍历所有pre code\\n  for (var i = 0; i &#x3C; blocks.length; i += 1) {\\n    var code = blocks[i];\\n    //code.className += ' prettyprint';\\n    var pre = code.parentNode;\\n    var above = pre;\\n    do {\\n      above = above.previousSibling;\\n    } while (above.nodeType == Node.TEXT_NODE)\\n    // 检查注释元素据\\n    if (above.nodeType == Node.COMMENT_NODE) {\\n      var comment = above.data;\\n      // 正则表达式，获取语言类型\\n      var pattern = /^\\\\s*language:\\\\s*([\\\\w\\\\-]+)\\\\s*(\\\\w+)?\\\\s*$/i;\\n      var match = pattern.exec(comment);\\n      if (match != null) {\\n        var lang = match[1];\\n        // 如果是uml，动态生成一个img元素，并设置uml属性值为pre code的内容。\\n        if (lang &#x26;&#x26; lang == \\\"uml\\\") {\\n          var container = document.createElement(\\\"div\\\");          \\n          var img = document.createElement(\\\"img\\\");\\n          img.setAttribute(\\\"uml\\\", code.innerText || code.textContent);\\n\\n          container.appendChild(img);\\n          container.className = \\\"text-center\\\";\\n\\n          pre.insertAdjacentElement('afterEnd', container);\\n          // 将pre code隐藏起来，只显示图片\\n          pre.style.display = \\\"none\\\";\\n          plantuml = true;\\n        }\\n      }\\n    }\\n  }\\n  // 调用jQuery插件生成图片。\\n  if (plantuml) {\\n    plantuml_runonce();\\n  }\\n}\\n</code></pre>\\n<p>然后，在html中调用：</p>\\n<!-- language:lang-html -->\\n<pre><code>&#x3C;script type='text/javascript'>\\n  window.onload = init;    \\n&#x3C;/script>  \\n</code></pre>\\n<p>搞定，收工！！写作、布局编排、画图全部纯文本，爽！</p>\\n<p>附上一个PlantUML的参考文档，原本上sourceforge网站就可以了，可惜被墙了，点击<a href=\\\"http://www.learn-scala.net/assets/ebooks/PlantUML_Language_Reference_Guide.pdf.zip\\\">这里</a>下载吧。</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/集成PlantUML和Markdown.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-07T19:16:45.000Z\",\"path\":\"/2013/markdown-plantuml-integration\",\"title\":\"边建边学-2：集成PlantUML和Markdown\",\"excerpt\":\"如何用Markdown+PlantUML结合来写图文并茂的博客。\",\"tags\":[\"markdown\",\"plantuml\",\"blog\"]}}},{\"node\":{\"html\":\"<h2>Play!框架的核心</h2>\\n<p>Play!的内核其实非常简单，简单地说，Play框架所实现的可以用一个函数表达式来描述：</p>\\n<p><code>RequestHeader -> Array[Byte] -> Result</code></p>\\n<p>具体讲，就是接受一个<code>RequestHeader</code>，然后读入类型为<code>Array[Byte]</code>的Request Body，计算完毕之后返回一个<code>Result</code>。</p>\\n<p>注：函数式语言的表达就是高度抽象，但异常简洁。</p>\\n<h2>问题及优化</h2>\\n<h3>文件上传</h3>\\n<p>上面的描述有一个问题：我们假定要把请求内容<em>全部</em>读入内存（或者写入磁盘），对于简单应用不是什么问题，但是对于文件上传等场景，这肯定是有问题的，所以，Play开发者做了优化。</p>\\n<p>注：此处可以看出函数式语言的一个优点：仅需要了解你的函数定义，就能分析出潜在的问题。而如果面向对象的方式一般关注在对象之间的通信、方法调用，从方法签名上往往会忽略这些细节。</p>\\n<p>优化的思路当然是将请求内容一部分一部分地读入（chunk），所以这个函数就变成了：</p>\\n<p><code>RequestHeader -> Iteratee[Array[Byte], Result]</code></p>\\n<p><code>Iteratee</code>是个什么东东？简单讲就是一个<code>Monad</code>，什么是Monad？可以类比为OO世界中的设计模式：专门为了解决某类问题的特定方法。Iteratee可以将输入（Input）分步(Step)读入，而且可以进行精细控制遇到EOF、Empty、El(chunk)的时候应该如何处理，是继续（Cont），结束（Done）还是抛错（Error）。这里不做详细介绍。有兴趣的可以参见：<a href=\\\"http://apocalisp.wordpress.com/2010/10/17/scalaz-tutorial-enumeration-based-io-with-iteratees/\\\">这篇博客</a></p>\\n<p>Iteratee本身也是一个<code>Arrow</code>（简单理解为函数），所以如果我们定义一个新类型：</p>\\n<!-- language:lang-scala -->\\n<pre><code>type ==>[E, R] = Iteratee[E, R]\\n</code></pre>\\n<p>上面的函数用scala来写就会变为：</p>\\n<!-- language:lang-scala -->\\n<pre><code>RequestHeader => Array[Byte] ==> Result\\n</code></pre>\\n<p>注：<code>==>[E, R]</code>和<code>E ==> R</code>是等价的，是scala的一个语法糖。</p>\\n<p>上面的表达式看上去更简洁，更有趣了。</p>\\n<h3>文件下载</h3>\\n<p>有了<code>Iteratee</code>我们就可以分块处理请求了，但是响应呢？同样地，如果响应中的数据量很大，比如文件下载，从上面的函数定义看，依旧会把文件完全读入到内存中，同样的问题。</p>\\n<p>解决的思路也是一样的。我们可以将<code>Result</code>看做下面的数据结构：</p>\\n<!-- language:lang-scala -->\\n<pre><code>case class Result(header: ResponseHeader, body: Array[Byte])\\n</code></pre>\\n<p>问题主要在<code>body</code>上，类型是Array[Byte]，需要有一个新的数据类型将起封装，可以分块地处理输出内容，这就是<code>Enumerator</code>，一个用来将响应数据分块(chunk)的东东。</p>\\n<p>所以最终Play框架核心可以看做下面的API：</p>\\n<!-- language:lang-scala -->\\n<pre><code>case class Result[E](headers:ResponseHeaders, body:Enumerator[E])(implicit writeable:Writeable[E])\\ntype ==>[E, R] = Iteratee[E, R]\\nRequestHeader => Array[Byte] ==> Result\\n</code></pre>\\n<p>下面我们来看看Request和Result各自的类图，了解一下都有哪些实现。</p>\\n<!-- language:uml -->\\n<pre><code>title Request Class Hierarchy\\nclass RequestHeader &#x3C;&#x3C; (T, #00FF00)>>\\nclass Request &#x3C;&#x3C; (T, #00FF00)>>\\n\\nRequestHeader &#x3C;|-- Request\\nRequest &#x3C;|-- WrappedRequest\\nRequest &#x3C;|-- FakeRequest\\nWrappedRequest &#x3C;|-- AuthenticatedRequest\\n\\ncenter footer 图一：Request 类图\\n</code></pre>\\n<p>真简单啊，比OO世界里面的一些MVC框架中的类层次结构少多了。</p>\\n<!-- language:uml -->\\n<pre><code>title Result Class Hierarchy\\nclass WithHeaders &#x3C;&#x3C; (T, #00FF00) >>\\nclass Result &#x3C;&#x3C; (T, #00FF00) >>\\n\\nclass PlainResult &#x3C;&#x3C; (T, #FF0000) deprecated>>\\nclass AsyncResult &#x3C;&#x3C; (C, #FF0000) deprecated>>\\nclass ChunkedResult &#x3C;&#x3C; (D, #FF0000) deprecated>>\\n\\nWithHeaders &#x3C;|-- Result\\nResult &#x3C;|-- PlainResult\\nResult &#x3C;|-- AsyncResult\\nPlainResult &#x3C;|-- SimpleResult\\nSimpleResult &#x3C;|-- ChunkedResult\\nSimpleResult &#x3C;|-- Status\\n\\ncenter footer 图二：Result 类图\\n</code></pre>\\n<p>目前Play2.2中Result有两个子类：PlainResult和AsyncResult，但这两个Result已经被标记为deprecated了，从2.3开始，Play将只支持SimpleResult。为什么呢？ 想想其实很简单：单一职责原则。所谓<code>AsyncResult</code>其实本身职责不单一，有异步和Result两个，而直接使用：<code>Future[SimpleResult]</code>则清晰很多。另外ChunkedResult被废弃的原因也一样。</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/EssentialAction-in-Playframework.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-05T09:16:45.000Z\",\"path\":\"/2013/essential-action-in-play\",\"title\":\"EssentialAction in Playframework\",\"excerpt\":\"Playframework中EssentialAction理解\",\"tags\":[\"scala\",\"playframework\"]}}},{\"node\":{\"html\":\"<p>本文将是一个系列文章，循序渐进地介绍本站的构建过程，不只是简单的技术介绍，重点是建站过程遇到的问题分析，以及解决的过程，所以起名<strong>“边建边学”</strong>系列。</p>\\n<p>希望对学习<code>Scala</code>+<code>Playframework</code>的童鞋有所启发。</p>\\n<p>本篇重点介绍如何用markdown来写技术文章，以及如何优化代码片段。</p>\\n<h2>需求</h2>\\n<ul>\\n<li>用markdown来写博客，对不同代码类型能够进行美化</li>\\n<li>技术博客一般会在文中包含部分代码片段，在看文章的时候，如果能运行一下这个代码片段，看看执行结果是什么，会对理解技术有所帮助，所以这里需要一个Web REPL (Read Eval Print Loop)</li>\\n<li>博文列表中只显示博文头</li>\\n</ul>\\n<h2>实现</h2>\\n<h3>markdown</h3>\\n<p>用Markdown写文章的流程是这样的：</p>\\n<ol>\\n<li>\\n<p>在本地创建md文件，用markdown语法写文章</p>\\n<p>markdown语法不是本文的介绍重点，需要温习的童鞋请查看<a href=\\\"http://zh.wikipedia.org/zh-cn/Markdown\\\">维基百科</a>，编辑工具可以考虑使用：<a href=\\\"http://mouapp.com\\\">Mou</a>，或者chrome插件stackedit。</p>\\n</li>\\n<li>\\n<p>将文章发布到网站。</p>\\n<p>发布的最终目的是将文章上传到网站，可以是存到数据库中，可以是上传为一个文件，因为文章的特殊性，创作过程需要跟踪记录，而且md文章本身也是一个文件，所以直接将文件上传搞定。</p>\\n<p>具体上传途径是通过git。其实从版本管理的角度，md文件和其他源代码文件没有什么不同。</p>\\n</li>\\n<li>\\n<p>mardkown解析成为HTML</p>\\n<p>这个解析有两种选择，一个是在服务器端解析，另外一个是在浏览器端通过javascript来解析。个人觉得没有太大不同，这里选择一个github上开源的工具来实现：<a href=\\\"https://github.com/sirthias/pegdown\\\">Pegdown</a>。</p>\\n<p>具体代码非常简单：</p>\\n</li>\\n</ol>\\n<!-- language:lang-scala -->\\n<pre><code>val processor = new PegDownProcessor()\\nval markdownContent = \\\"##title2\\\\n*item1\\\"\\nval htmlContent = processor.markdownToHtml(markdownContent)\\n</code></pre>\\n<ol start=\\\"4\\\">\\n<li>\\n<p>代码美化</p>\\n<p>将MD转换为html之后，代码片段只是被转换为：<code>&#x3C;pre>&#x3C;code> .... &#x3C;/code>&#x3C;/pre></code>，但是如何按照相应语言的语法进行高亮显示呢？其实任何Web效果的东西都没有什么神秘的，只是应用CSS而已。</p>\\n<p>这里我们选用的是<a href=\\\"https://code.google.com/p/google-code-prettify/\\\">prettify.js</a>，当然，还可以选择其他方案，比如<a href=\\\"http://highlightjs.org\\\">highlight.js</a>.</p>\\n<p>具体方案如下：</p>\\n</li>\\n</ol>\\n<!-- language:lang-javascript -->\\n<pre><code>&#x3C;script type='text/javascript'>\\n    function init() {\\n        var prettify = false;\\n        var blocks = document.querySelectorAll('pre code')\\n        for (var i = 0; i &#x3C; blocks.length ; i++) {\\n            blocks[i].className += 'prettyprint';\\n            prettify = true;\\n        }\\n        if (prettify) {\\n          prettyPrint();\\n        }\\n    }\\n    window.onload = init;\\n&#x3C;/script>\\n</code></pre>\\n<p>简单说，就是在页面（dom）加载完成之后，查找所有的pre+code元素，然后给该元素class添加<code>prettyprint</code>，这样有了预定义的样式表，代码语法高亮特性就实现了。\\n<br>\\n代码片段执行的部分将有专门的章节介绍，此处略过。\\n</p>\\n<h3>博文列表只显示文章头</h3>\\n<p>在列表页面，将在一个页面列出大量的内容，如果将每篇文章都完整地列出来，那么页面将变得很长，而且也不方便用户查找，而如果能够只显示文章的开头部分，就可以让读者快速地了解文章大致内容，并且快速浏览近期文章，有选择性地查看文章。</p>\\n<p>这个说起来其实很简单，展示部分内容逻辑上也很简单，只是简单截取文章开头的前N个字符而已。总体上是这个思路，可实际上会比这个稍微复杂一些。原因在于博文不是简单的plain text，而是HTML代码，如果只简单截取前面N个字符，极有可能会造成HTML片段不完整导致页面错误。</p>\\n<p>知道问题所在之后，解决办法其实也就简单了。我们可以简单分析一下markdown转换为html之后的代码结构，比如：</p>\\n<!-- language:lang-html -->\\n<pre><code>&#x3C;h1>手工打造博客站点-1: 用Markdown写博文&#x3C;/h1>\\n&#x3C;p>本文将是一个系列文章，循序渐进地介绍本站的构建过程，不只是简单的技术介绍，重点是建站过程遇到的问题分析，以及解决的过程。&#x3C;/p>\\n&#x3C;p>希望对学习&#x3C;code>Scala&#x3C;/code>+&#x3C;code>Playframework&#x3C;/code>的童鞋有所启发。&#x3C;/p>\\n&#x3C;p>本篇重点介绍如何用markdown来写技术文章，以及如何优化代码片段。&#x3C;/p>\\n&#x3C;h2>需求&#x3C;/h2>\\n……\\n</code></pre>\\n<p>很明显，标题、段落等html元素都是同级的，所以我们只需要一次计算每个html元素所包含内容的长度，当叠加到超过阀值时，将前面元素内容输出就好了。具体的办法是：先将html字符串解析为XML DOM，然后迭代每个一级children节点。</p>\\n<!-- language:lang-scala -->\\n<pre><code>val content = Source.fromFile(file, \\\"UTF-8\\\", 1024).mkString\\nval htmlContent = \\\"&#x3C;article>\\\" + processor.markdownToHtml(content) + \\\"&#x3C;/article>\\\"\\n// only show part of the article\\nval xml = scala.xml.XML.loadString(htmlContent)\\nvar i: Long = 0L\\nval elemList = xml.child.takeWhile( el => { i += el.toString().length; i &#x3C; ConfigUtils.BLOG_HEAD_LENGTH } )\\nval part = \\\"&#x3C;article>\\\" + elemList.mkString + s\\\"\\\"\\\"&#x3C;p>&#x3C;a href=\\\"/blogs/${file.getName}\\\">[...]&#x3C;/a>&#x3C;/p>&#x3C;/article>\\\"\\\"\\\"\\n</code></pre>\\n<p>备注：</p>\\n<ul>\\n<li>在转换为html之后，需要在外面包一个<code>&#x3C;article></code>容器元素。</li>\\n<li>从一个Seq容器元素中截取前面部分元素用<code>takeWhile</code>，此处有一个<code>var</code>可变参数的使用，其实也可以不用，只是用在这里容易一些。</li>\\n<li>在最后添加一个指向文章全文的链接。</li>\\n</ul>\\n<h2>预告</h2>\\n<p>下篇，将介绍如何将网页中的代码片段提交到服务器端执行并返回执行结果，也就是Web GUI REPL，敬请关注。</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/用markdown写博客.markdown absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-01T14:06:45.000Z\",\"path\":\"/2013/blogging-with-markdown\",\"title\":\"边建边学-1: 用Markdown写博文\",\"excerpt\":\"本文将是一个系列文章，循序渐进地介绍本站的构建过程，不只是简单的技术介绍，重点是建站过程遇到的问题分析，以及解决的过程，所以起名**“边建边学”**系列。\",\"tags\":[\"markdown\",\"blog\"]}}},{\"node\":{\"html\":\"<h2>引子</h2>\\n<p>从有了博客这个东西开始，就一直开始找各种好用的博客站点，csdn、新浪、搜狐、博客大巴、点点、google site、Github，甚至自己定制内容管理系统（CMS）Liferay，来建立自己的博客站点。免费的、收费的，都尝试了，可总觉得这里或者那里有点不满意。</p>\\n<p>所以就有一个小心愿能实现一个自己喜欢的站点。</p>\\n<p>这个站点应该可以：</p>\\n<ul>\\n<li>用比较“极客”的方式来写，符合我们这种工科IT男的作风。</li>\\n<li>可以很灵活地定制，想加什么功能就加什么功能。</li>\\n<li>最好有个主题，不是一个记流水账的地方。</li>\\n</ul>\\n<p>近来学习scala这门语言，对于我这个多年在OO世界中打拼的程序员在思维方式上的触动很大，有了找一个地方写一些关于scala学习方面的专题文章。</p>\\n<p>两者一结合，就有了这个网站。</p>\\n<h2>站点简介</h2>\\n<p>这个网站是用下列技术构建的：</p>\\n<ul>\\n<li>Scala</li>\\n<li>Playframework</li>\\n<li>Markdown</li>\\n<li>Websockets</li>\\n<li>Redis</li>\\n<li>MongoDB</li>\\n<li>Twitter Bootstrap</li>\\n</ul>\\n<p>运行在Heroku上，除了域名，一切免费。</p>\\n<h2>博客内容预告</h2>\\n<p>这一系列文章将包括，但不限于：</p>\\n<ul>\\n<li>\\n<p>构建本站技术介绍\\n如何一步一步地搭建一个完整的网站。</p>\\n</li>\\n<li>\\n<p>Scala语言特性</p>\\n</li>\\n<li>\\n<p>一些Scala世界的常用工具，比如Akka、Scalaz的介绍等等。</p>\\n</li>\\n</ul>\\n<p>你可以方便地在网站上直接测试一些小的代码，比如：</p>\\n<!-- language:lang-scala run -->\\n<pre><code>val i = 10\\nprintln(i + 2)\\nval j = 10\\nprintln(j - i)\\n</code></pre>\\n<p>点击<code>Run</code>你就能看到执行结果。</p>\\n<h2>TODO LIST</h2>\\n<ul>\\n<li>简单的搜索</li>\\n<li>分页</li>\\n<li>评论功能</li>\\n</ul>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/开篇.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-10-25T17:06:45.000Z\",\"path\":\"/2013/start\",\"title\":\"开篇\",\"excerpt\":\"网络博客\",\"tags\":[]}}}],\"pathPrefix\":\"\",\"first\":false,\"last\":true,\"index\":3,\"pageCount\":3}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/3.json\n// module id = 421\n// module chunks = 182981024786761"],"sourceRoot":""}