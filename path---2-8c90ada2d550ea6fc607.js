webpackJsonp([0x8f0ce58d3892],{382:function(e,n){e.exports={data:{allMarkdownRemark:{totalCount:23,edges:[{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2018/简单比较下http2和http1.1的性能.md absPath of file >>> MarkdownRemark",frontmatter:{title:"简单比较下http/2和http/1.1的性能",date:"March 19, 2018",path:"/2018/simple-performance-comparison-between-http2-and-http1",tags:["http/2","测试"],excerpt:"简单对比http/1.1和http/2的性能"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2018/微服务架构下的开发环境问题.md absPath of file >>> MarkdownRemark",frontmatter:{title:"微服务架构下的开发环境问题",date:"March 16, 2018",path:"/2018/development-environment-for-microservices",tags:["微服务","架构","开发环境","microservices"],excerpt:"本文介绍如何在微服务架构下解决开发环境的搭建、共享的问题。"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2018/为Gatsby博客添加分页功能.md absPath of file >>> MarkdownRemark",frontmatter:{title:"为Gatsby博客添加分页功能",date:"March 12, 2018",path:"/2018/support-pagination-for-gatsby-blog",tags:["blog","gatsby"],excerpt:"根据Egghead上的教程，做出的博客站点有个缺陷，那就是没有分页功能，对于勤奋的博主来说，在一个页面上显示所有文章列表有点不完美，这里我们改造一下，加入分页功能。"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2018/为你的Gatsby博客添加评论功能.md absPath of file >>> MarkdownRemark",frontmatter:{title:"为你的Gatsby博客添加评论功能",date:"March 12, 2018",path:"/2018/enable-comments-for-gatsby-blog",tags:["blog"],excerpt:"Gatsby打造的博客已经很不错了，但是缺少一个评论功能。本文简单介绍如何集成Disqus评论服务到你的博客站点。"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2018/转用Gatsby搭建博客.md absPath of file >>> MarkdownRemark",frontmatter:{title:"转用Gatsby打造基于github的博客站点",date:"March 08, 2018",path:"/2018/blog-with-gatsby",tags:["blog","github","gatsby"],excerpt:"如何用Gatsby打造一个博客"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2018/一则奇怪的Toubleshooting.md absPath of file >>> MarkdownRemark",frontmatter:{title:"记一次奇怪的troubleshooting",date:"March 08, 2018",path:"/2018/skipper-sni-domain-fronting",tags:["skipper","SNI","domain fronting"],excerpt:"在Skipper转发请求到一个https站点的时候，返回莫名404."}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2016/JSON解析利器JQ.md absPath of file >>> MarkdownRemark",frontmatter:{title:"JSON解析利器---JQ",date:"March 25, 2016",path:"/2013/jq",tags:["bash","jq","json"],excerpt:"在API first的时代，json作为最常用的格式，充斥着程序猿的屏幕各个角落，掌握一门解析、过滤、转换json输出的工具，已经成为程序猿们安身立命的必要技能。 这里隆重向大家介绍[jq](https://stedolan.github.io/jq/)."}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2016/Function的协变.md absPath of file >>> MarkdownRemark",frontmatter:{title:"Function的协、逆变",date:"February 04, 2016",path:"/2016/function-covariant-contravariant",tags:["scala","functional programming"],excerpt:"泛型编程的时候，协变(covariant)还是逆变(contravariant)很重要，在设计上层API接口的时候，正确的使用协变、逆变可以更好地约束程序员的行为，让实现变得安全、一致。"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2015/如何在Scala中实现AOP.md absPath of file >>> MarkdownRemark",frontmatter:{title:"用Mixin组合实现Scala中的AOP",date:"August 13, 2015",path:"/2015/aop-by-mixin-in-scala",tags:["scala","functional programming","AOP","mixin"],excerpt:"在Java世界，AOP（Aspect Oriented Programming， 面向方面编程)是很多框架的基础。这种将关注点按照“方面”来切分的编程模型极大地简化了编程的复杂度，尤其是在多维度因子交织在一起的时候的各种场景。对于代码的可读性、可维护性、可重用性都是极大的帮助。"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Scala雾里看花.md absPath of file >>> MarkdownRemark",frontmatter:{title:"Scala雾里看花",date:"April 23, 2015",path:"/2015/scala-trouble-shooting",tags:["scala","trouble shooting"],excerpt:"Scala的学习过程中，经常会碰到一些莫名其妙的现象，很多时候，这些语言层面的“怪象”都与scala编译器或者scala的类型系统有关。本文不是对编译器和类型系统的介绍，而是重点介绍遇到这些现象的时候，用什么样的方式，拨开云雾见蓝天，通过这些工具获取一些细节帮你了解编译器和类型系统如何工作。工欲善其事，必先利其器。"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Docker创建MySQL主从复制以及CDC测试.md absPath of file >>> MarkdownRemark",frontmatter:{title:"MySQL Master/Slave Replication on Docker",date:"April 21, 2015",path:"/2015/mysql-replication-on-docker",tags:["docker","mysql"],excerpt:"How to setup Mysql master/slave replication."}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2014/Scala函数式异常处理.md absPath of file >>> MarkdownRemark",frontmatter:{title:"Scala函数式异常处理",date:"May 04, 2014",path:"/2014/scala-error-handling-in-fp-style",tags:["scala","functional programming","exception handling"],excerpt:"经常看到很多示例代码，简洁的让人爱不释手，可是真正自己实现的时候，不得不添加各种各样的异常处理逻辑，最后发现代码总量的80%都是再做异常处理，而真正的代码逻辑只有很少的一部分。"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2014/高种泛型.md absPath of file >>> MarkdownRemark",frontmatter:{title:"高种泛型 (Generics of a Higher Kind)",date:"January 08, 2014",path:"/2014/generics-of-a-higher-kind",tags:["scala","functional programming","Generics"],excerpt:"Generics of a Higher Kind翻译加自我理解。"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2013/map-flatMap-for.md absPath of file >>> MarkdownRemark",frontmatter:{title:"map/flatMap/for in Action",date:"December 01, 2013",path:"/2013/map-flatmap-for",tags:["scala","functional programming"],excerpt:"前文说过了，高阶函数式函数式语言中的基石，而`map`, `flatMap`更是重要。"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2013/fold编程.md absPath of file >>> MarkdownRemark",frontmatter:{title:"折纸的艺术：fold编程",date:"November 27, 2013",path:"/2013/fold",tags:["scala","functional programming","fold"],excerpt:"Eric Meijer说：递归是函数式编程的GOTO，应该尽可能避免。如何避免，OO中我们用while循环，FP中我们用`fold`。"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Monad.md absPath of file >>> MarkdownRemark",frontmatter:{title:"Monad",date:"November 26, 2013",path:"/2013/monad",tags:["scala","functional programming","monad"],excerpt:"函数式语言与OO（确切地讲是指令式编程）的思维方式是完全不同的，很多OO中的经验在函数式语言中不是很匹配，比如设计模式，那就是一个OO中的特定术语，而在FP中，大家常谈的是对于习惯OO思维的程序员来说玄而又玄的Monad。"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2013/高阶函数.md absPath of file >>> MarkdownRemark",frontmatter:{title:"高阶函数",date:"November 21, 2013",path:"/2013/high-order-function",tags:["scala","functional programming","high order function"],excerpt:"所谓高阶函数（high order function），其实就是可以接受其他函数作为参数的函数。"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Actor协调并发场景下的集合操作.md absPath of file >>> MarkdownRemark",frontmatter:{title:"边建边学-3：Actor协调并发场景下的集合操作",date:"November 17, 2013",path:"/2013/actor-collection-collabration",tags:["scala","functional programming"],excerpt:"很多时候为了提高性能，减少IO操作，都会将数据load出来之后缓存在内存中。本站的实现过程中也遇到类似的问题，不希望每次有人访问的时候就读取一次md文件，或者从MongoDB中查一次，而是直接在内存中读取。"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Enumerator-Iteratee-Enumeratee.md absPath of file >>> MarkdownRemark",frontmatter:{title:"Enumerator / Iteratee / Enumeratee",date:"November 11, 2013",path:"/2013/enumerator-iteratee-enumeratee",tags:["scala","playframework","blog"],excerpt:"Stream对于指令式编程已经比较成熟了，有大量的类库，丰富的API。但是对于强调不可变量，尽可能无副作用的FP来说，要考虑语言适配的问题，而目前，流行的解决方案就是：Enumerator/Iteratee。"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2013/集成PlantUML和Markdown.md absPath of file >>> MarkdownRemark",frontmatter:{title:"边建边学-2：集成PlantUML和Markdown",date:"November 07, 2013",path:"/2013/markdown-plantuml-integration",tags:["markdown","plantuml","blog"],excerpt:"如何用Markdown+PlantUML结合来写图文并茂的博客。"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2013/EssentialAction-in-Playframework.md absPath of file >>> MarkdownRemark",frontmatter:{title:"EssentialAction in Playframework",date:"November 05, 2013",path:"/2013/essential-action-in-play",tags:["scala","playframework"],excerpt:"Playframework中EssentialAction理解"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2013/用markdown写博客.markdown absPath of file >>> MarkdownRemark",frontmatter:{title:"边建边学-1: 用Markdown写博文",date:"November 01, 2013",path:"/2013/blogging-with-markdown",tags:["markdown","blog"],excerpt:"本文将是一个系列文章，循序渐进地介绍本站的构建过程，不只是简单的技术介绍，重点是建站过程遇到的问题分析，以及解决的过程，所以起名**“边建边学”**系列。"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2013/开篇.md absPath of file >>> MarkdownRemark",frontmatter:{title:"开篇",date:"October 25, 2013",path:"/2013/start",tags:[],excerpt:"网络博客"}}}]}},pathContext:{group:[{node:{html:'<h2>Pull Mysql Docker Image</h2>\n<!-- language: bash -->\n<pre><code>docker pull mysql:5.6\n</code></pre>\n<h2>Create MySQL Config Files</h2>\n<p>For Master, create a <code>mysql.cnf</code> file and add the following content:</p>\n<!-- language: bash -->\n<pre><code>[mysqld]\n\nserver-id = 1\nlog_bin\nbinlog_format = ROW\nbind-address = 0.0.0.0\n\nsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES\n</code></pre>\n<p>For Slave, create another <code>mysql.cnf</code> and add the following content:</p>\n<!-- language: bash -->\n<pre><code>[mysqld]\n\nserver-id = 2\nlog_bin\nbinlog_format = ROW\nbind-address = 0.0.0.0\n\nsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES\n</code></pre>\n<h2>Start Master/Slave MySQL Containers</h2>\n<p>Start Master:</p>\n<!-- language: bash -->\n<pre><code>docker run --name master -v /my/master:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:5.6\n</code></pre>\n<p>Start Slave:</p>\n<!-- language: bash -->\n<pre><code>docker run --name slave -v /my/slave:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw --link master:master -d mysql:5.6\n</code></pre>\n<p>The slave node needs to link to master node.</p>\n<h2>Setup Replication</h2>\n<p>Check the master status:</p>\n<!-- language: bash -->\n<pre><code>mysql> show master status \\G\n*************************** 1. row ***************************\n             File: mysql-bin.000003\n         Position: 120\n     Binlog_Do_DB: \n Binlog_Ignore_DB: \nExecuted_Gtid_Set: \n1 row in set (0.00 sec)\n</code></pre>\n<p>the above information is necessary for the slave configuration, especially the <code>File</code> and <code>Position</code>.</p>\n<p>Connect to Slave node, in Mysql Shell:</p>\n<!-- language: bash -->\n<pre><code>mysql> change master to master_host=\'master\',master_user=\'root\',master_password=\'my-secret-pw\',master_log_file=\'mysql-bin.000003\',master_log_pos=120;  \nQuery OK, 0 rows affected (0.00 sec)  \n\nmysql> start slave;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql> show slave status\\G\n\n// until you see the following two options are \'Yes\'\nSlave_IO_Running: Yes  \nSlave_SQL_Running: Yes  \n</code></pre>\n<p>You need to change the parameters like <code>master_log_file</code> and <code>master_log_pos</code> based on previous <code>show master status</code> output.</p>\n<h2>Test</h2>\n<p>Create some tables and insert some data on master, and check if those data are synced to slave. </p>\n<h2>Change Data Capture (CDC)</h2>\n<p>Here I used an open source library <a href="https://github.com/whitesock/open-replicator">open-replicator</a></p>\n<!-- language: scala -->\n<pre><code>import com.google.code.or._\nimport com.google.code.or.binlog._\nimport com.google.code.or.binlog.impl.event.FormatDescriptionEvent\n\nval or = new OpenReplicator()\nor.setUser("root")\nor.setPassword("my-secret-pw")\nor.setServerId(2);\nor.setHost("slave")\nor.setPort(3306)\nor.setBinlogPosition(120)\nor.setBinlogFileName("mysql-bin.000004")\n\nor.setBinlogEventListener(new BinlogEventListener() {\n  def onEvents(event: BinlogEventV4) = {\n\n  }\n})\n\nor.start()\n</code></pre>\n<p>TBD.\nSee <code>com.linkedin.databus2.producers.ORListener</code></p>\n<h2>References</h2>\n<ol>\n<li><a href="https://registry.hub.docker.com/_/mysql/">Mysql Docker Official Repo</a></li>\n<li><a href="https://github.com/linkedin/databus/wiki/Databus-for-MySQL">Databus for MySQL</a></li>\n</ol>',id:"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Docker创建MySQL主从复制以及CDC测试.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2015-04-21T07:16:45.000Z",path:"/2015/mysql-replication-on-docker",title:"MySQL Master/Slave Replication on Docker",excerpt:"How to setup Mysql master/slave replication.",tags:["docker","mysql"]}}},{node:{html:'<p>经常看到很多示例代码，简洁的让人爱不释手，可是真正自己实现的时候，不得不添加各种各样的异常处理逻辑，最后发现代码总量的80%都是再做异常处理，而真正的代码逻辑只有很少的一部分。</p>\n<p>异常处理对于指令式和函数式编程都是同样需要的，只是因为实现方式的不同，让函数式编程看上去更加简洁，优雅，不需要像指令式那么繁琐。</p>\n<p>本文的目的，就是介绍函数式编程中常用的一些异常处理策略。记得把这些瑞士军刀放到你的百宝箱中，以后一定用得上。</p>\n<h2>空判断Option</h2>\n<p>如果采访100个程序员，让所有人投票他们在编程时最讨厌做的事情，但又经常犯错误的地方，我估计十有八九会是“空判断”了。</p>\n<p><code>Null</code>代表着一个对象还没有被初始化，具体点是对象的指针还没有一个确切的地址。在面向对象编程时，因为操作的都是对象，为了避免在一个<code>null</code>上面调用方法，或者 get一个<code>null</code>上的属性，而导致“空值异常”，程序员不得不做下面的事情：</p>\n<p>假设有下面一个场景：</p>\n<!-- language:uml -->\n<pre><code>Selling --> Store\nSelling --> Product\n</code></pre>\n<p>简单说，一个商场内有很多商店(Store)，每个商店卖(Selling)很多种商品(Product)，如果希望找出所有销售玩具的商店：</p>\n<!-- language:java -->\n<pre><code>public List&#x3C;Store> findByProductCategory(Category category) {\n  if (category == null)               &#x3C;1>\n    return null;\n  List&#x3C;Product> allProducts = getAllProducts(); // DB lookup\n  for (Product prod : allProducts) {\n    if (prod.category == null)        &#x3C;2>\n      continue; \n    if (category.equals(prod.category)){\n    \n</code></pre>\n<h2>参考</h2>\n<ol>\n<li><a href="https://tersesystems.com/2012/12/27/error-handling-in-scala/">Error Handling in Scala. https://tersesystems.com/2012/12/27/error-handling-in-scala. 2012</a></li>\n</ol>',id:"/Users/lliu/github/smilingleo.github.io/src/pages/2014/Scala函数式异常处理.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2014-05-04T07:16:45.000Z",path:"/2014/scala-error-handling-in-fp-style",title:"Scala函数式异常处理",excerpt:"经常看到很多示例代码，简洁的让人爱不释手，可是真正自己实现的时候，不得不添加各种各样的异常处理逻辑，最后发现代码总量的80%都是再做异常处理，而真正的代码逻辑只有很少的一部分。",tags:["scala","functional programming","exception handling"]}}},{node:{html:'<p>译者按语：很多翻译中将Kind和Type都翻译为“类型”，但实际上两者还是有不同的，本文中，将<code>Kind</code>翻译为“种类”，取王侯将相宁有种乎之意，是骨子里的东西。而将<code>type</code>译为“类型”。</p>\n<p>学习函数式语言如果想真正入门，一个不可避免的话题就是monad/monoid，而这些范畴论中的词汇都异常抽象，难于理解，尤其是对于从java领域转过来的同学，在很多FP的基础东西不了解情况下来研究monad就更加的困难，比如高种泛型。</p>\n<p><code>泛型</code> 我们都知道，就是某种类型的泛化（一般化），就是将某些特殊类型进行抽象，抽出一种一般化的类型<code>T</code>。而<code>高种泛型</code>就是在泛型的基础上再进行一次抽象。</p>\n<ul>\n<li>\n<p>First Order Abstraction</p>\n<p>first-order可以理解为”单次抽象“，将特定类型抽象一次，比如类型：<code>T</code>, <code>T</code>是什么？可以是任何具体类型，String，Integer，Date等等，不难发现，这就是Java中的泛型。</p>\n</li>\n<li>\n<p>Higher Order Abstraction</p>\n<p>对应first-order的单次抽象，高阶抽象就是再次抽象，也就是说：在某个东东的抽象上再进行抽象，抽象的抽象。晕了吧！</p>\n</li>\n</ul>\n<p>在继续之前，我们还得熟悉几个概念：</p>\n<ul>\n<li>\n<p>值构造器</p>\n<p>值构造器是一个function / method，接受特定值参数来构造一个特定的值(value)</p>\n<p>值构造器可以有多态：接受不同类型的参数，也可以是抽象abstract的。</p>\n</li>\n<li>\n<p>类型构造器</p>\n<p>类型构造器是一个类型，接受一个特定类型参数来构造一个特定的类型。</p>\n<p>和值构造器一样，类型构造器也可以有多态，这是高阶类型的关键。</p>\n</li>\n</ul>\n<p>先说这么多概念有什么用呢？我们还是先看一个具体的例子。</p>\n<h2>例子：Iterable</h2>\n<p>观察下面代码，我们来玩个找不同的游戏：</p>\n<!-- language:scala -->\n<pre><code>trait Iterable[T] {\n  def filter(p: T => Boolean): Iterable[T]\n  def remove(p: T => Boolean): Iterable[T] = filter(x => !p(x))\n}\n\ntrait List[T] extends Iterable[T] {\n  def filter(p: T => Boolean): List[T]\n  override def remove(p: T => Boolean): List[T] = filter(x => !p(x))\n}\n</code></pre>\n<p>看到两段代码有什么不同了吗？什么代码重复了？</p>\n<p>很容易发现：在<code>List[T]</code>中的两个方法主体结构和<code>Iterable[T]</code>中的几乎完全相同，只是返回类型不同，都期望返回自身类型。如果我们能够将返回类型也复用，那是否就可以完全去除这些重复代码呢？</p>\n<h3>通过类型构造器多态来去除重复代码</h3>\n<p>看下面代码：</p>\n<!-- language:scala -->\n<pre><code>trait Iterable[T, Container[X]] {\n  def filter(p: T => Boolean): Container[T]\n  def remove(p: T => Boolean): Container[T] = filter(x => !p(x))\n}\n\ntrait List[T] extends Iterable[T, List]\n</code></pre>\n<p>这是怎么做到的？很简单，引入了<strong>类型构造器多态</strong>的概念。上面例子中：<code>Iterable[T, Container[X]]</code>的<code>Iterable</code>是类型构造器，接受两个类型参数，引入多态概念，同样的类型构造器，让其可以接受不同类型的类型参数<code>List</code>。是不是和普通方法多态没什么区别？</p>\n<!-- language:java -->\n<pre><code>public Iterable iterable(T t, Container&#x3C;X> container) { ... }\npublic Iterable iterable(T t, List list) { ... }\n</code></pre>\n<p>因为Java的泛型没有类型构造器多态的概念，所以Java泛型无法解决上述重复代码的问题。最多只能将返回类型设为超类Iterable，然后在调用子类实现时将其强制类型转换为具体子类。</p>\n<p>有了上面的例子为上下文，我们再来看两个概念：</p>\n<h3>类型参数、类型成员</h3>\n<ul>\n<li>\n<p>Type Parameter</p>\n<p>类型参数，比如: <code>List[T]</code>，List具有一个类型参数<code>T</code>。这里的List就是一个类型构造器。List[Int]就是这个类型构造器接受类型参数Int之后构造的具体类型。</p>\n</li>\n<li>\n<p>Type Member</p>\n<p>类型成员，比如：<code>trait List { type T }</code></p>\n<p>这里<code>T</code>变成了一个trait的成员（抽象的）。在List子类实现中，指定其具体类型，比如：<code>List { type T = Int }</code>。而这里的类型成员也可能参数化，比如：<code>type Container[T]</code></p>\n<p>注意：这里的List只用来示意，并不是scala中的List实现。</p>\n</li>\n<li>\n<p>Type Parameter Vs. Type Member</p>\n<p>两者很像，只是作用范围和可见性不同:</p>\n<ul>\n<li>参数类型只是被参数化的类型的一部分（local，private）。</li>\n<li>类型变量就和不同变量一样，被封装在整个body中，可以被继承，显式地引用。</li>\n<li>两者可以相互补充。比如类型成员也可以被参数化。</li>\n</ul>\n</li>\n</ul>\n<h2>改进Iteratable</h2>\n<p>对于集合（collection）来说，很多方法，比如：map, flatMap, filter，各有作用，但是其实这些方法都有以下两个共同点：</p>\n<ol>\n<li>遍历一个集合</li>\n<li>产生一个新的集合</li>\n</ol>\n<p>仔细想想，是不是所有的这些操作都满足呢？</p>\n<ul>\n<li>map遍历一个collection，将其中的元素变形为另外类型并产生一个新的集合。</li>\n<li>flatMap遍历一个集合，将集合中元素转换为一个集合，并最后将“集合的集合”拉平，形成一个新的集合。</li>\n<li>filter遍历一个集合，判断是否符合过滤条件，并返回所有符合过滤条件的新的集合。</li>\n</ul>\n<p>找到共同点，我们就可以将其抽象出来，进而达到复用、减少重复代码的目的。对上面两个共同点，我们可以用Iterator和Builder来进行抽象实现。</p>\n<!-- language:scala -->\n<pre><code>// 产生新集合\ntrait Builder[Container[X], T] {\n  def +=(ele: T): Unit\n  def finalise(): Container[X]\n}\n// 遍历（迭代）器\ntrait Iterator[T] {\n  def next(): T\n  def hasNext(): Boolean\n  def foreach(op: T => Unit): Unit = {\n    while(hasNext()) { op(next()) }\n  }\n}\n</code></pre>\n<p>有了这两点抽象，那我们就可以对Iteratable进行改进：</p>\n<!-- language:scala -->\n<pre><code>// 类型参数Container\ntrait Buildable[Container[X]] {\n  // build方法只是返回一个Builder\n  def build[T]: Builder[Container[X], T]\n}\n\n// Iteratable没有类型参数Container\ntrait Iteratable[T] {\n  // 类型成员Container\n  type Container[X] &#x3C;: Iteratable[X]\n  def elements: Iterator[T]\n  \n  def mapTo[U, C[X]](f: T => U)(b: Buildable[C]): C[U] = {\n    val buff = b.build[U]\n    val elems = elements\n    while(elems.hasNext) {\n      buff += f(elems.next)\n    }\n    buff.finalise\n  }\n  \n  def filterTo[C[X]](f: T => Boolean)(b: Buildable[C]): C[T] = {\n    val buff = build[T]\n    val elems = elements\n    while(elems.hasNext) {\n      val elem = elems.next\n      if (f(elem)) buff += elem\n    }\n    buff.finalise\n  }\n  \n  def flatMapTo[U, C[X]](f: T => Iterable[U])(b: Buildable[C]): C[U] = {\n    val buff = build[U]\n    val elems = elements\n    while(elems.hasNext) {\n      f(elems.next).elements.foreach(buff += _)\n    }\n    buff.finalise\n  }\n  \n  def map[U](f: T => U)(b: Buildable[Container]): Container[U] = mapTo[U, Container](f)(b)\n  \n  def filterTo(f: T => Boolean)(b: Buildable[Container]) : Container[T] =\n    filterTo[Container](f)(b)\n  \n  def flatMap[U](f: T => Iteratable[U])(b: Buildable[Container]): Container[U] = \n    flatMapTo[U, Container](f, b)\n    \n}\n</code></pre>\n<p>上面的代码中，我们用<code>Buildable</code>和<code>Iterator</code>将前文提到的两个共同点进行抽象，并在<code>Iteratable</code>的实现中，利用这两个抽象：Curried的参数<code>b: Buildable[C]</code>以及<code>def elements: Iterator[T]</code>抽象方法，分别实现了：<code>map</code>, <code>filter</code>, <code>flatMap</code>。</p>\n<p>而Iteratable的具体实现，只需要具化上面两个抽象就可以了。比如List的实现：</p>\n<!-- language:scala -->\n<pre><code>object ListBuildable extends Buildable[List] {\n  def build[T]: Builder[List, T] = new ListBuffer[T] with Builder[List, T]() {\n    // `+=` 是scala标准库中ListBuffer的方法\n    def finalise(): List[T] = toList\n  }\n}\n\nclass List[T] extends Iteratable[T] {\n  type Container[X] = List[X]\n  def elements: Iterator[T] = new Iterator {\n    ......\n  }\n}\n</code></pre>\n<p>有了上面的实现，我们就可以利用scala的另外一个机制：implicit来实现根据类型来自动选择匹配的<code>Buildable</code>了。</p>\n<h3>Scala标准库实现</h3>\n<p>掌握上面的思想，我们回头再看scala标准库中collection的实现机制，就很容易理解了。scala的collection架构正是基于<code>builders</code>和<code>traversals</code>思想实现的。</p>\n<!-- language:scala -->\n<pre><code>package scala.collection.mutable\nclass Builder[-Elem, +To] {\n  def +=(elem: Elem): this.type\n  def result(): To\n  def clear(): Unit\n  def mapResult[NewTo](f: To => NewTo): Builder[Elem, NewTo] = ...\n}\n</code></pre>\n<p>可以看出上面的<code>result</code>方法就是：我们例子中的<code>finalise</code>，此外多了<code>clear</code>, <code>mapResult</code>两个方法。</p>\n<p>再看看<code>Buildable</code>的实现：</p>\n<!-- language:scala -->\n<pre><code>package scala.collection.generic\ntrait CanBuildFrom[-From, -Elem, +To] {\n  // Creates a new builder \n  def apply(from: From): Builder[Elem, To] \n}\n</code></pre>\n<p>在scala中，换了个名字：<code>CanBuildFrom</code>，感觉会更贴切一些（不过从dual的角度就感觉不那么好了）。</p>\n<p>上面的<code>apply</code>就是<code>build</code>只是多了一个参数。</p>\n<p>再来看<code>Iteratable</code>:</p>\n<!-- language:scala -->\n<pre><code>package scala.collection\nclass TraversableLike[+Elem, +Repr] {\n  def newBuilder: Builder[Elem, Repr] // deferred\n  def foreach[U](f: Elem => U)        // deferred\n          ...\n  def filter(p: Elem => Boolean): Repr = {\n    val b = newBuilder\n    foreach { elem => if (p(elem)) b += elem }\n    b.result\n  } \n}\n</code></pre>\n<h3>类型参数 vs. 类型成员</h3>\n<p>在上面的例子中，我们同时使用了类型参数和类型成员。</p>\n<ul>\n<li>Buildable的主要目的是构建某种类型的Container，因此使用类型参数将其显式地暴露给客户端。</li>\n<li>对于Iterable，用户更关心的是其中包含的元素类型，而不是容器(Iterable本身就类似个容器了)，所以我们采用类型成员。</li>\n</ul>\n<h2>关于类型(Type)和种类(Kind)</h2>\n<p>其实中文“类型”在这里很混淆，将英文中的两个词type、kind都翻译为“类型”了，其实是有差别的，我们这里将type翻译为"类型"，kind翻译为"种类"。</p>\n<p>值、特定类型和种类的关系可以从下图中得到解答。</p>\n<p><img src="http://i.stack.imgur.com/K0dwL.jpg" alt="values, types and kinds的关系图"></p>\n<ul>\n<li>特定类型是对某种特定类型的值进行分类，比如Int是对1，2，3，4等值的分类，1，2，3是值，Int是Type(类型)。</li>\n<li>种类是对特定类型的归类，比如对Int, String, List[Int]等类型，我们进行高阶抽象，可以认为这些特定类型都是相同种类的，可以用<code>*</code>来描述。这里<code>*</code>不是用来描述任意值的，而是<em>任意一个特定类型</em>。</li>\n<li>种类<code>K</code>可以是<code>*</code> (看下面定义)，也可以是<code>K → K</code>，其中<code>→</code>是<em>种类构造器</em>，用来构造一个<strong>用于归纳类型构造器的种类</strong>，绕口吧，简单地说就是<code>K → K</code>接受一个种类参数，返回一个新的种类.</li>\n</ul>\n<h3>Kind的定义</h3>\n<pre><code>Kind ::= \'*(\' Type \',\' Type \')\' | [id \'@\' ] Kind \'→\' Kind\n</code></pre>\n<p><code>*(T, U)</code>种类中<code>T</code>用来描述类型下边界(lower bound)，<code>U</code>为类型上边界(upper bound)。在Scala中，最低边界是<code>Nothing</code>因为它使一切类型的子类，最高边界是<code>Any</code>，它使所有类型的超类。因为我们经常使用upper bound, 所以，我们用<code>*(Nothing, U)</code>，简化为<code>*(U)</code>来描述一个种类，特别地，<code>*(Nothing, Any)</code>可以简化为<code>*</code>。</p>\n<p>上文的几个例子：</p>\n<table>\n<thead>\n<tr>\n<th align="center">Scala 类型定义</th>\n<th align="center">Kind 定义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="center">Container\n[\nX\n]</td>\n<td align="center">*\n → \n*</td>\n</tr>\n<tr>\n<td align="center">Pair\n[\nT, U\n]</td>\n<td align="center">*\n → \n*\n → \n*</td>\n</tr>\n<tr>\n<td align="center">Container\n[\nX\n]\n &#x3C;: Iterable\n[\nX\n]</td>\n<td align="center">X @ \n*\n → \n*\n(Iterable\n[\nX\n]\n)</td>\n</tr>\n<tr>\n<td align="center">C[X &#x3C;: Ordered\n[\nX\n]\n] &#x3C;: Iterable\n[\nX\n]</td>\n<td align="center">X @ \n*\n(Ordered\n[\nX\n]\n) → \n*\n(Iterable\n[\nX\n]\n)</td>\n</tr>\n</tbody>\n</table>\n<p>有了Kind定义，我们就可以通过其进行Kind推导，比如<code>T</code>的种类是<code>X @ K → K\'</code>，如果<code>U</code>的Kind是<code>K</code>，那么很简单的通过替换，我们就可以知道<code>T[U]</code>的Kind是<code>K\'</code>。</p>\n<h3>子种类Subkinding</h3>\n<p>scala中，我们通过<code>&#x3C;:</code>或者<code>>:</code>来表述两个类型（type）之间的关系。比如：<code>Int &#x3C;: Number</code>。</p>\n<p>对于种类，我们可以重载<code>&#x3C;:</code> and <code>>:</code>，用来描述两个种类之间的关系。比如：<code>*(T, U) &#x3C;: *(T\', U\')</code>，当且仅当：<code>T\' &#x3C;: T</code> AND <code>U &#x3C;: U\'</code>时上述关系成立。这个相对容易理解，因为<code>T</code>/<code>T\'</code>是类型参数，和方法参数一样，是逆变(contravariance)的。</p>\n<p>scala编译器正是通过应用这些规则来进行type/kind检查的。比如，scala编译器将对下面代码报错：</p>\n<!-- language:scala run -->\n<pre><code>class Iterable[Container[X], T]\ntrait NumericList[T &#x3C;: Number] extends Iterable[NumericList, T]\n</code></pre>\n<p>你可以点击<code>run</code>按钮试试，看看编译会出现什么结果。</p>\n<p>之所以报错，是因为<code>Iterable[NumericList, T]</code>的问题。我们可以应用上面学到的subkinding来分析一下。</p>\n<p><code>NumericList[T &#x3C;: Number]</code>的种类是：<code>*(Number) → *</code>，很显然，它必须是<code>Iterable</code>的第一个类型参数<code>NumericList</code>的子种类， 也就是：<code>*(Number) → * &#x3C;: * → *</code>。在<code>→</code>左边的是种类参数，是逆变的(contravariant)，所以这里我们需要：<code>* &#x3C;: *(Number)</code>，但是这显然是不成立的。所以scala编译器会报错：<code>type T\'s bounds &#x3C;: Number are stricter than type X\'s declared bounds >: Nothing &#x3C;: Any</code>。</p>\n<p>OK then, how to make it work ? 我们需要引入一个新的类型参数：Bound</p>\n<!-- language:scala run -->\n<pre><code>class Iterable[Container[X &#x3C;: Bound], T &#x3C;: Bound, Bound]\ntrait NumericList[T &#x3C;: Number] extends Iterable[NumericList, T, Number]\n</code></pre>\n<p><code>Iterable[Container[X &#x3C;: Bound], T &#x3C;: Bound, Bound]</code>的种类是：<code>*(Bound) → * → *(Bound) → * → *</code></p>\n<p><code>NumericList[T &#x3C;: Number]</code>的种类是：<code>*(Number) → *</code>，该种类必须是<code>Iterable</code>第一个参数的子种类，也就是：<code>*(Number) → * &#x3C;: *(Bound) → *</code>，而<code>Bound</code>已经指定为<code>Number</code>，经过替换，就有了：<code>*(Number) → * &#x3C;: *(Number) → *</code>，左右两边相同，自然是满足要求了。</p>\n<h3>高种类型</h3>\n<p>如果你使用scala 2.11.x版本，在REPL中，就可以通过<code>:type</code>来查看一个类型的种类（Kind）了。比如：</p>\n<!-- language:scala run -->\n<pre><code>scala> :kind -v List\nscala.collection.immutable.List\'s kind is F[+A]\n* -(+)-> *\nThis is a type constructor: a 1st-order-kinded type.\n\nscala> :kind -v Pair[_, _]\nscala.Tuple2\'s kind is F[+A1,+A2]\n* -(+)-> * -(+)-> *\nThis is a type constructor: a 1st-order-kinded type.\n</code></pre>\n<p>可以看到，两者的类型一个是：<code>* → *</code> 另外一个是 <code>* → * → *</code>，而且，两个都是：<code>1st-order-kinded type</code>。那怎么才算是一个<code>higher order kinded type</code>呢？</p>\n<p>在上面的图中:<code>Functor[List]</code>是<code>higher order kinded type</code>: <code>(* → *) → *</code>，这个和<code>Pair[_, _]</code>的<code>* → * → *</code>相比，不就多了个括号吗？玄机就再这个括号上：<code>(* → *) → *</code>表示你接受一个一阶类型* → *，然后产生一个最终的类型。类型的类型，所以是高阶类型。</p>\n<h2>Implicit机制</h2>\n<p><code>implicit</code>是scala中一个很强大的东西，其主要出发点是“偷懒”，没错，就是偷懒，让程序员可以偷懒，将本来应该码农干的活交给“编译器”完成。</p>\n<p>implicit能帮我们码农的有两个地方：隐式参数和隐式转换。</p>\n<h3>隐式参数</h3>\n<p>具体来说，就是你可以将一个方法调用的参数（显式注为implicit）省略掉，编译器会在当前上下文中找能用于补充缺失掉参数的值，如果能找到，就自动填充，找不到就会在编译时报错。比如下面例子：</p>\n<!-- language:scala run -->\n<pre><code>def foo[T](t: T)(implicit integral: Integral[T]) = { println(integral) }\nfoo(1)\n</code></pre>\n<p>注意<code>foo(1)</code>中只提供了第一个参数，一个<code>Int</code>值，但是第二个参数被省略了，scala编译器就会查找当前scope中有没有类型为<code>Integral[Int]</code>的<code>implicit</code>值。很幸运，scala.math.Numeric中定义了<code>implicit object IntIsIntegral extends IntIsIntegral with Ordering.IntOrdering</code>，所以编译器会找到<code>IntIsIntegral</code>对象然后自动补充第二个参数。</p>\n<p>那我们再试一下<code>foo(1.0)</code>，这个时候，编译器会报错。为什么呢？查查scala.math.Numeric源码，我们就会发现：scala为Double提供了implicit Fractional对象，make sense，double不是整数嘛。同时scala还是提供了一个对象<code>DoubleAsIfIntegral</code>，但并没有标记为<code>implicit</code>，所以编译器找不到。了解了原因，简单做如下改动：</p>\n<!-- language:scala run -->\n<pre><code>def foo[T](t: T)(implicit integral: Integral[T]) = { println(integral) }\nfoo(1)\nimplicit val doubleAsIfIntegral = scala.math.Numeric.DoubleAsIfIntegral\nfoo(1.0)\n</code></pre>\n<p>现在大家都happy了。</p>\n<p>你可以通过<code>implicitly[Integral[Double]]</code>来自行查找是否有符合条件的隐式参数。</p>\n<h3>隐式转换</h3>\n<p>implicit的另外一个作用是隐式转换，同样也是帮助码农的。具体讲，就是当你在调用某个方法在某个对象上的时候，如果这个对象的类A并没有定义这个方法，scala的编译器先不会报错，会尝试着在当前scope中查找：</p>\n<ol>\n<li>具有该方法定义的类型 B</li>\n<li>能够将A转换为B的转换器</li>\n</ol>\n<p>如果能找到，那么scala将自动进行上述转换，找不到，报错。例如：</p>\n<!-- language:scala -->\n<pre><code>"123".map(_.toInt)\n</code></pre>\n<p><code>"123"</code>是一个<code>java.lang.String</code>类型，String上并没有定义<code>map</code>方法，但是编译器也没有报错，而且顺利执行了。这就是隐式转换：scala编译器会在上下文中找到<code>implicit def augmentString(x: String): StringOps = new StringOps(x)</code>，可以将<code>String</code>转换为有<code>map</code>定义的<code>StringOps</code>。</p>\n<p>你可以通过<code>implicitly[String => StringOps]</code>进行自行查找符合条件的转换器。</p>\n<p>基于隐式参数和隐式转换，在Scala的类型系统中，有两个语法糖：view bound (CC &#x3C;% Seq[T]) 和 context bound (T : Integral)。</p>\n<h3>View Bounds</h3>\n<p>说实话不知道这个翻译为什么好，在微博上和几位国内scala大牛们探讨过，一些人认为应该直译为：“视界”，我自己倒是觉得应该叫“化界”？因为：</p>\n<ol>\n<li>“视界”，可见到的边界，太笼统，含义模糊，“化界”顾名思义，可“转化到的边界”</li>\n<li>化界听上去比较炫，像是玄幻小说中很高深的境界，^_^</li>\n</ol>\n<p>You can think of <code>T &#x3C;% Ordered[T]</code> as saying, “I can use any T, so long as T can be treated as an Ordered[T].” This is different from saying that T is an Ordered[T], which is what an upper bound, <code>T &#x3C;: Ordered[T]</code>, would say.</p>\n<p>有时候隐式参数和隐式转换可以同时存在、起作用，比如下面代码：</p>\n<!-- language:scala run -->\n<pre><code>def getIndex[T, CC](seq: CC, value: T)(implicit converter: CC => Seq[T]) = seq.indexOf(value)\n\ngetIndex("abcde", \'c\')\ngetIndex(List(1,3,2,5), 3)\n</code></pre>\n<p>上面代码中<code>CC</code>可以是任何能转换为<code>Seq</code>的类型，所以<code>String</code>和<code>List</code>都可以应用。</p>\n<p>首先，<code>converter</code>是一个隐式参数，其次，因为<code>seq</code>对象的类型是<code>CC</code>，其上面并没有定义<code>indexOf</code>方法，所以“隐式转换”介入。</p>\n<p>事实上，这个用法非常普遍，所以scala专门为其提供了一个语法糖：view bound <code>CC &#x3C;% Seq[T]</code>，重写上面代码：</p>\n<!-- language:scala run -->\n<pre><code>def getIndex[T, CC &#x3C;% Seq[T]](seq: CC, value: T) = seq.indexOf(value)\n</code></pre>\n<p>运行上面代码，你可以从输出看到scala编译器会将方法重新定义为：<code>getIndex: [T, CC](list: CC, value: T)(implicit evidence$1: CC => Seq[T])Int</code>，和第一种方法一样。</p>\n<h3>Context Bounds</h3>\n<p>再看下面一个例子：</p>\n<!-- language:scala run -->\n<pre><code>def sum[T](list: List[T])(implicit integral: Integral[T]): T = {\n    import integral._   // get the implicits in question into scope\n    list.foldLeft(integral.zero)(_ + _)\n}\n</code></pre>\n<p>这里有一个隐式参数<code>integral</code>类型为<code>Integral[T]</code>，如果方法传入<code>Int</code>，那么scala编译器就会找<code>implicitly[Integral[Int]]</code>，这个我们在隐式参数小节已经说过了。</p>\n<p>这里主要关注另外一个问题：<code>list.foldLeft(integral.zero)(_ + _)</code>，其中<code>_</code>的类型应该是<code>T</code>，但是<code>T</code>上面有定义<code>+</code>方法吗？我们先把<code>import integral._</code>去掉，就会发现编译出错：</p>\n<!-- language:scala -->\n<pre><code>&#x3C;console>:8: error: type mismatch;\n found   : T\n required: String\n           list.foldLeft(integral.zero)(_ + _)\n                                        ^\n</code></pre>\n<p>原来scala编译器尝试着将<code>T</code>转换为<code>String</code>了，这里应该是<code>Predef.any2string</code>起了作用。</p>\n<p>加上<code>import integral._</code>，一切工作了。</p>\n<p>回头想一下，其实挺有意思的：我们给一个泛型<code>T</code>动态地添加了<code>+</code>方法，但是并不改变<code>T</code>的代码。而这就是context bound的意义。</p>\n<p>这个在流行框架<code>Scalaz</code>中应用非常广泛。scala同样为其创建了专门的语法糖：<code>[T : Ordering]</code>。采用语法糖，这个例子可以重写为：</p>\n<!-- language:scala run -->\n<pre><code>def sum[T : Integral](list: List[T]): T = {\n  val integral = implicitly[Integral[T]]\n  import integral._\n  list.foldLeft(integral.zero)(_ + _)\n}\n</code></pre>\n<p>编译器编译之后，会生成一个<code>sum: [T](list: List[T])(implicit evidence$1: Integral[T])T</code>的方法。</p>\n<p>这里有点让人confusing的地方是：<code>T: Integral</code>的写法感觉像是说：<code>T</code>是<code>Integral</code>的类型，就像：<code>m: T</code>，可实际上应该认为是：<code>T</code>在<code>Integral</code>的<code>Context</code>中。</p>\n<h2>结束语</h2>\n<p>scala的类型系统确实是一个难点，但同时也是要真正掌握scala语言所必须的知识点。很多概念都很晦涩，对于像我们这些凡人，要想掌握没有太好的办法，只能多看、多练、多想。</p>\n<h2>参考</h2>\n<ol>\n<li><a href="http://stackoverflow.com/questions/6246719/what-is-a-higher-kinded-type-in-scala">Adriaan Moors. What is a higher kinded type in scala. StackOverflow. http://stackoverflow.com/questions/6246719/what-is-a-higher-kinded-type-in-scala. 2011</a></li>\n<li><a href="http://docs.scala-lang.org/overviews/core/architecture-of-scala-collections.html">Martin Odersky and Lex Spoon. Architecture of Scala Collection. scala-lang website. http://docs.scala-lang.org/overviews/core/architecture-of-scala-collections.html. 2013</a></li>\n<li><a href="http://stackoverflow.com/questions/5598085/where-does-scala-look-for-implicits">Daniel C. Sobral. Types of Implicits. StackOverflow. http://stackoverflow.com/questions/5598085/where-does-scala-look-for-implicits. 2011</a></li>\n<li><a href="http://blogs.atlassian.com/2013/09/scala-types-of-a-higher-kind/">Jed Wesley-Smith. Scala Types Of a Higher Kind. http://blogs.atlassian.com/2013/09/scala-types-of-a-higher-kind/</a></li>\n</ol>',id:"/Users/lliu/github/smilingleo.github.io/src/pages/2014/高种泛型.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2014-01-08T19:16:45.000Z",path:"/2014/generics-of-a-higher-kind",title:"高种泛型 (Generics of a Higher Kind)",excerpt:"Generics of a Higher Kind翻译加自我理解。",tags:["scala","functional programming","Generics"]}}},{node:{html:'<p>前文说过了，高阶函数式函数式语言中的基石，而<code>map</code>, <code>flatMap</code>更是重要。</p>\n<p>对于map，就是一个空间转换的概念，从这个空间映射到另外一个空间：</p>\n<ul>\n<li>必须是一一对应的，也就是这个空间的一个点也需要映射到另外一个空间的一个点。</li>\n</ul>\n<p>对于flatMap，一种理解是map + flatten，但是我觉得这种理解不好，应为在FP中，flatMap远比map重要。</p>\n<p>而map、flatMap加上withFilter和foreach实现了scala中最强大的for表达式。</p>\n<p>其实叫for表达式不准确，英文是有两种称谓：</p>\n<ul>\n<li>\n<p>for comprehension</p>\n<p>for {\nx &#x3C;- e1\ny &#x3C;- e2\n} yield e</p>\n<p>comprehension的含义是“理解力”，人如其名，这个表达式也有很强大的理解力。看文本文希望能够对这个方面有所帮助。</p>\n</li>\n<li>\n<p>for loop</p>\n</li>\n</ul>\n<pre><code>for {\n    i &#x3C;- e1\n} {\n    // do something.\n}\n</code></pre>\n<p>本文这里套用Martin在"Reactive Programming"中的例子，对如何应用map, flatMap, for表达式做个简单介绍。</p>\n<h2>例子</h2>\n<p>这个例子中，我们需要实现一个随机生成器，能够随机生成：Int, Boolean, Pair, List, Tree</p>\n<h2>实现</h2>\n<h3>规约定义</h3>\n<p>先定义一个Generator类，里面主要的方法就是一个<code>generate</code>，返回一个T</p>\n<!-- language:lang-scala -->\n<pre><code>trait Generator[T] { self =>\n  def generate : T\n}\n</code></pre>\n<h3>随机整数生成器</h3>\n<p>我们来实现一个随机整数生成器。</p>\n<!-- language:lang-scala -->\n<pre><code>val integers = new Generator[Int] {\n  def generate = {\n    val r = new java.util.Random\n    r.nextInt\n  }\n}\n</code></pre>\n<h3>随机布尔值生成器</h3>\n<p>再生成一个布尔值随机生成器。</p>\n<!-- language:lang-scala -->\n<pre><code>val booleans = new Generator[Boolean] {\n  def generate = {\n    val r = new java.util.Random\n    r.nextInt >= 0\n  }\n}\n</code></pre>\n<p>现在问题来了，上面的代码有两个问题：</p>\n<p>1.代码重复\n<code>val r = new java.util.Random ; r.nextInt</code>出现了两次</p>\n<p>2.有boilerplate代码，<code>new Generator[Boolean]</code>, <code>def generate</code>等等\n理想的情况应该是这样的：</p>\n<!-- language:lang-scala -->\n<pre><code>val booleans = for (i &#x3C;- integers) yield i > 0\n</code></pre>\n<p>但是如果你在REPL中尝试的话，会发现报错：</p>\n<!-- language:lang-scala -->\n<pre><code>scala> val boolean = for (i &#x3C;- integers) yield i >= 0\n&#x3C;console>:9: error: value map is not a member of Generator[Int]\n       val boolean = for (i &#x3C;- integers) yield i >= 0\n</code></pre>\n<p>OK, 因为for表达式就是对<code>map</code>, <code>flatMap</code>的简化，上面的代码会被翻译为：</p>\n<!-- language:lang-scala -->\n<pre><code>integers map { i => i > 0 }\n</code></pre>\n<p>我们没有在Generator中定义map，所以报错是必然的。修改一下：</p>\n<!-- language:lang-scala run -->\n<pre><code>trait Generator[T] { self =>\n  def generate : T\n\n  def map[S](f: T => S): Generator[S] = new Generator[S] {\n    def generate = f(self.generate)\n  }\n}\nval integers = new Generator[Int] {\n  def generate = {\n    val r = new java.util.Random\n    r.nextInt\n  }\n}\n\nval booleans = for (i &#x3C;- integers) yield i >= 0\nbooleans.generate\n</code></pre>\n<p>点击<code>run</code>按钮试试，一切顺利！不错。</p>\n<h3>随机Pair生成器</h3>\n<p>我们再继续，来点难点的，来个随机<code>(Int, Int)</code>生成器，想一下，很简单，调用两次<code>integers.generate</code>就可以了。</p>\n<!-- language:lang-scala -->\n<pre><code>val pairs = new Generator[(Int, Int)] {\n  def generate = (integers.generate, integers.generate)\n}\n</code></pre>\n<p>同样的，我们不希望有boilerplate代码，每次new一个匿名类，还要重新定义<code>generate</code>，这是java中的无奈之举，对于scala来说，我们希望这么写：</p>\n<!-- language:lang-scala -->\n<pre><code>val pairs = for {\n  x &#x3C;- integers\n  y &#x3C;- integers\n} yield (x, y)\n</code></pre>\n<p>但是当你试运行一下的时候会出现：</p>\n<pre><code>scala> val pairs = for (x &#x3C;- integers ; y &#x3C;- integers) yield (x, y)\n&#x3C;console>:9: error: value flatMap is not a member of Generator[Int]\n       val pairs = for (x &#x3C;- integers ; y &#x3C;- integers) yield (x, y)\n</code></pre>\n<p>编译器抱怨说没有flatMap定义在Generator上，怎么回事？</p>\n<p>同理，我们需要了解for表达式的翻译机理，上面的代码会背翻译为：</p>\n<!-- language:lang-scala -->\n<pre><code>integers flatMap { x => integers map { (x, _) }}\n</code></pre>\n<p>我们没有实现flatMap当然会出现这样的错误。好吧，我们来增强一下：</p>\n<!-- language:lang-scala run -->\n<pre><code>trait Generator[T] { self =>\n  def generate : T\n\n  def map[S](f: T => S): Generator[S] = new Generator[S] {\n    def generate = f(self.generate)\n  }\n\n  def flatMap[S](f: T => Generator[S]): Generator[S] = new Generator[S] {\n    def generate = f(self.generate).generate\n  }\n}\n\nval integers = new Generator[Int] {\n  def generate = {\n    val r = new java.util.Random\n    r.nextInt\n  }\n}\n\nval pairs = for {\n  x &#x3C;- integers\n  y &#x3C;- integers\n} yield (x, y)\n\npairs.generate\npairs.generate\n</code></pre>\n<p>不错吧，everything just works like a charm. </p>\n<p>我们还可以定义一些小工具，比如：</p>\n<!-- language:lang-scala -->\n<pre><code>def single[T](s: T) = new Generator[T] {\n  def generate = s\n}\n\ndef choose(from: Int, to: Int) = for { i &#x3C;- integers } yield (from + Math.abs(i) % (to - from))\n\ndef oneOf[T](choices: T*) = for ( idx &#x3C;- choose(0, choices.length) ) yield choices(idx)\n</code></pre>\n<p>看到OO中策略模式的影子了吗？</p>\n<h3>List[Int]生成器</h3>\n<!-- language:lang-scala -->\n<pre><code>def nonEmptyList = for {\n  head &#x3C;- integers\n  tail &#x3C;- lists\n} yield (head :: tail)\n\nval lists: Generator[List[Int]] = for {\n  isEmpty &#x3C;- oneOf(true, false, false, false, false)\n  list &#x3C;- if (isEmpty) single(Nil) else nonEmptyList\n} yield list\n</code></pre>\n<h3>Tree生成器</h3>\n<!-- language:lang-scala -->\n<pre><code>trait Tree\ncase class Node(left: Tree, right: Tree) extends Tree\ncase class Leaf(x: Int) extends Tree\n\ndef leafs: Generator[Leaf] = for ( i &#x3C;- integers ) yield Leaf(i)\n\n//不是尾递归，很容易StackOverflow\ndef nodes: Generator[Node] = for {\n  left &#x3C;- trees\n  right &#x3C;- trees\n} yield Node(left, right)\n\ndef trees: Generator[Tree] = for {\n  isLeaf &#x3C;- booleans\n  tree &#x3C;- if (isLeaf) leafs else nodes\n} yield tree\n</code></pre>\n<p>上面的代码因为用了递归，而且不是尾递归，很容易stackoverflow，一种workaround是增大<code>isLeaf</code>的概率，比如用<code>oneOf(true, true, true, false, false)</code>来替换<code>booleans</code>，这样就有2/3的概率为leaf，退出递归，但是还是很容易出错。下面用指令式的方式来实现以下：</p>\n<!-- language:lang-scala -->\n<pre><code>// 先根据深度，生成所有的叶子\nprivate def leafs(depth: Int): List[Option[Leaf]] = (Math.pow(2, depth - 1).toInt to 1 by -2).toList.foldLeft(List[Option[Leaf]]()) { (acc, ele) =>\n  val isLuck = booleans.generate\n  if (isLuck)\n    Some(Leaf(integers.generate)) :: Some(Leaf(integers.generate)) :: acc\n  else\n    None :: None :: acc\n}\n//依次聚集\nprivate def aggregate(children: List[Option[Tree]]): List[Option[Tree]] = {\n  if (children.length == 1) \n    children\n  else {\n    val length = children.length        \n    val parents = (length to 1 by -2).toList map { i => (children(i - 1), children(i - 2)) match {\n        case (Some(l), Some(r)) => Some(Node(l, r))\n        case (Some(l), None) => Some(Node(l, Leaf(integers.generate)))\n        case (None, Some(r)) => Some(Node(Leaf(integers.generate), r))\n        case (None, None) => Some(Leaf(integers.generate))\n      }\n    }\n    aggregate(parents)\n  }\n}\n\ndef generateTree(depth: Int) = aggregate(leafs(depth))(0).get\n</code></pre>\n<p>总的思路是：先根据深度生成可能的叶子，然后两两聚集为上一层的父节点，然后递归直到根节点。</p>\n<p>这个实现里同样没有用<code>可变量</code>。</p>\n<h4>Bonus: 打印tree</h4>\n<p>TBD</p>\n<h2>关于for表达式</h2>\n<p>如果你平常用for的场合都是在用一些collection的话，会产生一种错觉，以为for表达式智能应用在collection中，其实for表达式可以应用在任何定义了map/flatMap/withFilter/foreach的类型中，正如你在本文中看到的，那么一个问题是：</p>\n<!-- language:lang-scala -->\n<pre><code>val booleans = for ( x &#x3C;- integers ) yield x >= 0\n</code></pre>\n<p><code>booleans</code>的类型应该是什么呢？</p>\n<p>如果你经常用for于collection，你可能会觉得是一个List[Boolean]，其实不是，真正的返回值是：<code>Generator[Boolean]</code>，因为for表达式知道<code>integers</code>的类型是Generator所以其返回值也是Generator，这就是for comprehension的含义是“理解力”，人如其名，这个表达式也有很强大的理解力。看文本文希望能够对这个方面有所帮助。</p>\n<p>那么是如何实现的呢？其实很简单，将for表达式翻译为map你就知道其中玄机了。</p>\n<!-- language:lang-scala -->\n<pre><code>val booleans = for ( x &#x3C;- integers ) yield x >= 0 = integers map { _ >= 0 }\n</code></pre>',
id:"/Users/lliu/github/smilingleo.github.io/src/pages/2013/map-flatMap-for.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2013-12-01T19:16:45.000Z",path:"/2013/map-flatmap-for",title:"map/flatMap/for in Action",excerpt:"前文说过了，高阶函数式函数式语言中的基石，而`map`, `flatMap`更是重要。",tags:["scala","functional programming"]}}},{node:{html:'<p>Eric Meijer说：递归是函数式编程的GOTO，应该尽可能避免。如何避免，OO中我们用while循环，FP中我们用<code>fold</code>。</p>\n<h2>什么是fold</h2>\n<p>fold就是折纸，给你一张纸条，你可以将其分为若干等份（一个集合），然后从左向右一点一点卷折起来，折成一个你想要的形状，当然也可以从右向左，还可以对半折。</p>\n<pre><code>+---+---+---+---+---+---+---+---+---+---+---+---+\n|   |   |   |   |   |   |   |   |   |   |   |   |\n| --->  |   |   |   |   |   |   |   |   |   |   |\n|   |   |   |   |   |   |   |   |   |   |   |   |\n+---+---+---+---+---+---+---+---+---+---+---+---+\n</code></pre>\n<p>这里“你想要的形状”，就是最终<code>fold</code>的输出。</p>\n<p>风向的例子，北风就是从北面吹来的风。同样的，foldRight就是从右向左折叠，操作对象是seed集合，参数是前面集合的最后一个元素。</p>\n<h2>foldRight</h2>\n<!-- language:lang-scala -->\n<pre><code>List(1,2,3).foldRight(seed)(f) = f(1, f(2, f(3, seed)))\n</code></pre>\n<p>记住：等式两边各个因子出现的顺序是相同的，都是1 -> 2 -> 3 -> seed，之所以重要，是因为最后一个<code>f(3, seed)</code>接受的参数是一个tuple: (ele, seed)，而不是(seed, ele)。\n形象化一点，假设<code>f</code>是<code>cons</code>操作，也就是<code>::</code>:</p>\n<pre><code>    ::\n  /   \\\n1       ::\n       /  \\\n      2     ::\n           /  \\\n          3    seed \n</code></pre>\n<p>例子：求整数集合之和。</p>\n<!-- language:lang-scala run -->\n<pre><code>val sum = List(1,2,3).foldRight(0) { (ele, seed) => { println(ele); seed + ele } }\nprintln(sum)\n</code></pre>\n<p>点击<code>run</code>，可以看到，输出的<code>ele</code>顺序是<code>3 -> 2 -> 1</code>.</p>\n<h2>foldLeft</h2>\n<!-- language:lang-scala -->\n<pre><code>List(1,2,3).foldLeft(seed)(g) = g(g(g(seed, 1), 2), 3)\n</code></pre>\n<p>这里，前面List中元素的处理顺序还是从左向右的，只是seed跑到了最前面，所以tuple变成了：(seed, ele)。</p>\n<p>树形结构：</p>\n<pre><code>            g\n          /   \\\n        g      3\n      /   \\\n    g       2\n  /   \\\nseed   1\n</code></pre>\n<p>注意：这里我用的函数换成了<code>g</code>，而不是前面的<code>f</code>，就是想提醒大家，这是两个不同的函数，其参数都是tuple，但是seed的顺序不同。这在编程的时候经常搞混。</p>\n<p>相同的例子：求一个整数集合的和。</p>\n<!-- language:lang-scala run -->\n<pre><code>val sum = List(1,2,3).foldLeft(0) { (seed, ele) => { println(ele); seed + ele } }\nprintln(sum)\n</code></pre>\n<p>点击<code>run</code>，可以看到，输出的<code>ele</code>顺序是<code>1 -> 2 -> 3</code>.</p>\n<h2>助记</h2>\n<p>foldLeft/foldRight中block的参数tuple顺序经常搞混，为了方便记忆，我们可以这么来看，我们用seed做基准：</p>\n<ul>\n<li>foldRight，从右向左，tuple中seed在右<code>(elem, seed)</code></li>\n<li>foldLeft, 从左向右，tuple中seed在左<code>(seed, elem)</code></li>\n</ul>\n<p>有了fold是卷折纸的概念，我们就比较容易理解unfold.</p>\n<h2>unfold</h2>\n<p>与<code>fold</code>对应，<code>unfold</code>就是反过来将一个卷折好的纸分解开，变成若干等份（集合），所以unfold是一个集合的构造过程。</p>\n<h2>例子</h2>\n<p>我们这里举一个实际的例子。</p>\n<!-- language:lang-scala -->\n<pre><code>def retry(n: Int)(block: => Future[T]): Future[T] = {\n  if (n &#x3C;= 0) {\n    Future.failed{ new RuntimeException("failed even if retried") }\n  } else {\n    block fallbackTo {\n      retry(n - 1)(block)\n    }\n  }\n}\n</code></pre>\n<p>这里我们用了递归，但是如Erik Meijer所说，递归是FP的GOTO，不容易理解，容易出错，我们来用fold来替换一下。</p>\n<p>可是一般来说fold都是需要一个集合的，而这里有什么集合？没有条件，创造条件也要上！我们可以将<code>n</code>也就是次数看成是一个集合，因为逻辑上我们要作几次，每次算一个集合元素，那么这不就是一个集合吗？</p>\n<p>这个集合就是：<code>val attempts = (1 to n) map { _ => () => block }</code>，有了操作的集合，我们就可以开始玩折纸游戏了。</p>\n<p>我们最终要“折的形状”是：成功的话返回<code>T</code>，否则返回一个Failure。我们可以将一个缺省的failure作为seed开始。</p>\n<p>而且我们期望的执行顺序是：<code>block1 recoverWith (block2 recoverWith (block3 recoverWith failure))</code>，很明显，这是一个<code>foldRight</code>。</p>\n<!-- language:lang-scala -->\n<pre><code>def retry(n: Int)(block: => Future[T]) = {\n  val ns = (1 to n).iterator\n  // 注意：这里的map不关心ns中的系数，所以用\'_\'，后面需要一个by name参数，所以需要一个() => block，否则将会提前计算，达不到重试效果。\n  val attempts = ns map { _ => () => block }\n  val failure = Future.failed{ new RuntimeException("failed even if retried") }\n  // 这里seed是一个call by name\n  attempts.foldRight(() => failure) { (attempt, seed) =>\n    // seed是call by name，这里也需要是call by name\n    () => attempt() fallbackTo{ seed() }\n  }\n}\n</code></pre>',id:"/Users/lliu/github/smilingleo.github.io/src/pages/2013/fold编程.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2013-11-27T19:16:45.000Z",path:"/2013/fold",title:"折纸的艺术：fold编程",excerpt:"Eric Meijer说：递归是函数式编程的GOTO，应该尽可能避免。如何避免，OO中我们用while循环，FP中我们用`fold`。",tags:["scala","functional programming","fold"]}}},{node:{html:"<p>函数式语言与OO（确切地讲是指令式编程）的思维方式是完全不同的，很多OO中的经验在函数式语言中不是很匹配，比如设计模式，那就是一个OO中的特定术语，而在FP中，大家常谈的是对于习惯OO思维的程序员来说玄而又玄的Monad。</p>\n<p>虽然术语不同，其实要解决的问题是相同的，设计模式也好、Monad也好，都是为了如何更好地处理异常、让代码更加简洁易懂、容易扩展等等。【所以透彻地了解问题本身，比学习一个新的技术更加重要。】</p>\n<p>本系列文章试图能够将Monad这个及其抽象的东东具体化，将其落地，变为能够理解的例子，看看在具体问题下如何使用Monad来抽象问题，简化代码。</p>\n<h2>什么是Monad</h2>\n<h3>定义</h3>\n<p>一个Monad就是一个实现了flatMap, unit等函数，包含某种数据类型的容器，更加术语化一点是参数化类型<code>M[T]</code>.</p>\n<!-- language:lang-scala -->\n<pre><code>trait M[T] {\n  def flatMap[U](f: T => M[U]) : M[U]\n  def unit[T](x: T) : M[T]\n}\n</code></pre>\n<p>Monad需要满足三个定理（没错，就是定理，感觉回到了小学、初中的数学课堂）。</p>\n<ul>\n<li>\n<p>组合律</p>\n<p><code>(x flatMap f) flatMap g == x flatMap (y => f(y) flatMap g)</code></p>\n<p>有些人可能会问，右边为什么不是 <code>x flatMap (f flatMap g)</code>呢？ 你试一下就知道了，编译器报类型匹配错误，这里<code>x</code>是一个monad，<code>f</code>, <code>g</code>都是函数，所以<code>f flatMap g</code>会类型不匹配。</p>\n</li>\n<li>\n<p>左单一</p>\n<p><code>unit(x) flatMap f == f(x)</code></p>\n</li>\n<li>\n<p>右单一</p>\n<p><code>x flatMap unit == x</code></p>\n</li>\n</ul>\n<h3>Monad举例</h3>\n<p>在Scala中Monad不是新鲜玩意，其实只要你学scala，那你就会天天用，常用的Monad有：</p>\n<ul>\n<li>Collection类，比如：List, Set, Map</li>\n<li>描述可能性的Option  (Some, None)</li>\n<li>异常处理类 Try, scalaz中的Validation等</li>\n<li>描述未来的 Future</li>\n<li>封装状态变化的State</li>\n<li>封装IO的IO</li>\n</ul>\n<h2>Monad解决什么问题</h2>\n<p>正如上面列举的几个Monad，每种Monad都是为了解决某种具体问题而存在的，正如OO中设计模式一样，只不过Monad的侧重点是：</p>\n<ul>\n<li>\n<p>让你只关注代码主流程，而将异常等分支交给flatMap来处理。</p>\n</li>\n<li>\n<p>每个Monad是一个容器或者一个平行空间，让你可以在该容器（空间）中安全地、方便地操作容器中的数据类型，而不用关心相关问题。比如：在Option空间中，你不用考虑是否有返回值的问题，不需要像指令式编程那样<code>if (rtn == null) ... else ...</code>，再比如Future，让你能够在“未来的时空”中对数据进行操作，不用担心同步的问题，因为你的运算都发生在“未来”空间中。</p>\n</li>\n<li>\n<p>结合for表达式，让你的代码更加简洁、易读。</p>\n<p><code>for { x &#x3C;- monad; y &#x3C;- f(x); ...}</code></p>\n<p>而前面讲的定律（主要是结合律和右单一），可以确保monad在for表达式中使用的正确性，比如结合律：</p>\n</li>\n</ul>\n<!-- language:lang-scala -->\n<pre><code>for {\n  y &#x3C;- for (x &#x3C;- m; y &#x3C;- f(x)) yield y\n  z &#x3C;- g(y)\n} yield z\n</code></pre>\n<p>因为满足结合律，就可以简化为：</p>\n<!-- language:lang-scala -->\n<pre><code>for {\n  x &#x3C;- m\n  y &#x3C;- f(x)\n  z &#x3C;- g(y)\n} yield z\n</code></pre>\n<p>如果翻译为map/flatMap，前者翻译为：<code>m flatMap f flatMap g</code>，后者翻译为：<code>m flatMap (x => f(x) flatMap g)</code>.</p>\n<p>而右单一定律可以保证：<code>for {x &#x3C;- m} yield x == m</code>，如果你看过scalaz，你就了解为什么scalaz中需要有专门的test case来测试这些定律了。</p>\n<p>一般来说我们不太需要关注这些定律的问题，但是如果你需要自己开发一个自己的Monad，那么你就得保证你的Monad符合这些定律，因为这样才能让你的Monad安全地应用在for表达式中。</p>",id:"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Monad.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2013-11-26T07:16:45.000Z",path:"/2013/monad",title:"Monad",excerpt:"函数式语言与OO（确切地讲是指令式编程）的思维方式是完全不同的，很多OO中的经验在函数式语言中不是很匹配，比如设计模式，那就是一个OO中的特定术语，而在FP中，大家常谈的是对于习惯OO思维的程序员来说玄而又玄的Monad。",tags:["scala","functional programming","monad"]}}},{node:{html:'<p>所谓高阶函数（high order function），其实就是可以接受其他函数作为参数的函数。</p>\n<p>这里其实还有另外一个概念：<em>头等函数</em>（First Class Function），First Class应该是指头等公民的含义。在Java中的一个方法（函数），只能被调用，相比值Value就像个二等公民，不能像值Value一样，既可以在表达式中被引用，又可以作为参数传入其他方法。</p>\n<p>头等函数也就是可以将其作为一个值进行传递的函数。看上去很简单，可带来的变化是巨大的。</p>\n<p>头等函数加上高阶函数，可以极大地简化代码，实现DSL。</p>\n<h2>简化代码</h2>\n<h3>Java中的匿名类</h3>\n<!-- language:lang-java -->\n<pre><code>import java.util.*\n\nTimer timer = new Timer();\nTimerTask helloTimer = new TimerTask(){\n    public void run(){\n        System.out.println("Hello Timer");\n    }\n};\ntimer.schedule(helloTimer, 1);\n\nTimerTask helloWorld = new TimerTask(){\n    public void run(){\n        System.out.println("Hello World");\n    }\n};\ntimer.schedule(helloWorld, 1);\n</code></pre>\n<p>然后每次都需要new一个TimerTask匿名类，用起来真心不方便，尤其是当你有多个匿名类要一起使用的时候，那代码看起来简直就像一坨翔，丑陋无比！本来正常的、相同抽象层次的代码应该具有相同的缩进层次，这样阅读起来很易懂、顺畅。但是因为引入匿名类，就得放在不同的缩进层次中，加上不必要的类签名定义，方法定义等boilerplate code, 阅读起来那叫一个费劲！</p>\n<p>看看scala的方式：</p>\n<h1>Scala</h1>\n<!-- language:lang-scala run -->\n<pre><code>import scala.concurrent._\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nval timer = new java.util.Timer()\ndef timeout[A](a: => A, duration: Duration)(implicit ec: ExecutionContext): Future[A] = {\n    val p = Promise[A]()\n    timer.schedule(new java.util.TimerTask() {\n        def run() = {\n            p.success(a)\n        }\n    }, duration.toMillis)\n    p.future\n}\n\ntimeout(println("Hello World"), 1 millisecond)\ntimeout(println("Hello Timer"), 1 millisecond)\n</code></pre>\n<p>定义一个timeout高阶函数，接受一个<code>=> A</code>函数作为参数，然后就可以方便地重复调用了。\n</p>\n<h2>自定义控制结构+鸭子类型</h2>\n<h3>try with resources</h3>\n<p>在Java中，在处理一些资源相关的数据时，经常需要用一个<code>try .... catch ... finally { res.close(); }</code>的结构，同样地，这种结构使得代码的缩进层次和逻辑抽象层次不同而影响阅读。另外更严重的问题是常常忘记关闭资源。</p>\n<p>Java中的一种解决方案是用<code>template method</code>模式，比如Spring JdbcTemplate，传入一个匿名类，比如：</p>\n<!-- language: lang-java -->\n<pre><code>jdbcTemplate.execute(new StatementCallback(){\n    public Object doInStatement(Statement stmt) throws SQLException, DataAccessException {\n        // your real logic here\n    }\n}\n</code></pre>\n<p>可以看到，真正的逻辑被缩进了两层，有很多boilerplate代码。</p>\n<p>Java 1.7中引入了try with resources的语法，一定程度上解决了这个问题：</p>\n<!-- language: lang-java -->\n<pre><code>try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}\n</code></pre>\n<p>但是要求在try里面的资源必须实现<code>AutoCloseable</code>接口。当然了，Java中很多东西都是围绕接口转。接口就意味着规约，要使用try-with-resources语法，就必须符合这个规约。</p>\n<p>再看看Scala中如何实现：</p>\n<!-- language: lang-scala run -->\n<pre><code>def using[T &#x3C;: { def close() }](resource: T)(block: T => Unit) {\n  try {\n    block(resource)\n  }finally {\n    if (resource != null) resource.close()\n  }\n}\ncase class Resource {\n    def close() = println("I\'m closing")\n    def doSomething() = println("boring")\n}\n\nval res = Resource()\n\nusing[Resource](res){ res =>\n    res.doSomething()\n}\n</code></pre>\n<p>和<code>try-with-resources</code>的语法比较像吧，不过不同的是，<code>using</code>不要求传入的resource必须实现某种接口，只需要该类型定义了一个<code>def close(): Unit</code>方法。这就是所谓的鸭子类型，只要你走起来像鸭子，那你就是鸭子，不是一个很好的比喻，不过将就吧。</p>\n<h3>break</h3>\n<p>当你学习scala的时候，你会发现很多java中的关键字在scala中是不支持的，其中一个就是：<code>break</code>。</p>\n<p>在一个循环的时候，当满足某个条件就退出当前循环，是一个很普遍的用法，为什么scala中会不是一个关键字呢？我自己感觉是scala强调FP，而break有很浓的指令式编程的味道。</p>\n<p>那我就是想用break怎么办？不要紧，我们可以自己定义一个自己的break。</p>\n<!-- language: lang-scala run -->\n<pre><code>class Breaks {\n  private class BreakControl extends RuntimeException\n  private val breakException = new BreakControl\n\n  // breakable接受一个() => Unit的函数作为参数，是一个高阶函数。\n  def breakable(op: => Unit) {\n    try {\n      op\n    } catch {\n      case ex: BreakControl =>\n        if (ex ne breakException) throw ex\n    }\n  }\n\n  def break(): Nothing = { throw breakException }\n}\nobject Breaks extends Breaks\n\n\nimport Breaks.{break, breakable}\n// 通过高阶函数来实现break\nbreakable {\n  for (i &#x3C;- (1 to 1000)) {\n    if (i > 10){\n      break\n    } else {\n      println(i)\n    }\n  }\n}\n</code></pre>\n<p>是不是很棒？！scala没有我们可以自己造。这就是高阶函数的用处之一。</p>',id:"/Users/lliu/github/smilingleo.github.io/src/pages/2013/高阶函数.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2013-11-21T19:16:45.000Z",path:"/2013/high-order-function",title:"高阶函数",excerpt:"所谓高阶函数（high order function），其实就是可以接受其他函数作为参数的函数。",tags:["scala","functional programming","high order function"]}}},{node:{html:'<h2>上下文</h2>\n<p>很多时候为了提高性能，减少IO操作，都会将数据load出来之后缓存在内存中。本站的实现过程中也遇到类似的问题，不希望每次有人访问的时候就读取一次md文件，或者从MongoDB中查一次，而是直接在内存中读取。</p>\n<p>带来因减少IO而提升性能的好处的同时，也出现一个人和“缓存”解决方案都会遇到的问题：数据一致性。</p>\n<p>简单来说，就是你有同样的一份数据，冗余存放在两个地方，如何确保这两个地方的数据是一致的？再具体一点，可能的问题有：</p>\n<ul>\n<li>\n<p>数据更新的原子性</p>\n<p>更新数据的时候，同时将两个地方的数据都同步更新，任何一个地方更新失败，则整体更新失败。</p>\n</li>\n<li>\n<p>缓存线程安全的问题</p>\n<p>如果缓存既可以被读取，又可能被更新，那么就又线程安全问题：多个线程同时操作同一个值的时候怎么协调？</p>\n</li>\n</ul>\n<h2>具体问题</h2>\n<p>开始的时候，我将所有的文章列表放在一个<code>scala.collection.mutable.ListBuffer</code>中：</p>\n<!-- language:lang-scala -->\n<pre><code>object Application extends Controller {\n  lazy val allPosts: ListBuffer[Post] = ...\n\n}\n</code></pre>\n<p>因为新发布博客会增加集合内数据，所以这里用ListBuffer比较自然。当然用<code>var</code> + immutable collection也可以。</p>\n<p>对<code>allPost</code>的操作主要有三个：</p>\n<ol>\n<li>\n<p>在线编写一个博客的时候需要添加到集合中</p>\n</li>\n<li>\n<p>该集合本身是无序的，因为排序的规则可能有多种，展现的时候再排序</p>\n</li>\n<li>\n<p>更新一篇博文的时候同时更新集合中内容。</p>\n</li>\n</ol>\n<p>因为本身Application Object是单例的，多个线程共同运行的场景下就会出现线程安全的问题，类似Servlet中instance级别变量的问题。</p>\n<h2>解决方案</h2>\n<p>直观地想，理想的解决方案就是将所有对<code>allPost</code>的写操作都串行起来，这样即使有多个线程同时操作，也没问题了。但是如何将实现串行呢？</p>\n<p>在指令式编程的世界里，这个问题比较难于解答，一般需要通过加锁来解决。而一般的程序员看到<code>lock</code>, <code>synchronized</code>这些关键字就头疼了，即使经过无数次盲试之后侥幸实现了，也会在产品上线的时候出现这样那样、莫名其妙、让你大呼“这不科学”，“WTF”的惊呼！</p>\n<p>但是在scala中，我们却不用担心，因为我们有<code>Akka Actor</code>。</p>\n<p>Actor是另外一种并行计算方式，不同于线程共享内存的并发模型，Actor是基于消息的，强调不同Actor之间不共享数据。有了Actor，问题就迎刃而解了。</p>\n<p>具体思路是：重建一个单例Actor，由该Actor来维护ListBuffer变量，所有的写操作，全部通过该消息提交任务交给其处理，这样就将并发的多个写请求串行起来了。</p>\n<p>代码片段：</p>\n<!-- language:lang-scala -->\n<pre><code>object PostManager {\n  // 单例manager actor\n  lazy val manager = Akka.system.actorOf(Props[PostManager])\n  case class NewPost(post: Post)\n  \n  def saveOrUpdate(unsavedPost: Post) = {\n    manager ! NewPost(unsavedPost)\n  }\n}\n\nclass PostManager extends Actor {\n  import PostManager._\n  // actor是单例的，所以文章集合也是单例的。\n  // all posts, but not ordered.\n  lazy val allPosts: ListBuffer[Post] = Post.allPosts\n  \n  def receive = {\n    case NewPost(newPost) =>\n      // 先更新数据库，这样如果更新失败，就不会运行之后代码。一定程度上实现原子性。\n      Post.upsert(newPost)\n      \n      val idx = allPosts.indexWhere( _.fileName == newPost.fileName )\n      \n      if (idx == -1){\n        allPosts += newPost\n      } else {\n        allPosts.update(idx, newPost)\n      }\n  }\n}\n</code></pre>\n<p>全站一个文章集合变量感觉有点"玩具"的感觉，不过这个模型其实是可以扩展的，比如将来如果支持多用户、多博客系统，我们可以每个用户创建一个Actor、维护该用户自己的文章列表。这个Actor模型还是可以重用的。</p>',id:"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Actor协调并发场景下的集合操作.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2013-11-17T14:16:45.000Z",path:"/2013/actor-collection-collabration",title:"边建边学-3：Actor协调并发场景下的集合操作",excerpt:"很多时候为了提高性能，减少IO操作，都会将数据load出来之后缓存在内存中。本站的实现过程中也遇到类似的问题，不希望每次有人访问的时候就读取一次md文件，或者从MongoDB中查一次，而是直接在内存中读取。",tags:["scala","functional programming"]}}},{node:{html:'<h2>Context</h2>\n<p>插曲：前不久微博上看到一技术“牛人”大V评论Java8的一些特性，引入lambada但没有扩展能力，集合的查询都得靠新stream api而不是Enumerator / Iterator云云。一时手欠回复了下“似乎应该是Enumerator / Iteratee“, 结果引来一身骚，被该大V泼口大骂了一个下午，没错就是像网吧里面无聊的小青年一样无营养地谩骂，实在没搞懂到底是为什么，说我说的Iteratee和他说的没”鸡毛“关系，不懂，也不想搞懂了，还是他玩他的Iterator我介绍我的Iteratee吧。</p>\n<p>因为我们的内存、磁盘等资源还是有限的，对于一个大的Stream，Collection，我们在处理的时候不应该将其作为整体进行处理，因为这样会带来潜在的风险，比如：内存溢出，降低系统吞吐量等等。</p>\n<p>正确的方式是将大的不可预见（unpredictable）的stream，Collection进行分解，将其分解为小的，可预见（predictable）的块进行处理。这是流模式的思想，也是Iteratee的设计目标之一。</p>\n<p>Stream对于指令式编程已经比较成熟了，有大量的类库，丰富的API。但是对于强调不可变量，尽可能无副作用的FP来说，要考虑语言适配的问题，而目前，流行的解决方案就是：Enumerator/Iteratee。</p>\n<p>另外，就是需要用统一的API来处理所有类型的Stream，就像指令式编程中的<code>InputStream.read</code>, <code>OutputStream.write</code>，无论什么Stream都需要支持这些基本方法。</p>\n<h2>High Level Concept Model</h2>\n<p>Enumerator / Iteratee说起来很复杂，其实就是一个生产者 / 消费者模型。 Enumerator是生产者，创建诸多个可控的chunk，Iteratee是消费者，消费任意类型的Input Chunk。</p>\n<!-- language:lang-scala -->\n<pre><code>trait Enumerator {\n  def |>>[A](i: Iteratee[E, A]): Future[Iteratee[E, A]] = apply(i)\n}\n</code></pre>\n<p>Enumerator驱动一个Iteratee，Iteratee处理一个Chunk之后，返回下一个状态的Iteratee. 在构造Enumerator的时候不会真正读取数据，只有在真正消费时才产生IO。</p>\n<p>而且多个Enumerator之间可以组合，不同类型的消费者（Iteratee）也可以进行组合、变换，简言之，组合的概念就是将每个Enumerator / Iteratee都看成是一个可组合的积木，每个积木相对独立可复用，写代码就是将这些积木组合达成你想要形状的过程。这个说法很常见，OO里提倡“组合优于继承”也是一样的思想，其中的关键是如何找到最小的可复用的component，然后是通过什么样的方式进行灵活地组合。</p>\n<p>Enumerator / Iteratee / Enumeratee就是一个非常好的例子。</p>\n<h2>消费者 Iteratee</h2>\n<!-- language:lang-scala -->\n<pre><code>class Iteratee &#x3C;&#x3C; (T, #00FF00) >> {\n  Future[B] fold[B](folder: Step[E, A] => Future[B])\n}\nclass ImmediateIteratee &#x3C;&#x3C; (T, #00FF00) >>\nclass Done &#x3C;&#x3C; (O, #FF0000) >>\nclass Cont &#x3C;&#x3C; (O, #FF0000) >>\nclass Error &#x3C;&#x3C; (O, #FF0000) >>\nclass Step &#x3C;&#x3C; (T, #00FF00) >>\nclass Input &#x3C;&#x3C; (T, #00FF00) >>\n\nIteratee &#x3C;|-- ImmediateIteratee\nIteratee &#x3C;|-- FutureIteratee\nIteratee &#x3C;.left.> Step\nStep .left.> Input\n\nImmediateIteratee &#x3C;|-- DoneIteratee\nDoneIteratee .. Done\nImmediateIteratee &#x3C;|-- ContIteratee\nContIteratee .. Cont\nImmediateIteratee &#x3C;|-- ErrorIteratee\nErrorIteratee .. Error\n\nnote "company objects" as oNote\nDone .. oNote\nCont .. oNote\nError .. oNote\n</code></pre>\n<p>Iteratee是一个Input的消费者，注意：这里的Input不是全部输入，而是a chunk of input，这个很重要，没有一个Iteratee来消费所有输入数据，而是每块一个消费者，然后通过函数组合的方式将所有块穿起来。</p>\n<ul>\n<li>\n<p>为什么不是一个完整输入对应一个消费者呢？\n这是指令式编程的思维方式，因为你需要自己考虑实现细节，设计一些游标，每次读取步进的长度，判断游标的位置来判断下一步如何操作。</p>\n</li>\n<li>\n<p>为什么不是所有的输入chunk共享一个消费者呢？\n嗯，这个问题我不是很确定，应该是有一部分上面的原因，另外就是副作用的问题，每个Step自己维护自己的状态，可以比较容易地实现“懒加载”，在最后一步（调用<code>run</code>）的时候才真正发生IO，而之前，可以通过函数组合任意对每一步进行transform等操作。</p>\n</li>\n</ul>\n<p>Iteratee还有一个需要注意的地方，fold函数是一个<code>curried function</code>，有一个implicit的参数ExecutionContext，也就是在哪个线程池中执行，这个现象在Play中很普遍。</p>\n<p>ImmediateIteratee描述了一个已经预先知道其state的Iteratee，而FutureIteratee当然就是未来才能知道其State的Iteratee。[个人感觉这个地方设计有点怪，FutureIteratee似乎应该用Future[Iteratee]更好。] </p>\n<!-- language:uml -->\n<pre><code>class Step &#x3C;&#x3C; (T, #00FF00) >> {\n  Iteratee[E, A] it\n}\nclass Iteratee &#x3C;&#x3C; (T, #00FF00) >>\nclass Input &#x3C;&#x3C; (T, #00FF00) >>\nStep .left.> Input\nStep &#x3C;-right-> Iteratee\nStep &#x3C;|-- Done\nStep &#x3C;|-- Cont\nStep &#x3C;|-- Error\n</code></pre>\n<p>Step描述的是一个Iteratee的状态，其本身包含一个Iteratee不变量<code>it</code>，而Done、Cont、Error也是简单的<code>case class</code>，所以构造也很简单。</p>\n<!-- language:uml -->\n<pre><code>class Input &#x3C;&#x3C; (T, #00FF00) >>\nInput &#x3C;|-- El\nInput &#x3C;|-- Empty\nInput &#x3C;|-- EOF\n</code></pre>\n<p>Input[E]描述的是<code>一块</code>输入(a chunk of input，不是全部输入)，构造其实很简单，就是一个简单的case class，可以按照你熟悉的方式来构造。</p>\n<h2>生产者 Enumerator</h2>\n<p>先来看看Enumerator的定义：</p>\n<!-- language:lang-scala -->\n<pre><code>trait Enumerator[E] {\n\n  /**\n   * Apply this Enumerator to an Iteratee\n   */\n  def apply[A](i: Iteratee[E, A]): Future[Iteratee[E, A]]\n  def |>>[A](i: Iteratee[E, A]): Future[Iteratee[E, A]] = apply(i)\n  ...\n\n}\n</code></pre>\n<p>由上面定义可以看到，一个<code>Enumerator</code>接受一个<code>Iteratee[E, A]</code>，并返回一个<code>Future[Iteratee[E, A]]</code>，翻译一下就是：Enumerator驱动一个消费者，消费数据之后产生一个下个状态的消费者。</p>\n<p>Enumerator提供了大量的工厂方法（在scala中是通过伴生对象来实现），比如，你可以从一个数组创建一个Enumerator:</p>\n<!-- language:lang-scala -->\n<pre><code>val enumerateCountries = Enumerator[String] = Enumerator("China", "America", "Japan", "Russia", "England")\n</code></pre>\n<p>可以从一个文件中创建：</p>\n<!-- language:lang-scala -->\n<pre><code>val enumerateFile: Enumerator[Array[Byte]] = Enumerator.fromFile(new File("path/to/some/big/file"))\n</code></pre>\n<p>或者从一个Stream中创建：</p>\n<!-- language:lang-scala -->\n<pre><code>val enumerateFile: Enumerator[Array[Byte]] = Enumerator.fromStream(new java.io.FileInputStream(new File("path/to/some/big/file")))    \n</code></pre>\n<p>更加通用的方式是从一个<code>e: ()=>Future[Option[E]]</code>函数来创建，因为这个函数声明了：未来可能会产生一个<code>E</code>:</p>\n<!-- language:lang-scala -->\n<pre><code>def generateM[E](e: => Future[Option[E]])(implicit ec: ExecutionContext): Enumerator[E] = {\n    ...\n}\n</code></pre>\n<p>发挥一下你的想象，很多事情都可以看成是Stream，比如时间：</p>\n<!-- language:lang-scala -->\n<pre><code>import play.api.libs.concurrent.Promise\nimport play.api.libs.iteratee._\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport java.util.Date\n\n// 截止时间\nval alertTo = new Date(System.currentTimeMillis + 1000*60)\n\n// 一个时间流，截止到alertTo\nval timeStream = Enumerator.generateM {\n    Promise.timeout(\n      if (new Date before alertTo) Some(new Date) else None, \n      1 seconds)\n}\n\nval printlnSink = Iteratee.foreach[Date](date => println(date))\n// 每隔一秒钟打印一次，直到alertTo\ntimeStream |>> printlnSink\n</code></pre>\n<p>如果你想再play console里面运行上面的代码，可能会失败，说什么:no application started之类的，这时你需要前面加上：</p>\n<!-- language:lang-scala -->\n<pre><code>val app = new play.core.StaticApplication(new java.io.File("."))\n</code></pre>\n<p>创建一个测试用的application，再试一下就OK了。</p>\n<p>除了这个例子，我觉得也可以将数据库中的游标查询用Enumerator来实现。</p>\n<p>在Play框架中，还有一个实际的例子是<code>WebSocket</code>，有机会我们再单独介绍。</p>\n<h2>适配器 Enumeratee</h2>\n<p>对应OO Design Pattern中的Adaptor模式，<code>Enumeratee</code>就是一个Adaptor，将不同规格的组件适配在一起。比如下面这个例子：</p>\n<p>我们有一个String类型的Enumerator, <code>Enumerator("123", "456", "789", "222", "333", "444")</code>，还有一个累加器，<code>Iteratee.fold[Long, Long](0:Long) { (acc, el) => acc + el }</code>，两者的“规格”是不同的，一个是String， 但另外一个是Long，当然我们可以再定义一个新的Iteratee，比如：<code>Iteratee.fold[String, Long](0:Long) { (acc, el) => acc + el.toLong }</code>，但是显然，这里面有重复代码的臭味道。更加合理的方式是做一个适配，用一个适配器来讲两个已经存在的component转接后一起工作。</p>\n<!-- language:lang-scala run -->\n<pre><code>import play.api.libs.iteratee._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nval strings = Enumerator("123", "456", "789", "222", "333", "444")\nval sum = Iteratee.fold[Long, Long](0:Long) { (acc, el) => acc + el }\nval toLong = Enumeratee.map[String]( x => x.toLong )\n\nstrings |>> toLong &#x26;>> sum flatMap { x => x.run } onSuccess { case s => println(s) }\n// Or, transform the Enumerator first.\nstrings &#x26;> toLong |>> sum flatMap { x => x.run } onSuccess { case s => println(s) }\n</code></pre>\n<p>上面例子可以看到，<code>Enumeratee</code>不但可以适配<code>Iteratee</code>，还可以转换<code>Enumerator</code>。</p>\n<p>留个问题：<code>strings &#x26;> toLong</code>会不会产生memory的问题？ </p>\n<h2>指令式 VS. 函数式</h2>\n<p>这里用一个很无聊的例子：遍历一个大文件来统计文件大小。</p>\n<h3>指令式风格</h3>\n<p>Use Java FileInputStream, more imperative style:</p>\n<!-- language:lang-scala -->\n<pre><code>val fis = new java.io.FileInputStream(new java.io.File("/Users/leo/Movies/big_file.mkv"))\n\n// mutable variables\nvar readLength = 0\nvar fileSize: Long = 0\nvar buf = new Array[Byte](1024 * 8) // chunk size used in Enumerator\nval begin = System.currentTimeMillis\ndo {\n  readLength = fis.read(buf)\n  if (readLength != -1)\n    fileSize = fileSize + readLength\n}while(readLength != -1)\n\nprintln(s"File Size: $fileSize, and it took ${System.currentTimeMillis - begin} ms")\n</code></pre>\n<p>And output like <code>File Size: 4003885806, and it took 54701 ms</code>, the memory usage is about <code>78Mb</code>.</p>\n<h3>函数式风格</h3>\n<p>Use Enumerator / Iteratee to get file size:</p>\n<!-- language:lang-scala -->\n<pre><code>import play.api.libs.iteratee._\n// construct an Enumerator from a file\nval fileEnum = Enumerator.fromFile(new java.io.File("/Users/leo/Movies/big_file.mkv")) \n// create a consumer\nval counter = Iteratee.fold[Array[Byte], Long](0: Long){ (acc, ele) => ele.size + acc }\n\nval begin = System.currentTimeMillis\n// where the IO really happens.\nIteratee.flatten(fileEnum |>> counter).run.onSuccess { case x => println(s"File Size: $x, and it took ${System.currentTimeMillis - begin} ms") }\n</code></pre>\n<p>Here\'s the output: <code>File Size: 4003885806, and it took 57213 ms</code>, and max memory usage is about <code>120Mb</code>. </p>\n<p>Note: If you are running above code with Scala version &#x3C; 2.10.3, you\'ll run into <code>OutOfMemory</code> Error, it\'s so funny right? Enumerator / Iteratee suppose to be designed to solve the OutOfMemory issue, actually, it\'s not Enumerator/Iteratee \'s problem, it\'s a bug of scala, see <a href="https://issues.scala-lang.org/browse/SI-7336">SI-7336</a></p>\n<h3>对比</h3>\n<p>从上面的两种实现来看，从执行时间上，两种方式没有太大差异，但是指令式编程在内存占用方面要优于函数式编程，毕竟var变量可以复用，val变量需要重新生成。但是差别并没有想象中那么大，处理一个4G的文件，差别只是40M左右。但是带来的好处是显而易见的：因为没有mutable变量，没有副作用，并发、代码可读性有提高。</p>',id:"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Enumerator-Iteratee-Enumeratee.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2013-11-11T14:16:45.000Z",path:"/2013/enumerator-iteratee-enumeratee",title:"Enumerator / Iteratee / Enumeratee",excerpt:"Stream对于指令式编程已经比较成熟了，有大量的类库，丰富的API。但是对于强调不可变量，尽可能无副作用的FP来说，要考虑语言适配的问题，而目前，流行的解决方案就是：Enumerator/Iteratee。",tags:["scala","playframework","blog"]}}},{node:{html:'<p>Markdown是一个很爽的写作格式（或者说语言更合适一点），我们不再需要复杂的富文本编辑器，用纯文本就可以编写出布局漂亮的文章。</p>\n<p>不过Markdown对于技术类文章来说还有一个不足：我们经常需要画一些图来阐述自己的思路，但是Markdown只能引用已经存在的图。</p>\n<p>有没有可能用Plain Text来画图呢？AscII艺术图？太原始了。试试PlantUML吧。</p>\n<h2>PlantUML介绍</h2>\n<p>从某个角度说，<a href="http://plantuml.sourceforge.net">PlantUML</a>简直就是Markdown的绝配，也只需要纯文本就可以实现漂亮的效果，只是这里变成更炫的UML图。</p>\n<p>比如我想画一个类图，Cat和Dog继承Animal，用PlantUML来实现就是：</p>\n<pre><code>@startuml\nAnimal &#x3C;|-- Cat\nAnimal &#x3C;|-- Dog\n@enduml\n</code></pre>\n<p>是不是很简单？来看看效果：</p>\n<!-- language:uml -->\n<pre><code>Animal &#x3C;|-- Cat\nAnimal &#x3C;|-- Dog\n</code></pre>\n<p>怎么样？不错吧，这个图片哪里来的？其实在我发布这篇文章的时候，这个类图还不存在，只有在你访问这篇文章的时候才自动生成的。PlantUML有一个jQuery插件，可以在运行时生成图片。</p>\n<p>PlantUML的jQuery插件用法很简单，你只需要在html中编辑：</p>\n<!-- language:lang-html -->\n<pre><code>&#x3C;img uml="\n  Animal &#x3C;|-- Cat\n  Animal &#x3C;|-- Dog\n">\n</code></pre>\n<p>jQuery插件会自动增强这个img元素，具体实现还挺有意思，这里不细说了。</p>\n<p>可这还不够，怎么在Markdown中写<code>img</code>呢？如果你照抄上面的img代码，pegdown解析器会抛错，\'&#x3C;\'不匹配云云。</p>\n<h2>解决方案</h2>\n<p>基本上这种问题可以从两个方面想办法，一个是服务器端，实现一个markdown parser plugin，来定制一个特殊语法，另一个方向是从浏览器端想办法。</p>\n<p>从上面的介绍中我们知道，已经有jQuery插件了，那从前端做似乎更加容易一些。此外，从<a href="http://www.learn-scala.net/blogs/2013-11-01_14.md">上一篇</a>我们已经知道，在<code>pre code</code>前面加上一个<code>&#x3C;!-- language:lang-scala --></code>来实现语法高亮显示问题。</p>\n<p>PlantUML的内容也可以认为是一种code，很自然地，我们可以用<code>pre code</code>来封装。比如我们可以用：</p>\n<!-- language:lang-html -->\n<pre><code>&#x3C;!-- language:uml -->\n    Animal &#x3C;|-- Cat\n    Animal &#x3C;|-- Dog\n</code></pre>\n<p>这里我们自定义了一种language类型<code>uml</code>，在前端解析的时候，就能知道这个代码块是用来画图的了。</p>\n<p>好，我们来看前端JS代码的实现：</p>\n<!-- language:lang-javascript -->\n<pre><code>function init() {\n  var plantuml = false;\n  var blocks = document.querySelectorAll(\'pre code\');\n  // 遍历所有pre code\n  for (var i = 0; i &#x3C; blocks.length; i += 1) {\n    var code = blocks[i];\n    //code.className += \' prettyprint\';\n    var pre = code.parentNode;\n    var above = pre;\n    do {\n      above = above.previousSibling;\n    } while (above.nodeType == Node.TEXT_NODE)\n    // 检查注释元素据\n    if (above.nodeType == Node.COMMENT_NODE) {\n      var comment = above.data;\n      // 正则表达式，获取语言类型\n      var pattern = /^\\s*language:\\s*([\\w\\-]+)\\s*(\\w+)?\\s*$/i;\n      var match = pattern.exec(comment);\n      if (match != null) {\n        var lang = match[1];\n        // 如果是uml，动态生成一个img元素，并设置uml属性值为pre code的内容。\n        if (lang &#x26;&#x26; lang == "uml") {\n          var container = document.createElement("div");          \n          var img = document.createElement("img");\n          img.setAttribute("uml", code.innerText || code.textContent);\n\n          container.appendChild(img);\n          container.className = "text-center";\n\n          pre.insertAdjacentElement(\'afterEnd\', container);\n          // 将pre code隐藏起来，只显示图片\n          pre.style.display = "none";\n          plantuml = true;\n        }\n      }\n    }\n  }\n  // 调用jQuery插件生成图片。\n  if (plantuml) {\n    plantuml_runonce();\n  }\n}\n</code></pre>\n<p>然后，在html中调用：</p>\n<!-- language:lang-html -->\n<pre><code>&#x3C;script type=\'text/javascript\'>\n  window.onload = init;    \n&#x3C;/script>  \n</code></pre>\n<p>搞定，收工！！写作、布局编排、画图全部纯文本，爽！</p>\n<p>附上一个PlantUML的参考文档，原本上sourceforge网站就可以了，可惜被墙了，点击<a href="http://www.learn-scala.net/assets/ebooks/PlantUML_Language_Reference_Guide.pdf.zip">这里</a>下载吧。</p>',id:"/Users/lliu/github/smilingleo.github.io/src/pages/2013/集成PlantUML和Markdown.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2013-11-07T19:16:45.000Z",path:"/2013/markdown-plantuml-integration",title:"边建边学-2：集成PlantUML和Markdown",excerpt:"如何用Markdown+PlantUML结合来写图文并茂的博客。",tags:["markdown","plantuml","blog"]}}}],pathPrefix:"",first:!1,last:!1,index:2,pageCount:3}}}});
//# sourceMappingURL=path---2-8c90ada2d550ea6fc607.js.map