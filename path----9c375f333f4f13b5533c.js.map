{"version":3,"sources":["webpack:///path----9c375f333f4f13b5533c.js","webpack:///./.cache/json/index.json","webpack:///./.cache/json/layout-index.json"],"names":["webpackJsonp","364","module","exports","data","allMarkdownRemark","totalCount","edges","node","id","frontmatter","title","date","path","tags","excerpt","pathContext","group","html","pathPrefix","first","last","index","pageCount","109","layoutContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,mBAAqBC,WAAA,GAAAC,QAA0BC,MAAQC,GAAA,iHAAAC,aAAqIC,MAAA,oBAAAC,KAAA,iBAAAC,KAAA,wCAAAC,MAAA,QAAAC,QAAA,gEAA6LP,MAAQC,GAAA,4GAAAC,aAAgIC,MAAA,0BAAAC,KAAA,iBAAAC,KAAA,yBAAAC,MAAA,0BAAAC,QAAA,sBAA4JP,MAAQC,GAAA,mHAAAC,aAAuIC,MAAA,wBAAAC,KAAA,iBAAAC,KAAA,oCAAAC,MAAA,mCAAAC,QAAA,yCAAiMP,MAAQC,GAAA,0GAAAC,aAA8HC,MAAA,gBAAAC,KAAA,iBAAAC,KAAA,WAAAC,MAAA,oBAAAC,QAAA,uIAA+OP,MAAQC,GAAA,2GAAAC,aAA+HC,MAAA,gBAAAC,KAAA,oBAAAC,KAAA,yCAAAC,MAAA,kCAAAC,QAAA,oGAA2PP,MAAQC,GAAA,8GAAAC,aAAkIC,MAAA,uBAAAC,KAAA,kBAAAC,KAAA,8BAAAC,MAAA,gDAAAC,QAAA,kJAAiTP,MAAQC,GAAA,yGAAAC,aAA6HC,MAAA,YAAAC,KAAA,iBAAAC,KAAA,+BAAAC,MAAA,4BAAAC,QAAA,qKAAqSP,MAAQC,GAAA,wHAAAC,aAA4IC,MAAA,2CAAAC,KAAA,iBAAAC,KAAA,oCAAAC,MAAA,kBAAAC,QAAA,mDAA6MP,MAAQC,GAAA,4GAAAC,aAAgIC,MAAA,eAAAC,KAAA,eAAAC,KAAA,yCAAAC,MAAA,uDAAAC,QAAA,+FAAqQP,MAAQC,GAAA,oGAAAC,aAAwHC,MAAA,mCAAAC,KAAA,mBAAAC,KAAA,kCAAAC,MAAA,6CAAAC,QAAA,wCAAqNP,MAAQC,GAAA,+GAAAC,aAAmIC,MAAA,4BAAAC,KAAA,oBAAAC,KAAA,wBAAAC,MAAA,kCAAAC,QAAA,kDAAoMP,MAAQC,GAAA,sGAAAC,aAA0HC,MAAA,eAAAC,KAAA,oBAAAC,KAAA,aAAAC,MAAA,yCAAAC,QAAA,0EAA2MP,MAAQC,GAAA,qGAAAC,aAAyHC,MAAA,QAAAC,KAAA,oBAAAC,KAAA,cAAAC,MAAA,0CAAAC,QAAA,sHAAkPP,MAAQC,GAAA,oGAAAC,aAAwHC,MAAA,OAAAC,KAAA,oBAAAC,KAAA,4BAAAC,MAAA,wDAAAC,QAAA,uDAA8MP,MAAQC,GAAA,iHAAAC,aAAqIC,MAAA,2BAAAC,KAAA,oBAAAC,KAAA,sCAAAC,MAAA,kCAAAC,QAAA,8GAA6QP,MAAQC,GAAA,8HAAAC,aAAkJC,MAAA,qCAAAC,KAAA,oBAAAC,KAAA,uCAAAC,MAAA,gCAAAC,QAAA,+GAAuRP,MAAQC,GAAA,mHAAAC,aAAuIC,MAAA,6BAAAC,KAAA,oBAAAC,KAAA,sCAAAC,MAAA,8BAAAC,QAAA,uCAAoMP,MAAQC,GAAA,gIAAAC,aAAoJC,MAAA,mCAAAC,KAAA,oBAAAC,KAAA,iCAAAC,MAAA,yBAAAC,QAAA,sCAA+LP,MAAQC,GAAA,kHAAAC,aAAsIC,MAAA,uBAAAC,KAAA,oBAAAC,KAAA,+BAAAC,MAAA,mBAAAC,QAAA,oFAAyNP,MAAQC,GAAA,kGAAAC,aAAsHC,MAAA,KAAAC,KAAA,mBAAAC,KAAA,cAAAC,QAAAC,QAAA,aAA4FC,aAAgBC,QAAUT,MAAQU,KAAA,05CAAqvCT,GAAA,iHAAAC,aAAiTE,KAAA,gCAAAC,KAAA,wCAAAF,MAAA,oBAAAI,QAAA,4DAAAD,MAAA,YAA4MN,MAAQU,KAAA,8rFAAurFT,GAAA,4GAAAC,aAA+IE,KAAA,6BAAAC,KAAA,yBAAAF,MAAA,0BAAAI,QAAA,kBAAAD,MAAA,8BAAwKN,MAAQU,KAAA,wyFAAAT,GAAA,mHAAAC,aAAk9FE,KAAA,6BAAAC,KAAA,oCAAAF,MAAA,wBAAAI,QAAA,qCAAAD,MAAA,uCAA6MN,MAAQU,KAAA,w9CAAojCT,GAAA,0GAAAC,aAAyiBE,KAAA,2BAAAC,KAAA,WAAAF,MAAA,gBAAAI,QAAA,mIAAAD,MAAA,wBAAyPN,MAAQU,KAAA,ugFAAixCT,GAAA,2GAAAC,aAAw4CE,KAAA,2BAAAC,KAAA,yCAAAF,MAAA,gBAAAI,QAAA,gGAAAD,MAAA,sCAAkQN,MAAQU,KAAA,+sKAAwqKT,GAAA,8GAAAC,aAA8NE,KAAA,2BAAAC,KAAA,8BAAAF,MAAA,uBAAAI,QAAA,8IAAAD,MAAA,oDAA0TN,MAAQU,KAAA,o1EAAAT,GAAA,yGAAAC,aAA2+EE,KAAA,2BAAAC,KAAA,+BAAAF,MAAA,YAAAI,QAAA,iKAAAD,MAAA,gCAA+SN,MAAQU,KAAA,+1GAAyhGT,GAAA,wHAAAC,aAA6dE,KAAA,2BAAAC,KAAA;AAAAF,MAAA,2CAAAI,QAAA,+CAAAD,MAAA,sBAAuNN,MAAQU,KAAA,2vCAAiiCT,GAAA,4GAAAC,aAAmWE,KAAA,2BAAAC,KAAA,yCAAAF,MAAA,eAAAI,QAAA,2FAAAD,MAAA,2DAAiRN,MAAQU,KAAA,q1jBAA29gBT,GAAA,oGAAAC,aAA4gDE,KAAA,2BAAAC,KAAA,kCAAAF,MAAA,mCAAAI,QAAA,oCAAAD,MAAA,iDAA2NK,WAAA,IAAAC,OAAA,EAAAC,MAAA,EAAAC,MAAA,EAAAC,UAAA,KDS/wnDC,IACA,SAAUtB,EAAQC,GEVxBD,EAAAC,SAAkBsB","file":"path----9c375f333f4f13b5533c.js","sourcesContent":["webpackJsonp([60335399758886],{\n\n/***/ 364:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"allMarkdownRemark\":{\"totalCount\":20,\"edges\":[{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/为你的Gatsby博客添加评论功能.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"为你的Gatsby博客添加评论功能\",\"date\":\"March 12, 2018\",\"path\":\"/2018/enable-comments-for-gatsby-blog\",\"tags\":[\"blog\"],\"excerpt\":\"Gatsby打造的博客已经很不错了，但是缺少一个评论功能。本文简单介绍如何集成Disqus评论服务到你的博客站点。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/转用Gatsby搭建博客.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"转用Gatsby打造基于github的博客站点\",\"date\":\"March 08, 2018\",\"path\":\"/2018/blog-with-gatsby\",\"tags\":[\"blog\",\"github\",\"gatsby\"],\"excerpt\":\"如何用Gatsby打造一个博客\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/一则奇怪的Toubleshooting.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"记一次奇怪的troubleshooting\",\"date\":\"March 08, 2018\",\"path\":\"/2018/skipper-sni-domain-fronting\",\"tags\":[\"skipper\",\"SNI\",\"domain fronting\"],\"excerpt\":\"在Skipper转发请求到一个https站点的时候，返回莫名404.\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2016/JSON解析利器JQ.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"JSON解析利器---JQ\",\"date\":\"March 25, 2016\",\"path\":\"/2013/jq\",\"tags\":[\"bash\",\"jq\",\"json\"],\"excerpt\":\"在API first的时代，json作为最常用的格式，充斥着程序猿的屏幕各个角落，掌握一门解析、过滤、转换json输出的工具，已经成为程序猿们安身立命的必要技能。 这里隆重向大家介绍[jq](https://stedolan.github.io/jq/).\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2016/Function的协变.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Function的协、逆变\",\"date\":\"February 04, 2016\",\"path\":\"/2016/function-covariant-contravariant\",\"tags\":[\"scala\",\"functional programming\"],\"excerpt\":\"泛型编程的时候，协变(covariant)还是逆变(contravariant)很重要，在设计上层API接口的时候，正确的使用协变、逆变可以更好地约束程序员的行为，让实现变得安全、一致。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/如何在Scala中实现AOP.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"用Mixin组合实现Scala中的AOP\",\"date\":\"August 13, 2015\",\"path\":\"/2015/aop-by-mixin-in-scala\",\"tags\":[\"scala\",\"functional programming\",\"AOP\",\"mixin\"],\"excerpt\":\"在Java世界，AOP（Aspect Oriented Programming， 面向方面编程)是很多框架的基础。这种将关注点按照“方面”来切分的编程模型极大地简化了编程的复杂度，尤其是在多维度因子交织在一起的时候的各种场景。对于代码的可读性、可维护性、可重用性都是极大的帮助。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Scala雾里看花.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Scala雾里看花\",\"date\":\"April 23, 2015\",\"path\":\"/2015/scala-trouble-shooting\",\"tags\":[\"scala\",\"trouble shooting\"],\"excerpt\":\"Scala的学习过程中，经常会碰到一些莫名其妙的现象，很多时候，这些语言层面的“怪象”都与scala编译器或者scala的类型系统有关。本文不是对编译器和类型系统的介绍，而是重点介绍遇到这些现象的时候，用什么样的方式，拨开云雾见蓝天，通过这些工具获取一些细节帮你了解编译器和类型系统如何工作。工欲善其事，必先利其器。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Docker创建MySQL主从复制以及CDC测试.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"MySQL Master/Slave Replication on Docker\",\"date\":\"April 21, 2015\",\"path\":\"/2015/mysql-replication-on-docker\",\"tags\":[\"docker\",\"mysql\"],\"excerpt\":\"How to setup Mysql master/slave replication.\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2014/Scala函数式异常处理.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Scala函数式异常处理\",\"date\":\"May 04, 2014\",\"path\":\"/2014/scala-error-handling-in-fp-style\",\"tags\":[\"scala\",\"functional programming\",\"exception handling\"],\"excerpt\":\"经常看到很多示例代码，简洁的让人爱不释手，可是真正自己实现的时候，不得不添加各种各样的异常处理逻辑，最后发现代码总量的80%都是再做异常处理，而真正的代码逻辑只有很少的一部分。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2014/高种泛型.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"高种泛型 (Generics of a Higher Kind)\",\"date\":\"January 08, 2014\",\"path\":\"/2014/generics-of-a-higher-kind\",\"tags\":[\"scala\",\"functional programming\",\"Generics\"],\"excerpt\":\"Generics of a Higher Kind翻译加自我理解。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/map-flatMap-for.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"map/flatMap/for in Action\",\"date\":\"December 01, 2013\",\"path\":\"/2013/map-flatmap-for\",\"tags\":[\"scala\",\"functional programming\"],\"excerpt\":\"前文说过了，高阶函数式函数式语言中的基石，而`map`, `flatMap`更是重要。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/fold编程.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"折纸的艺术：fold编程\",\"date\":\"November 27, 2013\",\"path\":\"/2013/fold\",\"tags\":[\"scala\",\"functional programming\",\"fold\"],\"excerpt\":\"Eric Meijer说：递归是函数式编程的GOTO，应该尽可能避免。如何避免，OO中我们用while循环，FP中我们用`fold`。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Monad.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Monad\",\"date\":\"November 26, 2013\",\"path\":\"/2013/monad\",\"tags\":[\"scala\",\"functional programming\",\"monad\"],\"excerpt\":\"函数式语言与OO（确切地讲是指令式编程）的思维方式是完全不同的，很多OO中的经验在函数式语言中不是很匹配，比如设计模式，那就是一个OO中的特定术语，而在FP中，大家常谈的是对于习惯OO思维的程序员来说玄而又玄的Monad。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/高阶函数.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"高阶函数\",\"date\":\"November 21, 2013\",\"path\":\"/2013/high-order-function\",\"tags\":[\"scala\",\"functional programming\",\"high order function\"],\"excerpt\":\"所谓高阶函数（high order function），其实就是可以接受其他函数作为参数的函数。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Actor协调并发场景下的集合操作.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"边建边学-3：Actor协调并发场景下的集合操作\",\"date\":\"November 17, 2013\",\"path\":\"/2013/actor-collection-collabration\",\"tags\":[\"scala\",\"functional programming\"],\"excerpt\":\"很多时候为了提高性能，减少IO操作，都会将数据load出来之后缓存在内存中。本站的实现过程中也遇到类似的问题，不希望每次有人访问的时候就读取一次md文件，或者从MongoDB中查一次，而是直接在内存中读取。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Enumerator-Iteratee-Enumeratee.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Enumerator / Iteratee / Enumeratee\",\"date\":\"November 11, 2013\",\"path\":\"/2013/enumerator-iteratee-enumeratee\",\"tags\":[\"scala\",\"playframework\",\"blog\"],\"excerpt\":\"Stream对于指令式编程已经比较成熟了，有大量的类库，丰富的API。但是对于强调不可变量，尽可能无副作用的FP来说，要考虑语言适配的问题，而目前，流行的解决方案就是：Enumerator/Iteratee。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/集成PlantUML和Markdown.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"边建边学-2：集成PlantUML和Markdown\",\"date\":\"November 07, 2013\",\"path\":\"/2013/markdown-plantuml-integration\",\"tags\":[\"markdown\",\"plantuml\",\"blog\"],\"excerpt\":\"如何用Markdown+PlantUML结合来写图文并茂的博客。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/EssentialAction-in-Playframework.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"EssentialAction in Playframework\",\"date\":\"November 05, 2013\",\"path\":\"/2013/essential-action-in-play\",\"tags\":[\"scala\",\"playframework\"],\"excerpt\":\"Playframework中EssentialAction理解\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/用markdown写博客.markdown absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"边建边学-1: 用Markdown写博文\",\"date\":\"November 01, 2013\",\"path\":\"/2013/blogging-with-markdown\",\"tags\":[\"markdown\",\"blog\"],\"excerpt\":\"本文将是一个系列文章，循序渐进地介绍本站的构建过程，不只是简单的技术介绍，重点是建站过程遇到的问题分析，以及解决的过程，所以起名**“边建边学”**系列。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/开篇.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"开篇\",\"date\":\"October 25, 2013\",\"path\":\"/2013/start\",\"tags\":[],\"excerpt\":\"网络博客\"}}}]}},\"pathContext\":{\"group\":[{\"node\":{\"html\":\"<p>Gatsby打造的博客已经很不错了，但是缺少一个评论功能。</p>\\n<p>本文简单介绍如何集成Disqus评论服务到你的博客站点。</p>\\n<h2>How To</h2>\\n<p>首先，添加<code>react-disqus-thread</code>组件。</p>\\n<pre><code>yarn add react-disqus-thread\\n</code></pre>\\n<p>之后，新建一个<code>Comments</code>的React组件。</p>\\n<!-- language: lang-js -->\\n<pre><code>const React = require('react');\\nconst ReactDisqusThread = require('react-disqus-thread');\\n\\nclass Comments extends React.Component{\\n\\n    constructor(props) {\\n        super(props);\\n    }\\n    \\n    handleNewComment (comment) {\\n        \\n    }\\n\\n    render () {\\n        const id = `smilingleo/${window.location.pathname}`;\\n        return (\\n            &#x3C;ReactDisqusThread\\n                shortname=\\\"smilingleo\\\"\\n                identifier={id}\\n                title={this.props.title}\\n                onNewComment={this.handleNewComment}/>\\n        );\\n    }\\n};\\n\\nexport default Comments;\\n</code></pre>\\n<p>注意:</p>\\n<ul>\\n<li><code>identifier</code>需要是唯一的，这里我用了<code>smilingleo</code>作为前缀，加上<code>pathname</code>。</li>\\n<li><code>onNewComment</code>的响应函数中，可以做一些有意思的东西，比如给你的IM发一条消息，尝试了Slack Webhook，可惜不支持CORS.</li>\\n</ul>\\n<p>最后，在<code>templates/blog-post.js</code>文件中添加：</p>\\n<!-- language: lang-html -->\\n<pre><code>&#x3C;hr />\\n&#x3C;Comments title={title} />\\n</code></pre>\\n<p>搞定.</p>\\n<h2>References</h2>\\n<ol>\\n<li><a href=\\\"https://github.com/mzabriskie/react-disqus-thread\\\">React Disqus thread component</a></li>\\n</ol>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/为你的Gatsby博客添加评论功能.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2018-03-12T10:07:43.000+08:00\",\"path\":\"/2018/enable-comments-for-gatsby-blog\",\"title\":\"为你的Gatsby博客添加评论功能\",\"excerpt\":\"Gatsby打造的博客已经很不错了，但是缺少一个评论功能。本文简单介绍如何集成Disqus评论服务到你的博客站点。\",\"tags\":[\"blog\"]}}},{\"node\":{\"html\":\"<h2>起因</h2>\\n<p>原来的博客站点基于Jekyll搭建，各种问题，感觉很不爽。后来看到Gatsby，基于ReactJS, GraphQL，都是我的最爱，于是果断投诚！</p>\\n<h2>遇到的问题</h2>\\n<h3>和prettyprint集成的问题</h3>\\n<p>原来的prettyprint机制是在页面加载的时候调用<code>init()</code>，检查DOM中的<code>pre.code</code>元素。但是转到React之后，全部是前端Routing，原来写的<code>window.onload = init</code>不工作了。每次都要手动刷新。</p>\\n<p>解决办法是在Gatsby Link元素的<code>onClick</code>事件中注册一个timer:</p>\\n<!-- language: js -->\\n<pre><code>&#x3C;Link to={frontmatter.path} onClick={() => setTimeout(init, 100)}>{frontmatter.title}&#x3C;/Link>\\n</code></pre>\\n<p>这样，在点击链接打开页面之后，就会调用<code>init</code>了。</p>\\n<p><strong>更新：</strong>\\n上面的方法更像是一个Hack，因为毕竟Link的目的只是指向一个target，不应该把不属于Link的职责(解析页面DOM并设置pre.code的style)绑定到Link上。</p>\\n<p>重新思考了一下之后，重构了<code>templates/blog-post.js</code>，原来的<code>Template</code>是一个ES6箭头函数，因为我们希望的是在页面组件都Mount之后，调用<code>init</code>，所以，我们将其修改为一个扩展<code>React.Component</code>的class.</p>\\n<!-- language:lang-js -->\\n<pre><code>class Template extends React.Component {\\n    constructor(props) {\\n        super(props);\\n    }\\n    \\n    /*\\n    * Once the blog page is loaded, run init() to prettyprint the code.\\n    */\\n    componentDidMount() {\\n        init();\\n    }\\n\\n    render() {\\n        const { markdownRemark: post } = this.props.data\\n        const { frontmatter, html } = post\\n        const { title, date } = frontmatter\\n        const { next, prev } = this.props.pathContext\\n    \\n        return (\\n            ...\\n        )  \\n    }\\n}\\n</code></pre>\\n<p>这样，就达到目的了。</p>\\n<h3>发布方法</h3>\\n<p>原来以为是将这些源码直接push到 <code>smilingleo.github.io</code>，后来发现不对。</p>\\n<p>需要有两个github repos，一个 <code>my-blog-code</code>, 另外一个 <code>smilingleo.github.io</code>。</p>\\n<p>新的博文写完之后，需要<code>yarn deploy</code>，这样会发布到<code>public/</code>，然后将<code>public</code>目录指向<code>smilingleo.github.io</code>这个repo。</p>\\n<p>所以，一篇博客需要提交两个git repos。</p>\\n<h3>date格式问题</h3>\\n<p>原来用Jekyll的时候，date可以是<code>YYYY-MM-dd HH:mm:ss</code>的格式，但是用Gatsby必须是<code>YYYY-MM-dd'T'HH:mm:ss</code>。</p>\\n<h2>参考资料</h2>\\n<ol>\\n<li><a href=\\\"https://egghead.io/courses/build-a-blog-with-react-and-markdown-using-gatsby\\\">Egghead教程</a></li>\\n<li><a href=\\\"https://stackoverflow.com/questions/37170809/react-createclass-vs-es6-arrow-function/37170998#37170998\\\">React.createClass vs. ES6 arrow function</a></li>\\n</ol>\\n<p>In summary:</p>\\n<p>The short answer is that you want to use Stateless Functional Components (SFC) as often as you can; the majority of your components should be SFC's.</p>\\n<p>Use the traditional Component class when:</p>\\n<p>You need local state (<code>this.setState</code>)\\nYou need a lifecycle hook (<code>componentWillMount</code>, <code>componentDidUpdate</code>, etc)\\nYou need to access backing instances via refs (eg. <code>&#x3C;div ref={elem => this.elem = elem}></code>)</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/转用Gatsby搭建博客.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2018-03-08T17:00:00.000+08\",\"path\":\"/2018/blog-with-gatsby\",\"title\":\"转用Gatsby打造基于github的博客站点\",\"excerpt\":\"如何用Gatsby打造一个博客\",\"tags\":[\"blog\",\"github\",\"gatsby\"]}}},{\"node\":{\"html\":\"<h2>问题描述</h2>\\n<p>因为我们的项目中用到了<a href=\\\"http://github.com/zalando/skipper\\\">Skipper</a>作为UI层的gateway，在支持一个新上线的UI应用的时候，发现一个奇怪的现象，假定：</p>\\n<pre><code>Skipper Domain: https://ui.example.com\\nWebapp Internal Domain：https://webapp.internal.example.com\\n</code></pre>\\n<p>在Skipper收到一个请求 <code>GET https://ui.example.com/webapp</code>的时候，根据Routing规则：</p>\\n<pre><code>Path(\\\"/webapp\\\") -> \\\"https://webapp.internal.example.com\\\"\\n</code></pre>\\n<p>请求应该是会被转到这个地址的。测试发现：</p>\\n<!-- language: lang-bash -->\\n<pre><code># 正常工作，返回200\\ncurl -i https://webapp.internal.example.com\\n\\n# 返回404\\ncurl -i https://ui.example.com\\n</code></pre>\\n<p>神奇的就是后面的测试，返回404，而且来源于一个<code>nginx</code>服务器。</p>\\n<h2>调试</h2>\\n<p>通过 <code>curl -vv</code> 比较两个请求的差异，发现两个服务器的证书CN不同，一个是 <code>*.example.com</code>，另外一个是 <code>*.internal.example.com</code>，怀疑是不是SNI相关的问题，尝试了一下：</p>\\n<pre><code class=\\\"language-bash\\\">curl -i -H \\\"Host: webapp.internal.example.com\\\" https://ui.example.com\\n</code></pre>\\n<p>哈，成功返回200.</p>\\n<p>查阅了一下SNI相关资料，发现了疑惑：SNI中hello_name来源于 URL中的domain name，而不是被加密的Header。一个web server如果host多个domains，在request过来的时候，会根据URI中的domain name来查找对应domain的证书，然后用来SSL握手，如果找不到证书，才会返回一个默认的页面，比如404.</p>\\n<p>但是根据我们的试验，证书应该是正确的，所以应该不是SNI的问题。</p>\\n<h2>真相大白</h2>\\n<p>问题是解决了，但是却不知道是什么原因，这让人很不舒服，继续找。无意中发现了这个<a href=\\\"https://github.com/golang/go/issues/22704\\\">Issue</a>，其中提到：</p>\\n<blockquote>\\n<p>This would break usage of net/http for <a href=\\\"https://www.bamsoftware.com/papers/fronting/\\\">domain fronting</a>, an anti-censorship technique specifically relying on sending different hosts in SNI and HTTP headers. Such a use of net/http is not rare: censorship-resistant tunneling software such as <a href=\\\"https://github.com/getlantern/lantern\\\">Lantern</a> and my own project Geph both use net/http this way.</p>\\n</blockquote>\\n<p><code>domain fronting</code>？什么鬼，著名的<code>lantern</code>居然在用，查了一下，明白了。原来这个技术就是用来翻墙的，哈。</p>\\n<p>具体来说：</p>\\n<p><img src=\\\"https://www.bamsoftware.com/papers/fronting/fronting.svg\\\" alt=\\\"domain fronting\\\"></p>\\n<p>比如你想访问被墙的网站<code>forbidden.example</code>,你可以用36计之张冠李戴，谎称我访问的是<code>allowed.example</code>, 然后在request header中指定<code>Host: forbidden.example</code>，用https，这样请求就会被加密，邪恶的探测器们就无法知道你真正的地址，而且这样也符合SNI的握手协议。</p>\\n<p>现在很多网站都支持这种技术，比如google:</p>\\n<pre><code class=\\\"language-bash\\\">curl -vv -H \\\"Host: maps.google.com\\\" https://www.google.com\\n</code></pre>\\n<p>从URL上看，访问的是<code>www.google.com</code>，但是你看一下返回内容会发现，这个内容却是<code>maps.google.com</code>返回的。</p>\\n<p>在我们的例子中，因为skipper中设置了<code>-proxy-preserve-host</code>，这样<code>Host</code> header会被传递给下面的目标app，而这个目标app因为支持domain fronting，尝试着去找那个 <code>ui.example.com</code>对应的证书，当然没有，所以返回<code>404</code>.</p>\\n<h2>参考资料</h2>\\n<ol>\\n<li><a href=\\\"https://www.bamsoftware.com/papers/fronting/\\\">Domain Fronting</a></li>\\n<li><a href=\\\"https://en.wikipedia.org/wiki/Server_Name_Indication\\\">Server Name Indication</a></li>\\n</ol>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/一则奇怪的Toubleshooting.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2018-03-08T08:30:00.000+08\",\"path\":\"/2018/skipper-sni-domain-fronting\",\"title\":\"记一次奇怪的troubleshooting\",\"excerpt\":\"在Skipper转发请求到一个https站点的时候，返回莫名404.\",\"tags\":[\"skipper\",\"SNI\",\"domain fronting\"]}}},{\"node\":{\"html\":\"<p>在API first的时代，json作为最常用的格式，充斥着程序猿的屏幕各个角落，掌握一门解析、过滤、转换json输出的工具，已经成为程序猿们安身立命的必要技能。\\n这里隆重向大家介绍<a href=\\\"https://stedolan.github.io/jq/\\\">jq</a>.</p>\\n<h2>常用命令</h2>\\n<h3>pipe: |</h3>\\n<p>和unix管道一样。</p>\\n<h3>.[]</h3>\\n<p>用来将数组中内容传递给后面命令，而不是把整个数组传过去（脱包）\\n还可以用<code>.[n]</code>来获取数组中第n个元素。</p>\\n<h3>has(key)</h3>\\n<p>检查json对象中是否有key属性。一般结合<code>select()</code>使用。</p>\\n<h3>select(boolean_expr)</h3>\\n<p>用来过滤输入。比如，只输出具有<code>name</code>项的json对象，可以用：<code>jq 'has(\\\"name\\\") as $hasName | select($hasName=true)'</code></p>\\n<h2>实战</h2>\\n<p>我们将使用<code>docker inspect</code>输出结果作为例子进行解析。</p>\\n<h3>列出所有docker images的inspect结果</h3>\\n<!-- language:bash -->\\n<pre><code>docker inspect $(docker images | tail -n +2 | awk '{print $1\\\":\\\"$2}')\\n</code></pre>\\n<h3>只列出所有volumes不为空的images</h3>\\n<!-- language:bash -->\\n<pre><code>docker inspect $(docker images | tail -n +2 | awk '{print $1\\\":\\\"$2}') | jq '.[] | select(.Config.Volumes!=null)'\\n</code></pre>\\n<h3>将json转换为csv</h3>\\n<!-- language:bash -->\\n<pre><code>docker inspect $(docker images | tail -n +2 | awk '{print $1\\\":\\\"$2}') | jq '.[] | [(.RepoTags|.[0]), .DockerVersion] | @csv'\\n</code></pre>\\n<p>上面例子中：</p>\\n<ul>\\n<li><code>.[]</code>将数组中每个单项传递给后面命令</li>\\n<li><code>(.RepoTags|.[0])</code>取出第一个RepoTags的内容也就是image的name:tag</li>\\n<li><code>.DockerVersion</code>取出docker版本</li>\\n<li><code>将上面两个命令用</code>,`连接，表示将前面的输入同时传递给这两个命令</li>\\n<li>用<code>[]</code>将上面两个命令包起来，表示将两个命令的输出结果作为数组中的一个item</li>\\n<li><code>@csv</code>将前面的数组输出转换为csv格式。</li>\\n</ul>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2016/JSON解析利器JQ.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2016-03-25T19:16:45.000Z\",\"path\":\"/2013/jq\",\"title\":\"JSON解析利器---JQ\",\"excerpt\":\"在API first的时代，json作为最常用的格式，充斥着程序猿的屏幕各个角落，掌握一门解析、过滤、转换json输出的工具，已经成为程序猿们安身立命的必要技能。 这里隆重向大家介绍[jq](https://stedolan.github.io/jq/).\",\"tags\":[\"bash\",\"jq\",\"json\"]}}},{\"node\":{\"html\":\"<p>泛型编程的时候，协变(covariant)还是逆变(contravariant)很重要，在设计上层API接口的时候，正确的使用协变、逆变可以更好地约束程序员的行为，让实现变得安全、一致。</p>\\n<p>协变、逆变在一般时候是比较容易理解的，但是来到FP世界之后，Function的协变、逆变就变得比较复杂。</p>\\n<p>比如： 对于<code>trait List[+T]</code></p>\\n<!-- language:uml -->\\n<pre><code>class Animal\\nclass Dog\\nclass \\\"List[Animal]\\\" as LA\\nclass \\\"List[Dog]\\\" as LD\\n\\nAnimal &#x3C;|-- Dog\\nLA &#x3C;|-- LD\\n</code></pre>\\n<p>那对于<code>trait CList[-T]</code></p>\\n<!-- language:uml -->\\n<pre><code>class Animal\\nclass Dog\\nclass \\\"CList[Animal]\\\" as LA\\nclass \\\"CList[Dog]\\\" as LD\\n\\nAnimal &#x3C;|-- Dog\\nLA --|> LD\\n</code></pre>\\n<p>这些还都容易理解，对于<code>trait Func[-I, +O]</code>的理解就比较费劲了。</p>\\n<!-- language:lang-scala -->\\n<pre><code>import scala.reflect.runtime.universe._\\n\\nclass Animal\\ncase class Dog(name: String) extends Animal\\n\\nclass Material\\ncase class Wood(color: String) extends Material\\n\\ntrait Func[-I, +O] {\\n  def apply(input: I): O\\n}\\n\\ntypeOf[Dog] &#x3C;:&#x3C; typeOf[Animal]  // return true\\ntypeOf[Func[Material, Dog]] &#x3C;:&#x3C; typeOf[Func[Wood, Animal]]    // retrun true\\n</code></pre>\\n<!-- language:uml -->\\n<pre><code>class Animal\\nclass Dog\\nclass Wood\\nclass Material\\n\\nclass \\\"Func[Wood, Animal]\\\" as LA\\nclass \\\"Func[Material, Dog]\\\" as LD\\n\\n\\nWood --|> Material\\nLA &#x3C;|-- LD\\nAnimal &#x3C;|-- Dog\\n</code></pre>\\n<p>理解这个的关键是理解“里氏替换原则”，也就是，任何父类出现的地方，如果用其子类来替换都应该是安全的。从这个角度看，这个<code>Func</code>完成的工作是用某种材料来制作某种动物，<code>Func[Wood, Animal]</code>是输入木头制作任何动物，<code>Func[Material, Dog]</code>是输入任何材料来制作狗。考虑下面的应用场景：</p>\\n<!-- language:lang-scala -->\\n<pre><code>val woods: List[Wood] = ...         //给定一堆木头\\n\\nval makeAnimalWithWood: Func[Wood, Animal] = ...\\nval makeDogWithMaterial: Func[Material, Dog] = ...\\n\\nval describer: Animal -> String = ...\\n\\nwoods.map(makeAnimalWithWood)       // return List[Animal]\\n     .map(describer)                // 接受Animal返回String\\n</code></pre>\\n<p>根据里氏替换原则，用<code>makeDogWithMaterial</code>替换<code>makeAnimalWithWood</code>是安全的。反过来，看下面代码：</p>\\n<!-- language:lang-scala -->\\n<pre><code>val materials: List[Material] = ...           // 给定一堆材料\\n\\nval makeAnimalWithWood: Func[Wood, Animal] = ...\\nval makeDogWithMaterial: Func[Material, Dog] = ...\\n\\nval describer: Dog -> String = ...\\n\\nmaterials.map(makeDogWithMaterial)       // return List[Dog]\\n     .map(describer)                // 接受Dog返回String\\n</code></pre>\\n<p>这时候，用<code>makeAnimalWithWood</code>来替换<code>makeDogWithMaterial</code>就不行了，因为<code>materials.map(makeAnimalWithWood)</code>就会编译错误了，因为<code>makeAnimalWithWood</code>只接受<code>Wood</code>，而代码传递过来的是<code>Material</code>.</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2016/Function的协变.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2016-02-04T17:16:45.000Z\",\"path\":\"/2016/function-covariant-contravariant\",\"title\":\"Function的协、逆变\",\"excerpt\":\"泛型编程的时候，协变(covariant)还是逆变(contravariant)很重要，在设计上层API接口的时候，正确的使用协变、逆变可以更好地约束程序员的行为，让实现变得安全、一致。\",\"tags\":[\"scala\",\"functional programming\"]}}},{\"node\":{\"html\":\"<h2>Java中的AOP</h2>\\n<p>在Java世界，AOP（Aspect Oriented Programming， 面向方面编程)是很多框架的基础。这种将关注点按照“方面”来切分的编程模型极大地简化了编程的复杂度，尤其是在多维度因子交织在一起的时候的各种场景。对于代码的可读性、可维护性、可重用性都是极大的帮助。</p>\\n<p>不过AOP一个令人诟病的地方是其透明性，也就是说对于开发人员来说，我不知道我的某个方法会不会被某个Aspect切面一刀，有些时候，会造成一些意想不到的后果，比如Spring的transaction管理，如果通过aop的方式来定义，比如：</p>\\n<!-- language: xml -->\\n<pre><code>&#x3C;tx:advice id=\\\"txCommonAdvice\\\" transaction-manager=\\\"transactionManager\\\">\\n    &#x3C;tx:attributes>\\n        &#x3C;tx:method name=\\\"save*\\\" propagation=\\\"REQUIRED\\\"/>\\n        &#x3C;tx:method name=\\\"remove*\\\" propagation=\\\"REQUIRED\\\"/>\\n        &#x3C;tx:method name=\\\"update*\\\" propagation=\\\"REQUIRED\\\"/>\\n        &#x3C;tx:method name=\\\"delete*\\\" propagation=\\\"REQUIRED\\\"/>\\n        &#x3C;tx:method name=\\\"*\\\" propagation=\\\"REQUIRED\\\" read-only=\\\"true\\\"/>\\n    &#x3C;/tx:attributes>\\n&#x3C;/tx:advice>\\n</code></pre>\\n<p>那么被这个切面拦截的任何方法都会导致Spring Transaction Manager启动一个事务，甚至是像<code>toString()</code>, <code>equal(other)</code>等这样的方法，而且因为其透明性，开发人员往往意识不到这个问题。</p>\\n<h2>Scala中的AOP</h2>\\n<p>在Scala的世界里，AOP的思想其实也是适用的，当然，因为Scala就运行在jvm上面，很多code weaver工具也照样是可以用的，比如aspectj, asm等等，个人不是很喜欢这些东西，更喜欢用显式的方式来告诉我的代码读者，我的代码会做哪些事情。No Magic，是我的一个信条。</p>\\n<p>Scala的Mixin机制trait，可以很好地实现显式的AOP，举个例子：</p>\\n<!-- language: scala run -->\\n<pre><code>trait Task { def execute }\\ntrait TaskLogging extends Task {\\n    abstract override def execute = {\\n        println(\\\"before execute\\\")\\n        super.execute\\n        println(\\\"after execute\\\")\\n    }\\n}\\nclass MyTask extends Task {\\n    override def execute = {\\n        println(\\\"do something\\\")\\n    }\\n}\\n\\nval task = new MyTask\\ntask.execute    // 输出 'do something'，没什么稀奇的\\n\\nval task2 = new MyTask with TaskLogging\\ntask2.execute   // 点击'run'看看会输出什么？\\n</code></pre>\\n<p>在上面代码中，<code>MyTask</code>和<code>TaskLogging</code>都是只关注于自己的逻辑（Aspect），在运行时，可以构建一个<code>MyTask with TaskLogging</code>的<code>task2</code>instance，就可以将两个方面组合在一起了。当然你还可以增加新的方面，比如：</p>\\n<!-- language: scala -->\\n<pre><code>trait Transactional extends Task {\\n    abstract override def execute = {\\n        println(\\\"begin transaction\\\")\\n        try {\\n            super.execute\\n            println(\\\"commit transaction\\\")\\n        } catch {\\n            case _: Exception =>\\n                println(\\\"rollback transaction\\\")\\n        }\\n    }\\n}\\n\\nval task3 = new MyTask with TaskLogging with Transactional\\ntask3.execute\\n</code></pre>\\n<p>这样，就可以构建一个有事务，有logging的task。</p>\\n<p>总结一下，定义一个Aspect的步骤：</p>\\n<ol>\\n<li>重载trait中的方法</li>\\n<li>方法前逻辑，比如logging、begin transaction等等</li>\\n<li>调用<code>super</code>对象的方法</li>\\n<li>方法后逻辑，比如logging、commit transaction等</li>\\n</ol>\\n<p>这里，主要的知识点是调用<code>super.execute</code>的执行顺序，在用<code>with Trait</code>定义一个新类型的时候，多个Trait会形成一个Stack，执行的时候会按照出栈顺序执行，比如：</p>\\n<!-- language: scala -->\\n<pre><code>val task = new MyTask with TaskLogging with Transactional\\ntask.execute\\n</code></pre>\\n<p>TaskLogging先入栈，Transactional后入，那么执行的时候，先执行Transactional，后执行TaskLogging，就会输出：</p>\\n<!-- language -->\\n<pre><code>begin transaction\\nbefore execute\\ndo something\\nafter execute\\ncommit transaction\\n</code></pre>\\n<p>换一个顺序：</p>\\n<!-- language: scala -->\\n<pre><code>val task = new MyTask with TaskLogging with Transactional\\ntask.execute\\n</code></pre>\\n<p>那么输出将会是另外一个顺序。    </p>\\n<h3>抽象方法中的super call</h3>\\n<p>注意一个细节，在<code>TaskLogging.execute</code>中，我们调用了<code>super.execute</code>，仔细想想，感觉很奇怪，几个疑点：</p>\\n<ol>\\n<li>TaskLogging的super是谁？</li>\\n<li>为什么<code>MyTask.execute</code>是最后执行的？</li>\\n</ol>\\n<p>查询《Programming in Scala》“traits as stackable modifications“章节后，我们可以了解到：</p>\\n<ol>\\n<li>trait中的super call是动态绑定，是在另外一个trait或者class实现一个具体的方法之后。</li>\\n<li>所以trait中的方法必须标注: <code>abstract override</code>，以此来告诉编译器，你是故意这么来用的。</li>\\n</ol>\\n<p>用scalac编译上述源文件，生成.class文件之后，用<code>jad</code>等工具查看反编译类，会发现其实<code>MyTask with TaskLogging</code>会产生一个匿名类，继承MyTask，实现TaskLogging接口，回头再看TaskLogging中定义的<code>super.execute</code>，就能理解了，原来在调用TaskLogging.execute方法的时候的<code>this</code>，已经是匿名类的实例了，当然其super是合法的。然后其执行顺序也就能理解了。</p>\\n<p>但是这里明显有一个矛盾：从代码执行角度看，生成的匿名类是MyTask和TaskLogging的子类，这点可以通过<code>task.isInstanceOf[MyTask] &#x26;&#x26; task.isInstanceOf[TaskLogging]</code>中判断得出，但是从字面上看，在trait TaskLogging中调用<code>super.execute</code>，又给人感觉莫名其妙。可能这也是scala需要在jvm上运行所做的妥协吧。</p>\\n<h2>Stackable Actor模式</h2>\\n<p>在Akka中，这种Mixin的用法非常的有帮助，比如在对actor进行监控的时候，我们希望能记录每个actor发送消息的路径，每个actor接收消息之后处理所花费的时间、调用次数等等，如果不用这种trait mixin的话，代码将非常凌乱。</p>\\n<p>之所以单独将这个模式提出来，其实还因为这个模式中利用了PartialFunction的特性，让代码更加的优雅。看例子：</p>\\n<!-- language: scala run -->\\n<pre><code>type Receive = PartialFunction[Any, Unit]\\n\\ntrait Actor {\\n    def receive: Receive\\n    def unhandled(msg: Any): Unit = println(s\\\"unhandled message: $msg\\\")\\n}\\n\\ntrait StackableActor extends Actor {\\n    def wrapped: Receive\\n    def receive: Receive = {\\n        case x => if (wrapped.isDefinedAt(x)) wrapped(x) else unhandled(x)\\n    }\\n}\\n\\n trait LoggingActor extends StackableActor { \\n    override def wrapped: Receive = { \\n        case x => \\n            println(s\\\"start processing message: $x\\\")\\n            super.receive(x)\\n            println(\\\"end of processing message:\\\" + x) \\n    }\\n}\\n\\nclass MyActor extends StackableActor with LoggingActor {\\n    override def wrapped: Receive = {\\n        case \\\"something\\\" =>\\n            println(\\\"I can only do 'something'\\\")\\n    }\\n}\\n\\nnew MyActor() receive (\\\"something\\\")\\nnew MyActor() receive (\\\"else\\\")\\n</code></pre>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/如何在Scala中实现AOP.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2015-08-13T10:16:45.000Z\",\"path\":\"/2015/aop-by-mixin-in-scala\",\"title\":\"用Mixin组合实现Scala中的AOP\",\"excerpt\":\"在Java世界，AOP（Aspect Oriented Programming， 面向方面编程)是很多框架的基础。这种将关注点按照“方面”来切分的编程模型极大地简化了编程的复杂度，尤其是在多维度因子交织在一起的时候的各种场景。对于代码的可读性、可维护性、可重用性都是极大的帮助。\",\"tags\":[\"scala\",\"functional programming\",\"AOP\",\"mixin\"]}}},{\"node\":{\"html\":\"<p>Scala的学习过程中，经常会碰到一些莫名其妙的现象，很多时候，这些语言层面的“怪象”都与scala编译器或者scala的类型系统有关。</p>\\n<p>本文不是对编译器和类型系统的介绍，而是重点介绍遇到这些现象的时候，用什么样的方式，拨开云雾见蓝天，通过这些工具获取一些细节帮你了解编译器和类型系统如何工作。工欲善其事，必先利其器。</p>\\n<h2>REPL</h2>\\n<p>Read-Evaluate-Print-Loop, 是一个所有学习scala的同学都要掌握的工具，可以帮你快速测试一些代码，了解一些library怎么使用。</p>\\n<p>在安装scala之后，命令行下执行<code>scala</code>，就会进入REPL.</p>\\n<!-- language: bash -->\\n<pre><code>$ scala\\nWelcome to Scala version 2.11.1 (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_65).\\nType in expressions to have them evaluated.\\nType :help for more information.\\n\\nscala>\\n</code></pre>\\n<p>如果是SBT项目，可以用<code>sbt console</code>进入，之后操作类型，不再重复。</p>\\n<h3>模式</h3>\\n<p>scala REPL有<a href=\\\"http://hongjiang.info/scala-repl-modes/\\\">几种模式</a>，其中比较常用的就是<code>:paste</code>，可以比较方便的输入多行，不过要注意，拷贝粘贴的代码中，不要有Tab，否则会触发auto code completion，出现一堆错误提示。</p>\\n<h3>反射</h3>\\n<h2>命令行参数</h2>\\n<p>通过<code>man scala</code>, <code>man scalac</code>，可以了解scala都有哪些参数可用。注意的是：scala的命令行参数中import了scalac的参数，所以可以在scala命令后面使用任何scalac的参数。其中比较有用的参数有：</p>\\n<ul>\\n<li><code>-X</code>系列，用于输出高级选项概要。也就是正式支持的选项，向后兼容。</li>\\n<li><code>-Y</code>系列。用于输出私有选项信息，可能随版本变化。参见<a href=\\\"http://www.scala-lang.org/old/node/9313\\\">[6]</a><a href=\\\"http://paulbutcher.com/2010/04/26/scala-compiler-advanced-options/\\\">[7]</a></li>\\n</ul>\\n<p><code>scala -X</code>，<code>scala -Y</code>可以分别列出当前版本所支持的所有选项。</p>\\n<h2>参考</h2>\\n<ol>\\n<li><a href=\\\"http://stackoverflow.com/questions/11055210/whats-the-easiest-way-to-use-reify-get-an-ast-of-an-expression-in-scala\\\">What's the easiest way to use reify (get an AST of) an expression in Scala? stackoverflow</a></li>\\n<li><a href=\\\"http://stackoverflow.com/questions/11392622/how-to-investigate-objects-types-etc-from-scala-repl\\\">How to investigate objects/types/etc. from Scala REPL? stackoverflow</a></li>\\n<li><a href=\\\"https://www.parleys.com/tutorial/51c38751e4b0d38b54f4625e/chapter0/about\\\">Practical Type Mining in Scala ,  scaladay 2013</a></li>\\n<li><a href=\\\"http://hongjiang.info/scala-repl-modes/\\\">REPL的几种模式, hongjiang</a></li>\\n<li><a href=\\\"http://docs.scala-lang.org/overviews/reflection/symbols-trees-types.html\\\">Symbols, Trees, and Types, scalaDoc</a></li>\\n<li><a href=\\\"http://www.scala-lang.org/old/node/9313\\\">Difference between -Y and -X compiler options, scala user forum</a></li>\\n<li><a href=\\\"http://paulbutcher.com/2010/04/26/scala-compiler-advanced-options/\\\">Scala Compiler Advanced Options</a></li>\\n</ol>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Scala雾里看花.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2015-04-23T19:16:45.000Z\",\"path\":\"/2015/scala-trouble-shooting\",\"title\":\"Scala雾里看花\",\"excerpt\":\"Scala的学习过程中，经常会碰到一些莫名其妙的现象，很多时候，这些语言层面的“怪象”都与scala编译器或者scala的类型系统有关。本文不是对编译器和类型系统的介绍，而是重点介绍遇到这些现象的时候，用什么样的方式，拨开云雾见蓝天，通过这些工具获取一些细节帮你了解编译器和类型系统如何工作。工欲善其事，必先利其器。\",\"tags\":[\"scala\",\"trouble shooting\"]}}},{\"node\":{\"html\":\"<h2>Pull Mysql Docker Image</h2>\\n<!-- language: bash -->\\n<pre><code>docker pull mysql:5.6\\n</code></pre>\\n<h2>Create MySQL Config Files</h2>\\n<p>For Master, create a <code>mysql.cnf</code> file and add the following content:</p>\\n<!-- language: bash -->\\n<pre><code>[mysqld]\\n\\nserver-id = 1\\nlog_bin\\nbinlog_format = ROW\\nbind-address = 0.0.0.0\\n\\nsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES\\n</code></pre>\\n<p>For Slave, create another <code>mysql.cnf</code> and add the following content:</p>\\n<!-- language: bash -->\\n<pre><code>[mysqld]\\n\\nserver-id = 2\\nlog_bin\\nbinlog_format = ROW\\nbind-address = 0.0.0.0\\n\\nsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES\\n</code></pre>\\n<h2>Start Master/Slave MySQL Containers</h2>\\n<p>Start Master:</p>\\n<!-- language: bash -->\\n<pre><code>docker run --name master -v /my/master:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:5.6\\n</code></pre>\\n<p>Start Slave:</p>\\n<!-- language: bash -->\\n<pre><code>docker run --name slave -v /my/slave:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw --link master:master -d mysql:5.6\\n</code></pre>\\n<p>The slave node needs to link to master node.</p>\\n<h2>Setup Replication</h2>\\n<p>Check the master status:</p>\\n<!-- language: bash -->\\n<pre><code>mysql> show master status \\\\G\\n*************************** 1. row ***************************\\n             File: mysql-bin.000003\\n         Position: 120\\n     Binlog_Do_DB: \\n Binlog_Ignore_DB: \\nExecuted_Gtid_Set: \\n1 row in set (0.00 sec)\\n</code></pre>\\n<p>the above information is necessary for the slave configuration, especially the <code>File</code> and <code>Position</code>.</p>\\n<p>Connect to Slave node, in Mysql Shell:</p>\\n<!-- language: bash -->\\n<pre><code>mysql> change master to master_host='master',master_user='root',master_password='my-secret-pw',master_log_file='mysql-bin.000003',master_log_pos=120;  \\nQuery OK, 0 rows affected (0.00 sec)  \\n\\nmysql> start slave;\\nQuery OK, 0 rows affected (0.01 sec)\\n\\nmysql> show slave status\\\\G\\n\\n// until you see the following two options are 'Yes'\\nSlave_IO_Running: Yes  \\nSlave_SQL_Running: Yes  \\n</code></pre>\\n<p>You need to change the parameters like <code>master_log_file</code> and <code>master_log_pos</code> based on previous <code>show master status</code> output.</p>\\n<h2>Test</h2>\\n<p>Create some tables and insert some data on master, and check if those data are synced to slave. </p>\\n<h2>Change Data Capture (CDC)</h2>\\n<p>Here I used an open source library <a href=\\\"https://github.com/whitesock/open-replicator\\\">open-replicator</a></p>\\n<!-- language: scala -->\\n<pre><code>import com.google.code.or._\\nimport com.google.code.or.binlog._\\nimport com.google.code.or.binlog.impl.event.FormatDescriptionEvent\\n\\nval or = new OpenReplicator()\\nor.setUser(\\\"root\\\")\\nor.setPassword(\\\"my-secret-pw\\\")\\nor.setServerId(2);\\nor.setHost(\\\"slave\\\")\\nor.setPort(3306)\\nor.setBinlogPosition(120)\\nor.setBinlogFileName(\\\"mysql-bin.000004\\\")\\n\\nor.setBinlogEventListener(new BinlogEventListener() {\\n  def onEvents(event: BinlogEventV4) = {\\n\\n  }\\n})\\n\\nor.start()\\n</code></pre>\\n<p>TBD.\\nSee <code>com.linkedin.databus2.producers.ORListener</code></p>\\n<h2>References</h2>\\n<ol>\\n<li><a href=\\\"https://registry.hub.docker.com/_/mysql/\\\">Mysql Docker Official Repo</a></li>\\n<li><a href=\\\"https://github.com/linkedin/databus/wiki/Databus-for-MySQL\\\">Databus for MySQL</a></li>\\n</ol>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Docker创建MySQL主从复制以及CDC测试.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2015-04-21T07:16:45.000Z\",\"path\":\"/2015/mysql-replication-on-docker\",\"title\":\"MySQL Master/Slave Replication on Docker\",\"excerpt\":\"How to setup Mysql master/slave replication.\",\"tags\":[\"docker\",\"mysql\"]}}},{\"node\":{\"html\":\"<p>经常看到很多示例代码，简洁的让人爱不释手，可是真正自己实现的时候，不得不添加各种各样的异常处理逻辑，最后发现代码总量的80%都是再做异常处理，而真正的代码逻辑只有很少的一部分。</p>\\n<p>异常处理对于指令式和函数式编程都是同样需要的，只是因为实现方式的不同，让函数式编程看上去更加简洁，优雅，不需要像指令式那么繁琐。</p>\\n<p>本文的目的，就是介绍函数式编程中常用的一些异常处理策略。记得把这些瑞士军刀放到你的百宝箱中，以后一定用得上。</p>\\n<h2>空判断Option</h2>\\n<p>如果采访100个程序员，让所有人投票他们在编程时最讨厌做的事情，但又经常犯错误的地方，我估计十有八九会是“空判断”了。</p>\\n<p><code>Null</code>代表着一个对象还没有被初始化，具体点是对象的指针还没有一个确切的地址。在面向对象编程时，因为操作的都是对象，为了避免在一个<code>null</code>上面调用方法，或者 get一个<code>null</code>上的属性，而导致“空值异常”，程序员不得不做下面的事情：</p>\\n<p>假设有下面一个场景：</p>\\n<!-- language:uml -->\\n<pre><code>Selling --> Store\\nSelling --> Product\\n</code></pre>\\n<p>简单说，一个商场内有很多商店(Store)，每个商店卖(Selling)很多种商品(Product)，如果希望找出所有销售玩具的商店：</p>\\n<!-- language:java -->\\n<pre><code>public List&#x3C;Store> findByProductCategory(Category category) {\\n  if (category == null)               &#x3C;1>\\n    return null;\\n  List&#x3C;Product> allProducts = getAllProducts(); // DB lookup\\n  for (Product prod : allProducts) {\\n    if (prod.category == null)        &#x3C;2>\\n      continue; \\n    if (category.equals(prod.category)){\\n    \\n</code></pre>\\n<h2>参考</h2>\\n<ol>\\n<li><a href=\\\"https://tersesystems.com/2012/12/27/error-handling-in-scala/\\\">Error Handling in Scala. https://tersesystems.com/2012/12/27/error-handling-in-scala. 2012</a></li>\\n</ol>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2014/Scala函数式异常处理.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2014-05-04T07:16:45.000Z\",\"path\":\"/2014/scala-error-handling-in-fp-style\",\"title\":\"Scala函数式异常处理\",\"excerpt\":\"经常看到很多示例代码，简洁的让人爱不释手，可是真正自己实现的时候，不得不添加各种各样的异常处理逻辑，最后发现代码总量的80%都是再做异常处理，而真正的代码逻辑只有很少的一部分。\",\"tags\":[\"scala\",\"functional programming\",\"exception handling\"]}}},{\"node\":{\"html\":\"<p>译者按语：很多翻译中将Kind和Type都翻译为“类型”，但实际上两者还是有不同的，本文中，将<code>Kind</code>翻译为“种类”，取王侯将相宁有种乎之意，是骨子里的东西。而将<code>type</code>译为“类型”。</p>\\n<p>学习函数式语言如果想真正入门，一个不可避免的话题就是monad/monoid，而这些范畴论中的词汇都异常抽象，难于理解，尤其是对于从java领域转过来的同学，在很多FP的基础东西不了解情况下来研究monad就更加的困难，比如高种泛型。</p>\\n<p><code>泛型</code> 我们都知道，就是某种类型的泛化（一般化），就是将某些特殊类型进行抽象，抽出一种一般化的类型<code>T</code>。而<code>高种泛型</code>就是在泛型的基础上再进行一次抽象。</p>\\n<ul>\\n<li>\\n<p>First Order Abstraction</p>\\n<p>first-order可以理解为”单次抽象“，将特定类型抽象一次，比如类型：<code>T</code>, <code>T</code>是什么？可以是任何具体类型，String，Integer，Date等等，不难发现，这就是Java中的泛型。</p>\\n</li>\\n<li>\\n<p>Higher Order Abstraction</p>\\n<p>对应first-order的单次抽象，高阶抽象就是再次抽象，也就是说：在某个东东的抽象上再进行抽象，抽象的抽象。晕了吧！</p>\\n</li>\\n</ul>\\n<p>在继续之前，我们还得熟悉几个概念：</p>\\n<ul>\\n<li>\\n<p>值构造器</p>\\n<p>值构造器是一个function / method，接受特定值参数来构造一个特定的值(value)</p>\\n<p>值构造器可以有多态：接受不同类型的参数，也可以是抽象abstract的。</p>\\n</li>\\n<li>\\n<p>类型构造器</p>\\n<p>类型构造器是一个类型，接受一个特定类型参数来构造一个特定的类型。</p>\\n<p>和值构造器一样，类型构造器也可以有多态，这是高阶类型的关键。</p>\\n</li>\\n</ul>\\n<p>先说这么多概念有什么用呢？我们还是先看一个具体的例子。</p>\\n<h2>例子：Iterable</h2>\\n<p>观察下面代码，我们来玩个找不同的游戏：</p>\\n<!-- language:scala -->\\n<pre><code>trait Iterable[T] {\\n  def filter(p: T => Boolean): Iterable[T]\\n  def remove(p: T => Boolean): Iterable[T] = filter(x => !p(x))\\n}\\n\\ntrait List[T] extends Iterable[T] {\\n  def filter(p: T => Boolean): List[T]\\n  override def remove(p: T => Boolean): List[T] = filter(x => !p(x))\\n}\\n</code></pre>\\n<p>看到两段代码有什么不同了吗？什么代码重复了？</p>\\n<p>很容易发现：在<code>List[T]</code>中的两个方法主体结构和<code>Iterable[T]</code>中的几乎完全相同，只是返回类型不同，都期望返回自身类型。如果我们能够将返回类型也复用，那是否就可以完全去除这些重复代码呢？</p>\\n<h3>通过类型构造器多态来去除重复代码</h3>\\n<p>看下面代码：</p>\\n<!-- language:scala -->\\n<pre><code>trait Iterable[T, Container[X]] {\\n  def filter(p: T => Boolean): Container[T]\\n  def remove(p: T => Boolean): Container[T] = filter(x => !p(x))\\n}\\n\\ntrait List[T] extends Iterable[T, List]\\n</code></pre>\\n<p>这是怎么做到的？很简单，引入了<strong>类型构造器多态</strong>的概念。上面例子中：<code>Iterable[T, Container[X]]</code>的<code>Iterable</code>是类型构造器，接受两个类型参数，引入多态概念，同样的类型构造器，让其可以接受不同类型的类型参数<code>List</code>。是不是和普通方法多态没什么区别？</p>\\n<!-- language:java -->\\n<pre><code>public Iterable iterable(T t, Container&#x3C;X> container) { ... }\\npublic Iterable iterable(T t, List list) { ... }\\n</code></pre>\\n<p>因为Java的泛型没有类型构造器多态的概念，所以Java泛型无法解决上述重复代码的问题。最多只能将返回类型设为超类Iterable，然后在调用子类实现时将其强制类型转换为具体子类。</p>\\n<p>有了上面的例子为上下文，我们再来看两个概念：</p>\\n<h3>类型参数、类型成员</h3>\\n<ul>\\n<li>\\n<p>Type Parameter</p>\\n<p>类型参数，比如: <code>List[T]</code>，List具有一个类型参数<code>T</code>。这里的List就是一个类型构造器。List[Int]就是这个类型构造器接受类型参数Int之后构造的具体类型。</p>\\n</li>\\n<li>\\n<p>Type Member</p>\\n<p>类型成员，比如：<code>trait List { type T }</code></p>\\n<p>这里<code>T</code>变成了一个trait的成员（抽象的）。在List子类实现中，指定其具体类型，比如：<code>List { type T = Int }</code>。而这里的类型成员也可能参数化，比如：<code>type Container[T]</code></p>\\n<p>注意：这里的List只用来示意，并不是scala中的List实现。</p>\\n</li>\\n<li>\\n<p>Type Parameter Vs. Type Member</p>\\n<p>两者很像，只是作用范围和可见性不同:</p>\\n<ul>\\n<li>参数类型只是被参数化的类型的一部分（local，private）。</li>\\n<li>类型变量就和不同变量一样，被封装在整个body中，可以被继承，显式地引用。</li>\\n<li>两者可以相互补充。比如类型成员也可以被参数化。</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>改进Iteratable</h2>\\n<p>对于集合（collection）来说，很多方法，比如：map, flatMap, filter，各有作用，但是其实这些方法都有以下两个共同点：</p>\\n<ol>\\n<li>遍历一个集合</li>\\n<li>产生一个新的集合</li>\\n</ol>\\n<p>仔细想想，是不是所有的这些操作都满足呢？</p>\\n<ul>\\n<li>map遍历一个collection，将其中的元素变形为另外类型并产生一个新的集合。</li>\\n<li>flatMap遍历一个集合，将集合中元素转换为一个集合，并最后将“集合的集合”拉平，形成一个新的集合。</li>\\n<li>filter遍历一个集合，判断是否符合过滤条件，并返回所有符合过滤条件的新的集合。</li>\\n</ul>\\n<p>找到共同点，我们就可以将其抽象出来，进而达到复用、减少重复代码的目的。对上面两个共同点，我们可以用Iterator和Builder来进行抽象实现。</p>\\n<!-- language:scala -->\\n<pre><code>// 产生新集合\\ntrait Builder[Container[X], T] {\\n  def +=(ele: T): Unit\\n  def finalise(): Container[X]\\n}\\n// 遍历（迭代）器\\ntrait Iterator[T] {\\n  def next(): T\\n  def hasNext(): Boolean\\n  def foreach(op: T => Unit): Unit = {\\n    while(hasNext()) { op(next()) }\\n  }\\n}\\n</code></pre>\\n<p>有了这两点抽象，那我们就可以对Iteratable进行改进：</p>\\n<!-- language:scala -->\\n<pre><code>// 类型参数Container\\ntrait Buildable[Container[X]] {\\n  // build方法只是返回一个Builder\\n  def build[T]: Builder[Container[X], T]\\n}\\n\\n// Iteratable没有类型参数Container\\ntrait Iteratable[T] {\\n  // 类型成员Container\\n  type Container[X] &#x3C;: Iteratable[X]\\n  def elements: Iterator[T]\\n  \\n  def mapTo[U, C[X]](f: T => U)(b: Buildable[C]): C[U] = {\\n    val buff = b.build[U]\\n    val elems = elements\\n    while(elems.hasNext) {\\n      buff += f(elems.next)\\n    }\\n    buff.finalise\\n  }\\n  \\n  def filterTo[C[X]](f: T => Boolean)(b: Buildable[C]): C[T] = {\\n    val buff = build[T]\\n    val elems = elements\\n    while(elems.hasNext) {\\n      val elem = elems.next\\n      if (f(elem)) buff += elem\\n    }\\n    buff.finalise\\n  }\\n  \\n  def flatMapTo[U, C[X]](f: T => Iterable[U])(b: Buildable[C]): C[U] = {\\n    val buff = build[U]\\n    val elems = elements\\n    while(elems.hasNext) {\\n      f(elems.next).elements.foreach(buff += _)\\n    }\\n    buff.finalise\\n  }\\n  \\n  def map[U](f: T => U)(b: Buildable[Container]): Container[U] = mapTo[U, Container](f)(b)\\n  \\n  def filterTo(f: T => Boolean)(b: Buildable[Container]) : Container[T] =\\n    filterTo[Container](f)(b)\\n  \\n  def flatMap[U](f: T => Iteratable[U])(b: Buildable[Container]): Container[U] = \\n    flatMapTo[U, Container](f, b)\\n    \\n}\\n</code></pre>\\n<p>上面的代码中，我们用<code>Buildable</code>和<code>Iterator</code>将前文提到的两个共同点进行抽象，并在<code>Iteratable</code>的实现中，利用这两个抽象：Curried的参数<code>b: Buildable[C]</code>以及<code>def elements: Iterator[T]</code>抽象方法，分别实现了：<code>map</code>, <code>filter</code>, <code>flatMap</code>。</p>\\n<p>而Iteratable的具体实现，只需要具化上面两个抽象就可以了。比如List的实现：</p>\\n<!-- language:scala -->\\n<pre><code>object ListBuildable extends Buildable[List] {\\n  def build[T]: Builder[List, T] = new ListBuffer[T] with Builder[List, T]() {\\n    // `+=` 是scala标准库中ListBuffer的方法\\n    def finalise(): List[T] = toList\\n  }\\n}\\n\\nclass List[T] extends Iteratable[T] {\\n  type Container[X] = List[X]\\n  def elements: Iterator[T] = new Iterator {\\n    ......\\n  }\\n}\\n</code></pre>\\n<p>有了上面的实现，我们就可以利用scala的另外一个机制：implicit来实现根据类型来自动选择匹配的<code>Buildable</code>了。</p>\\n<h3>Scala标准库实现</h3>\\n<p>掌握上面的思想，我们回头再看scala标准库中collection的实现机制，就很容易理解了。scala的collection架构正是基于<code>builders</code>和<code>traversals</code>思想实现的。</p>\\n<!-- language:scala -->\\n<pre><code>package scala.collection.mutable\\nclass Builder[-Elem, +To] {\\n  def +=(elem: Elem): this.type\\n  def result(): To\\n  def clear(): Unit\\n  def mapResult[NewTo](f: To => NewTo): Builder[Elem, NewTo] = ...\\n}\\n</code></pre>\\n<p>可以看出上面的<code>result</code>方法就是：我们例子中的<code>finalise</code>，此外多了<code>clear</code>, <code>mapResult</code>两个方法。</p>\\n<p>再看看<code>Buildable</code>的实现：</p>\\n<!-- language:scala -->\\n<pre><code>package scala.collection.generic\\ntrait CanBuildFrom[-From, -Elem, +To] {\\n  // Creates a new builder \\n  def apply(from: From): Builder[Elem, To] \\n}\\n</code></pre>\\n<p>在scala中，换了个名字：<code>CanBuildFrom</code>，感觉会更贴切一些（不过从dual的角度就感觉不那么好了）。</p>\\n<p>上面的<code>apply</code>就是<code>build</code>只是多了一个参数。</p>\\n<p>再来看<code>Iteratable</code>:</p>\\n<!-- language:scala -->\\n<pre><code>package scala.collection\\nclass TraversableLike[+Elem, +Repr] {\\n  def newBuilder: Builder[Elem, Repr] // deferred\\n  def foreach[U](f: Elem => U)        // deferred\\n          ...\\n  def filter(p: Elem => Boolean): Repr = {\\n    val b = newBuilder\\n    foreach { elem => if (p(elem)) b += elem }\\n    b.result\\n  } \\n}\\n</code></pre>\\n<h3>类型参数 vs. 类型成员</h3>\\n<p>在上面的例子中，我们同时使用了类型参数和类型成员。</p>\\n<ul>\\n<li>Buildable的主要目的是构建某种类型的Container，因此使用类型参数将其显式地暴露给客户端。</li>\\n<li>对于Iterable，用户更关心的是其中包含的元素类型，而不是容器(Iterable本身就类似个容器了)，所以我们采用类型成员。</li>\\n</ul>\\n<h2>关于类型(Type)和种类(Kind)</h2>\\n<p>其实中文“类型”在这里很混淆，将英文中的两个词type、kind都翻译为“类型”了，其实是有差别的，我们这里将type翻译为\\\"类型\\\"，kind翻译为\\\"种类\\\"。</p>\\n<p>值、特定类型和种类的关系可以从下图中得到解答。</p>\\n<p><img src=\\\"http://i.stack.imgur.com/K0dwL.jpg\\\" alt=\\\"values, types and kinds的关系图\\\"></p>\\n<ul>\\n<li>特定类型是对某种特定类型的值进行分类，比如Int是对1，2，3，4等值的分类，1，2，3是值，Int是Type(类型)。</li>\\n<li>种类是对特定类型的归类，比如对Int, String, List[Int]等类型，我们进行高阶抽象，可以认为这些特定类型都是相同种类的，可以用<code>*</code>来描述。这里<code>*</code>不是用来描述任意值的，而是<em>任意一个特定类型</em>。</li>\\n<li>种类<code>K</code>可以是<code>*</code> (看下面定义)，也可以是<code>K → K</code>，其中<code>→</code>是<em>种类构造器</em>，用来构造一个<strong>用于归纳类型构造器的种类</strong>，绕口吧，简单地说就是<code>K → K</code>接受一个种类参数，返回一个新的种类.</li>\\n</ul>\\n<h3>Kind的定义</h3>\\n<pre><code>Kind ::= '*(' Type ',' Type ')' | [id '@' ] Kind '→' Kind\\n</code></pre>\\n<p><code>*(T, U)</code>种类中<code>T</code>用来描述类型下边界(lower bound)，<code>U</code>为类型上边界(upper bound)。在Scala中，最低边界是<code>Nothing</code>因为它使一切类型的子类，最高边界是<code>Any</code>，它使所有类型的超类。因为我们经常使用upper bound, 所以，我们用<code>*(Nothing, U)</code>，简化为<code>*(U)</code>来描述一个种类，特别地，<code>*(Nothing, Any)</code>可以简化为<code>*</code>。</p>\\n<p>上文的几个例子：</p>\\n<table>\\n<thead>\\n<tr>\\n<th align=\\\"center\\\">Scala 类型定义</th>\\n<th align=\\\"center\\\">Kind 定义</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td align=\\\"center\\\">Container\\n[\\nX\\n]</td>\\n<td align=\\\"center\\\">*\\n → \\n*</td>\\n</tr>\\n<tr>\\n<td align=\\\"center\\\">Pair\\n[\\nT, U\\n]</td>\\n<td align=\\\"center\\\">*\\n → \\n*\\n → \\n*</td>\\n</tr>\\n<tr>\\n<td align=\\\"center\\\">Container\\n[\\nX\\n]\\n &#x3C;: Iterable\\n[\\nX\\n]</td>\\n<td align=\\\"center\\\">X @ \\n*\\n → \\n*\\n(Iterable\\n[\\nX\\n]\\n)</td>\\n</tr>\\n<tr>\\n<td align=\\\"center\\\">C[X &#x3C;: Ordered\\n[\\nX\\n]\\n] &#x3C;: Iterable\\n[\\nX\\n]</td>\\n<td align=\\\"center\\\">X @ \\n*\\n(Ordered\\n[\\nX\\n]\\n) → \\n*\\n(Iterable\\n[\\nX\\n]\\n)</td>\\n</tr>\\n</tbody>\\n</table>\\n<p>有了Kind定义，我们就可以通过其进行Kind推导，比如<code>T</code>的种类是<code>X @ K → K'</code>，如果<code>U</code>的Kind是<code>K</code>，那么很简单的通过替换，我们就可以知道<code>T[U]</code>的Kind是<code>K'</code>。</p>\\n<h3>子种类Subkinding</h3>\\n<p>scala中，我们通过<code>&#x3C;:</code>或者<code>>:</code>来表述两个类型（type）之间的关系。比如：<code>Int &#x3C;: Number</code>。</p>\\n<p>对于种类，我们可以重载<code>&#x3C;:</code> and <code>>:</code>，用来描述两个种类之间的关系。比如：<code>*(T, U) &#x3C;: *(T', U')</code>，当且仅当：<code>T' &#x3C;: T</code> AND <code>U &#x3C;: U'</code>时上述关系成立。这个相对容易理解，因为<code>T</code>/<code>T'</code>是类型参数，和方法参数一样，是逆变(contravariance)的。</p>\\n<p>scala编译器正是通过应用这些规则来进行type/kind检查的。比如，scala编译器将对下面代码报错：</p>\\n<!-- language:scala run -->\\n<pre><code>class Iterable[Container[X], T]\\ntrait NumericList[T &#x3C;: Number] extends Iterable[NumericList, T]\\n</code></pre>\\n<p>你可以点击<code>run</code>按钮试试，看看编译会出现什么结果。</p>\\n<p>之所以报错，是因为<code>Iterable[NumericList, T]</code>的问题。我们可以应用上面学到的subkinding来分析一下。</p>\\n<p><code>NumericList[T &#x3C;: Number]</code>的种类是：<code>*(Number) → *</code>，很显然，它必须是<code>Iterable</code>的第一个类型参数<code>NumericList</code>的子种类， 也就是：<code>*(Number) → * &#x3C;: * → *</code>。在<code>→</code>左边的是种类参数，是逆变的(contravariant)，所以这里我们需要：<code>* &#x3C;: *(Number)</code>，但是这显然是不成立的。所以scala编译器会报错：<code>type T's bounds &#x3C;: Number are stricter than type X's declared bounds >: Nothing &#x3C;: Any</code>。</p>\\n<p>OK then, how to make it work ? 我们需要引入一个新的类型参数：Bound</p>\\n<!-- language:scala run -->\\n<pre><code>class Iterable[Container[X &#x3C;: Bound], T &#x3C;: Bound, Bound]\\ntrait NumericList[T &#x3C;: Number] extends Iterable[NumericList, T, Number]\\n</code></pre>\\n<p><code>Iterable[Container[X &#x3C;: Bound], T &#x3C;: Bound, Bound]</code>的种类是：<code>*(Bound) → * → *(Bound) → * → *</code></p>\\n<p><code>NumericList[T &#x3C;: Number]</code>的种类是：<code>*(Number) → *</code>，该种类必须是<code>Iterable</code>第一个参数的子种类，也就是：<code>*(Number) → * &#x3C;: *(Bound) → *</code>，而<code>Bound</code>已经指定为<code>Number</code>，经过替换，就有了：<code>*(Number) → * &#x3C;: *(Number) → *</code>，左右两边相同，自然是满足要求了。</p>\\n<h3>高种类型</h3>\\n<p>如果你使用scala 2.11.x版本，在REPL中，就可以通过<code>:type</code>来查看一个类型的种类（Kind）了。比如：</p>\\n<!-- language:scala run -->\\n<pre><code>scala> :kind -v List\\nscala.collection.immutable.List's kind is F[+A]\\n* -(+)-> *\\nThis is a type constructor: a 1st-order-kinded type.\\n\\nscala> :kind -v Pair[_, _]\\nscala.Tuple2's kind is F[+A1,+A2]\\n* -(+)-> * -(+)-> *\\nThis is a type constructor: a 1st-order-kinded type.\\n</code></pre>\\n<p>可以看到，两者的类型一个是：<code>* → *</code> 另外一个是 <code>* → * → *</code>，而且，两个都是：<code>1st-order-kinded type</code>。那怎么才算是一个<code>higher order kinded type</code>呢？</p>\\n<p>在上面的图中:<code>Functor[List]</code>是<code>higher order kinded type</code>: <code>(* → *) → *</code>，这个和<code>Pair[_, _]</code>的<code>* → * → *</code>相比，不就多了个括号吗？玄机就再这个括号上：<code>(* → *) → *</code>表示你接受一个一阶类型* → *，然后产生一个最终的类型。类型的类型，所以是高阶类型。</p>\\n<h2>Implicit机制</h2>\\n<p><code>implicit</code>是scala中一个很强大的东西，其主要出发点是“偷懒”，没错，就是偷懒，让程序员可以偷懒，将本来应该码农干的活交给“编译器”完成。</p>\\n<p>implicit能帮我们码农的有两个地方：隐式参数和隐式转换。</p>\\n<h3>隐式参数</h3>\\n<p>具体来说，就是你可以将一个方法调用的参数（显式注为implicit）省略掉，编译器会在当前上下文中找能用于补充缺失掉参数的值，如果能找到，就自动填充，找不到就会在编译时报错。比如下面例子：</p>\\n<!-- language:scala run -->\\n<pre><code>def foo[T](t: T)(implicit integral: Integral[T]) = { println(integral) }\\nfoo(1)\\n</code></pre>\\n<p>注意<code>foo(1)</code>中只提供了第一个参数，一个<code>Int</code>值，但是第二个参数被省略了，scala编译器就会查找当前scope中有没有类型为<code>Integral[Int]</code>的<code>implicit</code>值。很幸运，scala.math.Numeric中定义了<code>implicit object IntIsIntegral extends IntIsIntegral with Ordering.IntOrdering</code>，所以编译器会找到<code>IntIsIntegral</code>对象然后自动补充第二个参数。</p>\\n<p>那我们再试一下<code>foo(1.0)</code>，这个时候，编译器会报错。为什么呢？查查scala.math.Numeric源码，我们就会发现：scala为Double提供了implicit Fractional对象，make sense，double不是整数嘛。同时scala还是提供了一个对象<code>DoubleAsIfIntegral</code>，但并没有标记为<code>implicit</code>，所以编译器找不到。了解了原因，简单做如下改动：</p>\\n<!-- language:scala run -->\\n<pre><code>def foo[T](t: T)(implicit integral: Integral[T]) = { println(integral) }\\nfoo(1)\\nimplicit val doubleAsIfIntegral = scala.math.Numeric.DoubleAsIfIntegral\\nfoo(1.0)\\n</code></pre>\\n<p>现在大家都happy了。</p>\\n<p>你可以通过<code>implicitly[Integral[Double]]</code>来自行查找是否有符合条件的隐式参数。</p>\\n<h3>隐式转换</h3>\\n<p>implicit的另外一个作用是隐式转换，同样也是帮助码农的。具体讲，就是当你在调用某个方法在某个对象上的时候，如果这个对象的类A并没有定义这个方法，scala的编译器先不会报错，会尝试着在当前scope中查找：</p>\\n<ol>\\n<li>具有该方法定义的类型 B</li>\\n<li>能够将A转换为B的转换器</li>\\n</ol>\\n<p>如果能找到，那么scala将自动进行上述转换，找不到，报错。例如：</p>\\n<!-- language:scala -->\\n<pre><code>\\\"123\\\".map(_.toInt)\\n</code></pre>\\n<p><code>\\\"123\\\"</code>是一个<code>java.lang.String</code>类型，String上并没有定义<code>map</code>方法，但是编译器也没有报错，而且顺利执行了。这就是隐式转换：scala编译器会在上下文中找到<code>implicit def augmentString(x: String): StringOps = new StringOps(x)</code>，可以将<code>String</code>转换为有<code>map</code>定义的<code>StringOps</code>。</p>\\n<p>你可以通过<code>implicitly[String => StringOps]</code>进行自行查找符合条件的转换器。</p>\\n<p>基于隐式参数和隐式转换，在Scala的类型系统中，有两个语法糖：view bound (CC &#x3C;% Seq[T]) 和 context bound (T : Integral)。</p>\\n<h3>View Bounds</h3>\\n<p>说实话不知道这个翻译为什么好，在微博上和几位国内scala大牛们探讨过，一些人认为应该直译为：“视界”，我自己倒是觉得应该叫“化界”？因为：</p>\\n<ol>\\n<li>“视界”，可见到的边界，太笼统，含义模糊，“化界”顾名思义，可“转化到的边界”</li>\\n<li>化界听上去比较炫，像是玄幻小说中很高深的境界，^_^</li>\\n</ol>\\n<p>You can think of <code>T &#x3C;% Ordered[T]</code> as saying, “I can use any T, so long as T can be treated as an Ordered[T].” This is different from saying that T is an Ordered[T], which is what an upper bound, <code>T &#x3C;: Ordered[T]</code>, would say.</p>\\n<p>有时候隐式参数和隐式转换可以同时存在、起作用，比如下面代码：</p>\\n<!-- language:scala run -->\\n<pre><code>def getIndex[T, CC](seq: CC, value: T)(implicit converter: CC => Seq[T]) = seq.indexOf(value)\\n\\ngetIndex(\\\"abcde\\\", 'c')\\ngetIndex(List(1,3,2,5), 3)\\n</code></pre>\\n<p>上面代码中<code>CC</code>可以是任何能转换为<code>Seq</code>的类型，所以<code>String</code>和<code>List</code>都可以应用。</p>\\n<p>首先，<code>converter</code>是一个隐式参数，其次，因为<code>seq</code>对象的类型是<code>CC</code>，其上面并没有定义<code>indexOf</code>方法，所以“隐式转换”介入。</p>\\n<p>事实上，这个用法非常普遍，所以scala专门为其提供了一个语法糖：view bound <code>CC &#x3C;% Seq[T]</code>，重写上面代码：</p>\\n<!-- language:scala run -->\\n<pre><code>def getIndex[T, CC &#x3C;% Seq[T]](seq: CC, value: T) = seq.indexOf(value)\\n</code></pre>\\n<p>运行上面代码，你可以从输出看到scala编译器会将方法重新定义为：<code>getIndex: [T, CC](list: CC, value: T)(implicit evidence$1: CC => Seq[T])Int</code>，和第一种方法一样。</p>\\n<h3>Context Bounds</h3>\\n<p>再看下面一个例子：</p>\\n<!-- language:scala run -->\\n<pre><code>def sum[T](list: List[T])(implicit integral: Integral[T]): T = {\\n    import integral._   // get the implicits in question into scope\\n    list.foldLeft(integral.zero)(_ + _)\\n}\\n</code></pre>\\n<p>这里有一个隐式参数<code>integral</code>类型为<code>Integral[T]</code>，如果方法传入<code>Int</code>，那么scala编译器就会找<code>implicitly[Integral[Int]]</code>，这个我们在隐式参数小节已经说过了。</p>\\n<p>这里主要关注另外一个问题：<code>list.foldLeft(integral.zero)(_ + _)</code>，其中<code>_</code>的类型应该是<code>T</code>，但是<code>T</code>上面有定义<code>+</code>方法吗？我们先把<code>import integral._</code>去掉，就会发现编译出错：</p>\\n<!-- language:scala -->\\n<pre><code>&#x3C;console>:8: error: type mismatch;\\n found   : T\\n required: String\\n           list.foldLeft(integral.zero)(_ + _)\\n                                        ^\\n</code></pre>\\n<p>原来scala编译器尝试着将<code>T</code>转换为<code>String</code>了，这里应该是<code>Predef.any2string</code>起了作用。</p>\\n<p>加上<code>import integral._</code>，一切工作了。</p>\\n<p>回头想一下，其实挺有意思的：我们给一个泛型<code>T</code>动态地添加了<code>+</code>方法，但是并不改变<code>T</code>的代码。而这就是context bound的意义。</p>\\n<p>这个在流行框架<code>Scalaz</code>中应用非常广泛。scala同样为其创建了专门的语法糖：<code>[T : Ordering]</code>。采用语法糖，这个例子可以重写为：</p>\\n<!-- language:scala run -->\\n<pre><code>def sum[T : Integral](list: List[T]): T = {\\n  val integral = implicitly[Integral[T]]\\n  import integral._\\n  list.foldLeft(integral.zero)(_ + _)\\n}\\n</code></pre>\\n<p>编译器编译之后，会生成一个<code>sum: [T](list: List[T])(implicit evidence$1: Integral[T])T</code>的方法。</p>\\n<p>这里有点让人confusing的地方是：<code>T: Integral</code>的写法感觉像是说：<code>T</code>是<code>Integral</code>的类型，就像：<code>m: T</code>，可实际上应该认为是：<code>T</code>在<code>Integral</code>的<code>Context</code>中。</p>\\n<h2>结束语</h2>\\n<p>scala的类型系统确实是一个难点，但同时也是要真正掌握scala语言所必须的知识点。很多概念都很晦涩，对于像我们这些凡人，要想掌握没有太好的办法，只能多看、多练、多想。</p>\\n<h2>参考</h2>\\n<ol>\\n<li><a href=\\\"http://stackoverflow.com/questions/6246719/what-is-a-higher-kinded-type-in-scala\\\">Adriaan Moors. What is a higher kinded type in scala. StackOverflow. http://stackoverflow.com/questions/6246719/what-is-a-higher-kinded-type-in-scala. 2011</a></li>\\n<li><a href=\\\"http://docs.scala-lang.org/overviews/core/architecture-of-scala-collections.html\\\">Martin Odersky and Lex Spoon. Architecture of Scala Collection. scala-lang website. http://docs.scala-lang.org/overviews/core/architecture-of-scala-collections.html. 2013</a></li>\\n<li><a href=\\\"http://stackoverflow.com/questions/5598085/where-does-scala-look-for-implicits\\\">Daniel C. Sobral. Types of Implicits. StackOverflow. http://stackoverflow.com/questions/5598085/where-does-scala-look-for-implicits. 2011</a></li>\\n<li><a href=\\\"http://blogs.atlassian.com/2013/09/scala-types-of-a-higher-kind/\\\">Jed Wesley-Smith. Scala Types Of a Higher Kind. http://blogs.atlassian.com/2013/09/scala-types-of-a-higher-kind/</a></li>\\n</ol>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2014/高种泛型.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2014-01-08T19:16:45.000Z\",\"path\":\"/2014/generics-of-a-higher-kind\",\"title\":\"高种泛型 (Generics of a Higher Kind)\",\"excerpt\":\"Generics of a Higher Kind翻译加自我理解。\",\"tags\":[\"scala\",\"functional programming\",\"Generics\"]}}}],\"pathPrefix\":\"/\",\"first\":true,\"last\":false,\"index\":1,\"pageCount\":2}}\n\n/***/ }),\n\n/***/ 109:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"layoutContext\":{}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path----9c375f333f4f13b5533c.js","module.exports = {\"data\":{\"allMarkdownRemark\":{\"totalCount\":20,\"edges\":[{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/为你的Gatsby博客添加评论功能.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"为你的Gatsby博客添加评论功能\",\"date\":\"March 12, 2018\",\"path\":\"/2018/enable-comments-for-gatsby-blog\",\"tags\":[\"blog\"],\"excerpt\":\"Gatsby打造的博客已经很不错了，但是缺少一个评论功能。本文简单介绍如何集成Disqus评论服务到你的博客站点。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/转用Gatsby搭建博客.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"转用Gatsby打造基于github的博客站点\",\"date\":\"March 08, 2018\",\"path\":\"/2018/blog-with-gatsby\",\"tags\":[\"blog\",\"github\",\"gatsby\"],\"excerpt\":\"如何用Gatsby打造一个博客\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/一则奇怪的Toubleshooting.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"记一次奇怪的troubleshooting\",\"date\":\"March 08, 2018\",\"path\":\"/2018/skipper-sni-domain-fronting\",\"tags\":[\"skipper\",\"SNI\",\"domain fronting\"],\"excerpt\":\"在Skipper转发请求到一个https站点的时候，返回莫名404.\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2016/JSON解析利器JQ.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"JSON解析利器---JQ\",\"date\":\"March 25, 2016\",\"path\":\"/2013/jq\",\"tags\":[\"bash\",\"jq\",\"json\"],\"excerpt\":\"在API first的时代，json作为最常用的格式，充斥着程序猿的屏幕各个角落，掌握一门解析、过滤、转换json输出的工具，已经成为程序猿们安身立命的必要技能。 这里隆重向大家介绍[jq](https://stedolan.github.io/jq/).\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2016/Function的协变.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Function的协、逆变\",\"date\":\"February 04, 2016\",\"path\":\"/2016/function-covariant-contravariant\",\"tags\":[\"scala\",\"functional programming\"],\"excerpt\":\"泛型编程的时候，协变(covariant)还是逆变(contravariant)很重要，在设计上层API接口的时候，正确的使用协变、逆变可以更好地约束程序员的行为，让实现变得安全、一致。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/如何在Scala中实现AOP.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"用Mixin组合实现Scala中的AOP\",\"date\":\"August 13, 2015\",\"path\":\"/2015/aop-by-mixin-in-scala\",\"tags\":[\"scala\",\"functional programming\",\"AOP\",\"mixin\"],\"excerpt\":\"在Java世界，AOP（Aspect Oriented Programming， 面向方面编程)是很多框架的基础。这种将关注点按照“方面”来切分的编程模型极大地简化了编程的复杂度，尤其是在多维度因子交织在一起的时候的各种场景。对于代码的可读性、可维护性、可重用性都是极大的帮助。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Scala雾里看花.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Scala雾里看花\",\"date\":\"April 23, 2015\",\"path\":\"/2015/scala-trouble-shooting\",\"tags\":[\"scala\",\"trouble shooting\"],\"excerpt\":\"Scala的学习过程中，经常会碰到一些莫名其妙的现象，很多时候，这些语言层面的“怪象”都与scala编译器或者scala的类型系统有关。本文不是对编译器和类型系统的介绍，而是重点介绍遇到这些现象的时候，用什么样的方式，拨开云雾见蓝天，通过这些工具获取一些细节帮你了解编译器和类型系统如何工作。工欲善其事，必先利其器。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Docker创建MySQL主从复制以及CDC测试.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"MySQL Master/Slave Replication on Docker\",\"date\":\"April 21, 2015\",\"path\":\"/2015/mysql-replication-on-docker\",\"tags\":[\"docker\",\"mysql\"],\"excerpt\":\"How to setup Mysql master/slave replication.\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2014/Scala函数式异常处理.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Scala函数式异常处理\",\"date\":\"May 04, 2014\",\"path\":\"/2014/scala-error-handling-in-fp-style\",\"tags\":[\"scala\",\"functional programming\",\"exception handling\"],\"excerpt\":\"经常看到很多示例代码，简洁的让人爱不释手，可是真正自己实现的时候，不得不添加各种各样的异常处理逻辑，最后发现代码总量的80%都是再做异常处理，而真正的代码逻辑只有很少的一部分。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2014/高种泛型.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"高种泛型 (Generics of a Higher Kind)\",\"date\":\"January 08, 2014\",\"path\":\"/2014/generics-of-a-higher-kind\",\"tags\":[\"scala\",\"functional programming\",\"Generics\"],\"excerpt\":\"Generics of a Higher Kind翻译加自我理解。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/map-flatMap-for.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"map/flatMap/for in Action\",\"date\":\"December 01, 2013\",\"path\":\"/2013/map-flatmap-for\",\"tags\":[\"scala\",\"functional programming\"],\"excerpt\":\"前文说过了，高阶函数式函数式语言中的基石，而`map`, `flatMap`更是重要。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/fold编程.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"折纸的艺术：fold编程\",\"date\":\"November 27, 2013\",\"path\":\"/2013/fold\",\"tags\":[\"scala\",\"functional programming\",\"fold\"],\"excerpt\":\"Eric Meijer说：递归是函数式编程的GOTO，应该尽可能避免。如何避免，OO中我们用while循环，FP中我们用`fold`。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Monad.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Monad\",\"date\":\"November 26, 2013\",\"path\":\"/2013/monad\",\"tags\":[\"scala\",\"functional programming\",\"monad\"],\"excerpt\":\"函数式语言与OO（确切地讲是指令式编程）的思维方式是完全不同的，很多OO中的经验在函数式语言中不是很匹配，比如设计模式，那就是一个OO中的特定术语，而在FP中，大家常谈的是对于习惯OO思维的程序员来说玄而又玄的Monad。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/高阶函数.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"高阶函数\",\"date\":\"November 21, 2013\",\"path\":\"/2013/high-order-function\",\"tags\":[\"scala\",\"functional programming\",\"high order function\"],\"excerpt\":\"所谓高阶函数（high order function），其实就是可以接受其他函数作为参数的函数。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Actor协调并发场景下的集合操作.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"边建边学-3：Actor协调并发场景下的集合操作\",\"date\":\"November 17, 2013\",\"path\":\"/2013/actor-collection-collabration\",\"tags\":[\"scala\",\"functional programming\"],\"excerpt\":\"很多时候为了提高性能，减少IO操作，都会将数据load出来之后缓存在内存中。本站的实现过程中也遇到类似的问题，不希望每次有人访问的时候就读取一次md文件，或者从MongoDB中查一次，而是直接在内存中读取。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Enumerator-Iteratee-Enumeratee.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Enumerator / Iteratee / Enumeratee\",\"date\":\"November 11, 2013\",\"path\":\"/2013/enumerator-iteratee-enumeratee\",\"tags\":[\"scala\",\"playframework\",\"blog\"],\"excerpt\":\"Stream对于指令式编程已经比较成熟了，有大量的类库，丰富的API。但是对于强调不可变量，尽可能无副作用的FP来说，要考虑语言适配的问题，而目前，流行的解决方案就是：Enumerator/Iteratee。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/集成PlantUML和Markdown.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"边建边学-2：集成PlantUML和Markdown\",\"date\":\"November 07, 2013\",\"path\":\"/2013/markdown-plantuml-integration\",\"tags\":[\"markdown\",\"plantuml\",\"blog\"],\"excerpt\":\"如何用Markdown+PlantUML结合来写图文并茂的博客。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/EssentialAction-in-Playframework.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"EssentialAction in Playframework\",\"date\":\"November 05, 2013\",\"path\":\"/2013/essential-action-in-play\",\"tags\":[\"scala\",\"playframework\"],\"excerpt\":\"Playframework中EssentialAction理解\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/用markdown写博客.markdown absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"边建边学-1: 用Markdown写博文\",\"date\":\"November 01, 2013\",\"path\":\"/2013/blogging-with-markdown\",\"tags\":[\"markdown\",\"blog\"],\"excerpt\":\"本文将是一个系列文章，循序渐进地介绍本站的构建过程，不只是简单的技术介绍，重点是建站过程遇到的问题分析，以及解决的过程，所以起名**“边建边学”**系列。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/开篇.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"开篇\",\"date\":\"October 25, 2013\",\"path\":\"/2013/start\",\"tags\":[],\"excerpt\":\"网络博客\"}}}]}},\"pathContext\":{\"group\":[{\"node\":{\"html\":\"<p>Gatsby打造的博客已经很不错了，但是缺少一个评论功能。</p>\\n<p>本文简单介绍如何集成Disqus评论服务到你的博客站点。</p>\\n<h2>How To</h2>\\n<p>首先，添加<code>react-disqus-thread</code>组件。</p>\\n<pre><code>yarn add react-disqus-thread\\n</code></pre>\\n<p>之后，新建一个<code>Comments</code>的React组件。</p>\\n<!-- language: lang-js -->\\n<pre><code>const React = require('react');\\nconst ReactDisqusThread = require('react-disqus-thread');\\n\\nclass Comments extends React.Component{\\n\\n    constructor(props) {\\n        super(props);\\n    }\\n    \\n    handleNewComment (comment) {\\n        \\n    }\\n\\n    render () {\\n        const id = `smilingleo/${window.location.pathname}`;\\n        return (\\n            &#x3C;ReactDisqusThread\\n                shortname=\\\"smilingleo\\\"\\n                identifier={id}\\n                title={this.props.title}\\n                onNewComment={this.handleNewComment}/>\\n        );\\n    }\\n};\\n\\nexport default Comments;\\n</code></pre>\\n<p>注意:</p>\\n<ul>\\n<li><code>identifier</code>需要是唯一的，这里我用了<code>smilingleo</code>作为前缀，加上<code>pathname</code>。</li>\\n<li><code>onNewComment</code>的响应函数中，可以做一些有意思的东西，比如给你的IM发一条消息，尝试了Slack Webhook，可惜不支持CORS.</li>\\n</ul>\\n<p>最后，在<code>templates/blog-post.js</code>文件中添加：</p>\\n<!-- language: lang-html -->\\n<pre><code>&#x3C;hr />\\n&#x3C;Comments title={title} />\\n</code></pre>\\n<p>搞定.</p>\\n<h2>References</h2>\\n<ol>\\n<li><a href=\\\"https://github.com/mzabriskie/react-disqus-thread\\\">React Disqus thread component</a></li>\\n</ol>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/为你的Gatsby博客添加评论功能.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2018-03-12T10:07:43.000+08:00\",\"path\":\"/2018/enable-comments-for-gatsby-blog\",\"title\":\"为你的Gatsby博客添加评论功能\",\"excerpt\":\"Gatsby打造的博客已经很不错了，但是缺少一个评论功能。本文简单介绍如何集成Disqus评论服务到你的博客站点。\",\"tags\":[\"blog\"]}}},{\"node\":{\"html\":\"<h2>起因</h2>\\n<p>原来的博客站点基于Jekyll搭建，各种问题，感觉很不爽。后来看到Gatsby，基于ReactJS, GraphQL，都是我的最爱，于是果断投诚！</p>\\n<h2>遇到的问题</h2>\\n<h3>和prettyprint集成的问题</h3>\\n<p>原来的prettyprint机制是在页面加载的时候调用<code>init()</code>，检查DOM中的<code>pre.code</code>元素。但是转到React之后，全部是前端Routing，原来写的<code>window.onload = init</code>不工作了。每次都要手动刷新。</p>\\n<p>解决办法是在Gatsby Link元素的<code>onClick</code>事件中注册一个timer:</p>\\n<!-- language: js -->\\n<pre><code>&#x3C;Link to={frontmatter.path} onClick={() => setTimeout(init, 100)}>{frontmatter.title}&#x3C;/Link>\\n</code></pre>\\n<p>这样，在点击链接打开页面之后，就会调用<code>init</code>了。</p>\\n<p><strong>更新：</strong>\\n上面的方法更像是一个Hack，因为毕竟Link的目的只是指向一个target，不应该把不属于Link的职责(解析页面DOM并设置pre.code的style)绑定到Link上。</p>\\n<p>重新思考了一下之后，重构了<code>templates/blog-post.js</code>，原来的<code>Template</code>是一个ES6箭头函数，因为我们希望的是在页面组件都Mount之后，调用<code>init</code>，所以，我们将其修改为一个扩展<code>React.Component</code>的class.</p>\\n<!-- language:lang-js -->\\n<pre><code>class Template extends React.Component {\\n    constructor(props) {\\n        super(props);\\n    }\\n    \\n    /*\\n    * Once the blog page is loaded, run init() to prettyprint the code.\\n    */\\n    componentDidMount() {\\n        init();\\n    }\\n\\n    render() {\\n        const { markdownRemark: post } = this.props.data\\n        const { frontmatter, html } = post\\n        const { title, date } = frontmatter\\n        const { next, prev } = this.props.pathContext\\n    \\n        return (\\n            ...\\n        )  \\n    }\\n}\\n</code></pre>\\n<p>这样，就达到目的了。</p>\\n<h3>发布方法</h3>\\n<p>原来以为是将这些源码直接push到 <code>smilingleo.github.io</code>，后来发现不对。</p>\\n<p>需要有两个github repos，一个 <code>my-blog-code</code>, 另外一个 <code>smilingleo.github.io</code>。</p>\\n<p>新的博文写完之后，需要<code>yarn deploy</code>，这样会发布到<code>public/</code>，然后将<code>public</code>目录指向<code>smilingleo.github.io</code>这个repo。</p>\\n<p>所以，一篇博客需要提交两个git repos。</p>\\n<h3>date格式问题</h3>\\n<p>原来用Jekyll的时候，date可以是<code>YYYY-MM-dd HH:mm:ss</code>的格式，但是用Gatsby必须是<code>YYYY-MM-dd'T'HH:mm:ss</code>。</p>\\n<h2>参考资料</h2>\\n<ol>\\n<li><a href=\\\"https://egghead.io/courses/build-a-blog-with-react-and-markdown-using-gatsby\\\">Egghead教程</a></li>\\n<li><a href=\\\"https://stackoverflow.com/questions/37170809/react-createclass-vs-es6-arrow-function/37170998#37170998\\\">React.createClass vs. ES6 arrow function</a></li>\\n</ol>\\n<p>In summary:</p>\\n<p>The short answer is that you want to use Stateless Functional Components (SFC) as often as you can; the majority of your components should be SFC's.</p>\\n<p>Use the traditional Component class when:</p>\\n<p>You need local state (<code>this.setState</code>)\\nYou need a lifecycle hook (<code>componentWillMount</code>, <code>componentDidUpdate</code>, etc)\\nYou need to access backing instances via refs (eg. <code>&#x3C;div ref={elem => this.elem = elem}></code>)</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/转用Gatsby搭建博客.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2018-03-08T17:00:00.000+08\",\"path\":\"/2018/blog-with-gatsby\",\"title\":\"转用Gatsby打造基于github的博客站点\",\"excerpt\":\"如何用Gatsby打造一个博客\",\"tags\":[\"blog\",\"github\",\"gatsby\"]}}},{\"node\":{\"html\":\"<h2>问题描述</h2>\\n<p>因为我们的项目中用到了<a href=\\\"http://github.com/zalando/skipper\\\">Skipper</a>作为UI层的gateway，在支持一个新上线的UI应用的时候，发现一个奇怪的现象，假定：</p>\\n<pre><code>Skipper Domain: https://ui.example.com\\nWebapp Internal Domain：https://webapp.internal.example.com\\n</code></pre>\\n<p>在Skipper收到一个请求 <code>GET https://ui.example.com/webapp</code>的时候，根据Routing规则：</p>\\n<pre><code>Path(\\\"/webapp\\\") -> \\\"https://webapp.internal.example.com\\\"\\n</code></pre>\\n<p>请求应该是会被转到这个地址的。测试发现：</p>\\n<!-- language: lang-bash -->\\n<pre><code># 正常工作，返回200\\ncurl -i https://webapp.internal.example.com\\n\\n# 返回404\\ncurl -i https://ui.example.com\\n</code></pre>\\n<p>神奇的就是后面的测试，返回404，而且来源于一个<code>nginx</code>服务器。</p>\\n<h2>调试</h2>\\n<p>通过 <code>curl -vv</code> 比较两个请求的差异，发现两个服务器的证书CN不同，一个是 <code>*.example.com</code>，另外一个是 <code>*.internal.example.com</code>，怀疑是不是SNI相关的问题，尝试了一下：</p>\\n<pre><code class=\\\"language-bash\\\">curl -i -H \\\"Host: webapp.internal.example.com\\\" https://ui.example.com\\n</code></pre>\\n<p>哈，成功返回200.</p>\\n<p>查阅了一下SNI相关资料，发现了疑惑：SNI中hello_name来源于 URL中的domain name，而不是被加密的Header。一个web server如果host多个domains，在request过来的时候，会根据URI中的domain name来查找对应domain的证书，然后用来SSL握手，如果找不到证书，才会返回一个默认的页面，比如404.</p>\\n<p>但是根据我们的试验，证书应该是正确的，所以应该不是SNI的问题。</p>\\n<h2>真相大白</h2>\\n<p>问题是解决了，但是却不知道是什么原因，这让人很不舒服，继续找。无意中发现了这个<a href=\\\"https://github.com/golang/go/issues/22704\\\">Issue</a>，其中提到：</p>\\n<blockquote>\\n<p>This would break usage of net/http for <a href=\\\"https://www.bamsoftware.com/papers/fronting/\\\">domain fronting</a>, an anti-censorship technique specifically relying on sending different hosts in SNI and HTTP headers. Such a use of net/http is not rare: censorship-resistant tunneling software such as <a href=\\\"https://github.com/getlantern/lantern\\\">Lantern</a> and my own project Geph both use net/http this way.</p>\\n</blockquote>\\n<p><code>domain fronting</code>？什么鬼，著名的<code>lantern</code>居然在用，查了一下，明白了。原来这个技术就是用来翻墙的，哈。</p>\\n<p>具体来说：</p>\\n<p><img src=\\\"https://www.bamsoftware.com/papers/fronting/fronting.svg\\\" alt=\\\"domain fronting\\\"></p>\\n<p>比如你想访问被墙的网站<code>forbidden.example</code>,你可以用36计之张冠李戴，谎称我访问的是<code>allowed.example</code>, 然后在request header中指定<code>Host: forbidden.example</code>，用https，这样请求就会被加密，邪恶的探测器们就无法知道你真正的地址，而且这样也符合SNI的握手协议。</p>\\n<p>现在很多网站都支持这种技术，比如google:</p>\\n<pre><code class=\\\"language-bash\\\">curl -vv -H \\\"Host: maps.google.com\\\" https://www.google.com\\n</code></pre>\\n<p>从URL上看，访问的是<code>www.google.com</code>，但是你看一下返回内容会发现，这个内容却是<code>maps.google.com</code>返回的。</p>\\n<p>在我们的例子中，因为skipper中设置了<code>-proxy-preserve-host</code>，这样<code>Host</code> header会被传递给下面的目标app，而这个目标app因为支持domain fronting，尝试着去找那个 <code>ui.example.com</code>对应的证书，当然没有，所以返回<code>404</code>.</p>\\n<h2>参考资料</h2>\\n<ol>\\n<li><a href=\\\"https://www.bamsoftware.com/papers/fronting/\\\">Domain Fronting</a></li>\\n<li><a href=\\\"https://en.wikipedia.org/wiki/Server_Name_Indication\\\">Server Name Indication</a></li>\\n</ol>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/一则奇怪的Toubleshooting.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2018-03-08T08:30:00.000+08\",\"path\":\"/2018/skipper-sni-domain-fronting\",\"title\":\"记一次奇怪的troubleshooting\",\"excerpt\":\"在Skipper转发请求到一个https站点的时候，返回莫名404.\",\"tags\":[\"skipper\",\"SNI\",\"domain fronting\"]}}},{\"node\":{\"html\":\"<p>在API first的时代，json作为最常用的格式，充斥着程序猿的屏幕各个角落，掌握一门解析、过滤、转换json输出的工具，已经成为程序猿们安身立命的必要技能。\\n这里隆重向大家介绍<a href=\\\"https://stedolan.github.io/jq/\\\">jq</a>.</p>\\n<h2>常用命令</h2>\\n<h3>pipe: |</h3>\\n<p>和unix管道一样。</p>\\n<h3>.[]</h3>\\n<p>用来将数组中内容传递给后面命令，而不是把整个数组传过去（脱包）\\n还可以用<code>.[n]</code>来获取数组中第n个元素。</p>\\n<h3>has(key)</h3>\\n<p>检查json对象中是否有key属性。一般结合<code>select()</code>使用。</p>\\n<h3>select(boolean_expr)</h3>\\n<p>用来过滤输入。比如，只输出具有<code>name</code>项的json对象，可以用：<code>jq 'has(\\\"name\\\") as $hasName | select($hasName=true)'</code></p>\\n<h2>实战</h2>\\n<p>我们将使用<code>docker inspect</code>输出结果作为例子进行解析。</p>\\n<h3>列出所有docker images的inspect结果</h3>\\n<!-- language:bash -->\\n<pre><code>docker inspect $(docker images | tail -n +2 | awk '{print $1\\\":\\\"$2}')\\n</code></pre>\\n<h3>只列出所有volumes不为空的images</h3>\\n<!-- language:bash -->\\n<pre><code>docker inspect $(docker images | tail -n +2 | awk '{print $1\\\":\\\"$2}') | jq '.[] | select(.Config.Volumes!=null)'\\n</code></pre>\\n<h3>将json转换为csv</h3>\\n<!-- language:bash -->\\n<pre><code>docker inspect $(docker images | tail -n +2 | awk '{print $1\\\":\\\"$2}') | jq '.[] | [(.RepoTags|.[0]), .DockerVersion] | @csv'\\n</code></pre>\\n<p>上面例子中：</p>\\n<ul>\\n<li><code>.[]</code>将数组中每个单项传递给后面命令</li>\\n<li><code>(.RepoTags|.[0])</code>取出第一个RepoTags的内容也就是image的name:tag</li>\\n<li><code>.DockerVersion</code>取出docker版本</li>\\n<li><code>将上面两个命令用</code>,`连接，表示将前面的输入同时传递给这两个命令</li>\\n<li>用<code>[]</code>将上面两个命令包起来，表示将两个命令的输出结果作为数组中的一个item</li>\\n<li><code>@csv</code>将前面的数组输出转换为csv格式。</li>\\n</ul>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2016/JSON解析利器JQ.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2016-03-25T19:16:45.000Z\",\"path\":\"/2013/jq\",\"title\":\"JSON解析利器---JQ\",\"excerpt\":\"在API first的时代，json作为最常用的格式，充斥着程序猿的屏幕各个角落，掌握一门解析、过滤、转换json输出的工具，已经成为程序猿们安身立命的必要技能。 这里隆重向大家介绍[jq](https://stedolan.github.io/jq/).\",\"tags\":[\"bash\",\"jq\",\"json\"]}}},{\"node\":{\"html\":\"<p>泛型编程的时候，协变(covariant)还是逆变(contravariant)很重要，在设计上层API接口的时候，正确的使用协变、逆变可以更好地约束程序员的行为，让实现变得安全、一致。</p>\\n<p>协变、逆变在一般时候是比较容易理解的，但是来到FP世界之后，Function的协变、逆变就变得比较复杂。</p>\\n<p>比如： 对于<code>trait List[+T]</code></p>\\n<!-- language:uml -->\\n<pre><code>class Animal\\nclass Dog\\nclass \\\"List[Animal]\\\" as LA\\nclass \\\"List[Dog]\\\" as LD\\n\\nAnimal &#x3C;|-- Dog\\nLA &#x3C;|-- LD\\n</code></pre>\\n<p>那对于<code>trait CList[-T]</code></p>\\n<!-- language:uml -->\\n<pre><code>class Animal\\nclass Dog\\nclass \\\"CList[Animal]\\\" as LA\\nclass \\\"CList[Dog]\\\" as LD\\n\\nAnimal &#x3C;|-- Dog\\nLA --|> LD\\n</code></pre>\\n<p>这些还都容易理解，对于<code>trait Func[-I, +O]</code>的理解就比较费劲了。</p>\\n<!-- language:lang-scala -->\\n<pre><code>import scala.reflect.runtime.universe._\\n\\nclass Animal\\ncase class Dog(name: String) extends Animal\\n\\nclass Material\\ncase class Wood(color: String) extends Material\\n\\ntrait Func[-I, +O] {\\n  def apply(input: I): O\\n}\\n\\ntypeOf[Dog] &#x3C;:&#x3C; typeOf[Animal]  // return true\\ntypeOf[Func[Material, Dog]] &#x3C;:&#x3C; typeOf[Func[Wood, Animal]]    // retrun true\\n</code></pre>\\n<!-- language:uml -->\\n<pre><code>class Animal\\nclass Dog\\nclass Wood\\nclass Material\\n\\nclass \\\"Func[Wood, Animal]\\\" as LA\\nclass \\\"Func[Material, Dog]\\\" as LD\\n\\n\\nWood --|> Material\\nLA &#x3C;|-- LD\\nAnimal &#x3C;|-- Dog\\n</code></pre>\\n<p>理解这个的关键是理解“里氏替换原则”，也就是，任何父类出现的地方，如果用其子类来替换都应该是安全的。从这个角度看，这个<code>Func</code>完成的工作是用某种材料来制作某种动物，<code>Func[Wood, Animal]</code>是输入木头制作任何动物，<code>Func[Material, Dog]</code>是输入任何材料来制作狗。考虑下面的应用场景：</p>\\n<!-- language:lang-scala -->\\n<pre><code>val woods: List[Wood] = ...         //给定一堆木头\\n\\nval makeAnimalWithWood: Func[Wood, Animal] = ...\\nval makeDogWithMaterial: Func[Material, Dog] = ...\\n\\nval describer: Animal -> String = ...\\n\\nwoods.map(makeAnimalWithWood)       // return List[Animal]\\n     .map(describer)                // 接受Animal返回String\\n</code></pre>\\n<p>根据里氏替换原则，用<code>makeDogWithMaterial</code>替换<code>makeAnimalWithWood</code>是安全的。反过来，看下面代码：</p>\\n<!-- language:lang-scala -->\\n<pre><code>val materials: List[Material] = ...           // 给定一堆材料\\n\\nval makeAnimalWithWood: Func[Wood, Animal] = ...\\nval makeDogWithMaterial: Func[Material, Dog] = ...\\n\\nval describer: Dog -> String = ...\\n\\nmaterials.map(makeDogWithMaterial)       // return List[Dog]\\n     .map(describer)                // 接受Dog返回String\\n</code></pre>\\n<p>这时候，用<code>makeAnimalWithWood</code>来替换<code>makeDogWithMaterial</code>就不行了，因为<code>materials.map(makeAnimalWithWood)</code>就会编译错误了，因为<code>makeAnimalWithWood</code>只接受<code>Wood</code>，而代码传递过来的是<code>Material</code>.</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2016/Function的协变.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2016-02-04T17:16:45.000Z\",\"path\":\"/2016/function-covariant-contravariant\",\"title\":\"Function的协、逆变\",\"excerpt\":\"泛型编程的时候，协变(covariant)还是逆变(contravariant)很重要，在设计上层API接口的时候，正确的使用协变、逆变可以更好地约束程序员的行为，让实现变得安全、一致。\",\"tags\":[\"scala\",\"functional programming\"]}}},{\"node\":{\"html\":\"<h2>Java中的AOP</h2>\\n<p>在Java世界，AOP（Aspect Oriented Programming， 面向方面编程)是很多框架的基础。这种将关注点按照“方面”来切分的编程模型极大地简化了编程的复杂度，尤其是在多维度因子交织在一起的时候的各种场景。对于代码的可读性、可维护性、可重用性都是极大的帮助。</p>\\n<p>不过AOP一个令人诟病的地方是其透明性，也就是说对于开发人员来说，我不知道我的某个方法会不会被某个Aspect切面一刀，有些时候，会造成一些意想不到的后果，比如Spring的transaction管理，如果通过aop的方式来定义，比如：</p>\\n<!-- language: xml -->\\n<pre><code>&#x3C;tx:advice id=\\\"txCommonAdvice\\\" transaction-manager=\\\"transactionManager\\\">\\n    &#x3C;tx:attributes>\\n        &#x3C;tx:method name=\\\"save*\\\" propagation=\\\"REQUIRED\\\"/>\\n        &#x3C;tx:method name=\\\"remove*\\\" propagation=\\\"REQUIRED\\\"/>\\n        &#x3C;tx:method name=\\\"update*\\\" propagation=\\\"REQUIRED\\\"/>\\n        &#x3C;tx:method name=\\\"delete*\\\" propagation=\\\"REQUIRED\\\"/>\\n        &#x3C;tx:method name=\\\"*\\\" propagation=\\\"REQUIRED\\\" read-only=\\\"true\\\"/>\\n    &#x3C;/tx:attributes>\\n&#x3C;/tx:advice>\\n</code></pre>\\n<p>那么被这个切面拦截的任何方法都会导致Spring Transaction Manager启动一个事务，甚至是像<code>toString()</code>, <code>equal(other)</code>等这样的方法，而且因为其透明性，开发人员往往意识不到这个问题。</p>\\n<h2>Scala中的AOP</h2>\\n<p>在Scala的世界里，AOP的思想其实也是适用的，当然，因为Scala就运行在jvm上面，很多code weaver工具也照样是可以用的，比如aspectj, asm等等，个人不是很喜欢这些东西，更喜欢用显式的方式来告诉我的代码读者，我的代码会做哪些事情。No Magic，是我的一个信条。</p>\\n<p>Scala的Mixin机制trait，可以很好地实现显式的AOP，举个例子：</p>\\n<!-- language: scala run -->\\n<pre><code>trait Task { def execute }\\ntrait TaskLogging extends Task {\\n    abstract override def execute = {\\n        println(\\\"before execute\\\")\\n        super.execute\\n        println(\\\"after execute\\\")\\n    }\\n}\\nclass MyTask extends Task {\\n    override def execute = {\\n        println(\\\"do something\\\")\\n    }\\n}\\n\\nval task = new MyTask\\ntask.execute    // 输出 'do something'，没什么稀奇的\\n\\nval task2 = new MyTask with TaskLogging\\ntask2.execute   // 点击'run'看看会输出什么？\\n</code></pre>\\n<p>在上面代码中，<code>MyTask</code>和<code>TaskLogging</code>都是只关注于自己的逻辑（Aspect），在运行时，可以构建一个<code>MyTask with TaskLogging</code>的<code>task2</code>instance，就可以将两个方面组合在一起了。当然你还可以增加新的方面，比如：</p>\\n<!-- language: scala -->\\n<pre><code>trait Transactional extends Task {\\n    abstract override def execute = {\\n        println(\\\"begin transaction\\\")\\n        try {\\n            super.execute\\n            println(\\\"commit transaction\\\")\\n        } catch {\\n            case _: Exception =>\\n                println(\\\"rollback transaction\\\")\\n        }\\n    }\\n}\\n\\nval task3 = new MyTask with TaskLogging with Transactional\\ntask3.execute\\n</code></pre>\\n<p>这样，就可以构建一个有事务，有logging的task。</p>\\n<p>总结一下，定义一个Aspect的步骤：</p>\\n<ol>\\n<li>重载trait中的方法</li>\\n<li>方法前逻辑，比如logging、begin transaction等等</li>\\n<li>调用<code>super</code>对象的方法</li>\\n<li>方法后逻辑，比如logging、commit transaction等</li>\\n</ol>\\n<p>这里，主要的知识点是调用<code>super.execute</code>的执行顺序，在用<code>with Trait</code>定义一个新类型的时候，多个Trait会形成一个Stack，执行的时候会按照出栈顺序执行，比如：</p>\\n<!-- language: scala -->\\n<pre><code>val task = new MyTask with TaskLogging with Transactional\\ntask.execute\\n</code></pre>\\n<p>TaskLogging先入栈，Transactional后入，那么执行的时候，先执行Transactional，后执行TaskLogging，就会输出：</p>\\n<!-- language -->\\n<pre><code>begin transaction\\nbefore execute\\ndo something\\nafter execute\\ncommit transaction\\n</code></pre>\\n<p>换一个顺序：</p>\\n<!-- language: scala -->\\n<pre><code>val task = new MyTask with TaskLogging with Transactional\\ntask.execute\\n</code></pre>\\n<p>那么输出将会是另外一个顺序。    </p>\\n<h3>抽象方法中的super call</h3>\\n<p>注意一个细节，在<code>TaskLogging.execute</code>中，我们调用了<code>super.execute</code>，仔细想想，感觉很奇怪，几个疑点：</p>\\n<ol>\\n<li>TaskLogging的super是谁？</li>\\n<li>为什么<code>MyTask.execute</code>是最后执行的？</li>\\n</ol>\\n<p>查询《Programming in Scala》“traits as stackable modifications“章节后，我们可以了解到：</p>\\n<ol>\\n<li>trait中的super call是动态绑定，是在另外一个trait或者class实现一个具体的方法之后。</li>\\n<li>所以trait中的方法必须标注: <code>abstract override</code>，以此来告诉编译器，你是故意这么来用的。</li>\\n</ol>\\n<p>用scalac编译上述源文件，生成.class文件之后，用<code>jad</code>等工具查看反编译类，会发现其实<code>MyTask with TaskLogging</code>会产生一个匿名类，继承MyTask，实现TaskLogging接口，回头再看TaskLogging中定义的<code>super.execute</code>，就能理解了，原来在调用TaskLogging.execute方法的时候的<code>this</code>，已经是匿名类的实例了，当然其super是合法的。然后其执行顺序也就能理解了。</p>\\n<p>但是这里明显有一个矛盾：从代码执行角度看，生成的匿名类是MyTask和TaskLogging的子类，这点可以通过<code>task.isInstanceOf[MyTask] &#x26;&#x26; task.isInstanceOf[TaskLogging]</code>中判断得出，但是从字面上看，在trait TaskLogging中调用<code>super.execute</code>，又给人感觉莫名其妙。可能这也是scala需要在jvm上运行所做的妥协吧。</p>\\n<h2>Stackable Actor模式</h2>\\n<p>在Akka中，这种Mixin的用法非常的有帮助，比如在对actor进行监控的时候，我们希望能记录每个actor发送消息的路径，每个actor接收消息之后处理所花费的时间、调用次数等等，如果不用这种trait mixin的话，代码将非常凌乱。</p>\\n<p>之所以单独将这个模式提出来，其实还因为这个模式中利用了PartialFunction的特性，让代码更加的优雅。看例子：</p>\\n<!-- language: scala run -->\\n<pre><code>type Receive = PartialFunction[Any, Unit]\\n\\ntrait Actor {\\n    def receive: Receive\\n    def unhandled(msg: Any): Unit = println(s\\\"unhandled message: $msg\\\")\\n}\\n\\ntrait StackableActor extends Actor {\\n    def wrapped: Receive\\n    def receive: Receive = {\\n        case x => if (wrapped.isDefinedAt(x)) wrapped(x) else unhandled(x)\\n    }\\n}\\n\\n trait LoggingActor extends StackableActor { \\n    override def wrapped: Receive = { \\n        case x => \\n            println(s\\\"start processing message: $x\\\")\\n            super.receive(x)\\n            println(\\\"end of processing message:\\\" + x) \\n    }\\n}\\n\\nclass MyActor extends StackableActor with LoggingActor {\\n    override def wrapped: Receive = {\\n        case \\\"something\\\" =>\\n            println(\\\"I can only do 'something'\\\")\\n    }\\n}\\n\\nnew MyActor() receive (\\\"something\\\")\\nnew MyActor() receive (\\\"else\\\")\\n</code></pre>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/如何在Scala中实现AOP.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2015-08-13T10:16:45.000Z\",\"path\":\"/2015/aop-by-mixin-in-scala\",\"title\":\"用Mixin组合实现Scala中的AOP\",\"excerpt\":\"在Java世界，AOP（Aspect Oriented Programming， 面向方面编程)是很多框架的基础。这种将关注点按照“方面”来切分的编程模型极大地简化了编程的复杂度，尤其是在多维度因子交织在一起的时候的各种场景。对于代码的可读性、可维护性、可重用性都是极大的帮助。\",\"tags\":[\"scala\",\"functional programming\",\"AOP\",\"mixin\"]}}},{\"node\":{\"html\":\"<p>Scala的学习过程中，经常会碰到一些莫名其妙的现象，很多时候，这些语言层面的“怪象”都与scala编译器或者scala的类型系统有关。</p>\\n<p>本文不是对编译器和类型系统的介绍，而是重点介绍遇到这些现象的时候，用什么样的方式，拨开云雾见蓝天，通过这些工具获取一些细节帮你了解编译器和类型系统如何工作。工欲善其事，必先利其器。</p>\\n<h2>REPL</h2>\\n<p>Read-Evaluate-Print-Loop, 是一个所有学习scala的同学都要掌握的工具，可以帮你快速测试一些代码，了解一些library怎么使用。</p>\\n<p>在安装scala之后，命令行下执行<code>scala</code>，就会进入REPL.</p>\\n<!-- language: bash -->\\n<pre><code>$ scala\\nWelcome to Scala version 2.11.1 (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_65).\\nType in expressions to have them evaluated.\\nType :help for more information.\\n\\nscala>\\n</code></pre>\\n<p>如果是SBT项目，可以用<code>sbt console</code>进入，之后操作类型，不再重复。</p>\\n<h3>模式</h3>\\n<p>scala REPL有<a href=\\\"http://hongjiang.info/scala-repl-modes/\\\">几种模式</a>，其中比较常用的就是<code>:paste</code>，可以比较方便的输入多行，不过要注意，拷贝粘贴的代码中，不要有Tab，否则会触发auto code completion，出现一堆错误提示。</p>\\n<h3>反射</h3>\\n<h2>命令行参数</h2>\\n<p>通过<code>man scala</code>, <code>man scalac</code>，可以了解scala都有哪些参数可用。注意的是：scala的命令行参数中import了scalac的参数，所以可以在scala命令后面使用任何scalac的参数。其中比较有用的参数有：</p>\\n<ul>\\n<li><code>-X</code>系列，用于输出高级选项概要。也就是正式支持的选项，向后兼容。</li>\\n<li><code>-Y</code>系列。用于输出私有选项信息，可能随版本变化。参见<a href=\\\"http://www.scala-lang.org/old/node/9313\\\">[6]</a><a href=\\\"http://paulbutcher.com/2010/04/26/scala-compiler-advanced-options/\\\">[7]</a></li>\\n</ul>\\n<p><code>scala -X</code>，<code>scala -Y</code>可以分别列出当前版本所支持的所有选项。</p>\\n<h2>参考</h2>\\n<ol>\\n<li><a href=\\\"http://stackoverflow.com/questions/11055210/whats-the-easiest-way-to-use-reify-get-an-ast-of-an-expression-in-scala\\\">What's the easiest way to use reify (get an AST of) an expression in Scala? stackoverflow</a></li>\\n<li><a href=\\\"http://stackoverflow.com/questions/11392622/how-to-investigate-objects-types-etc-from-scala-repl\\\">How to investigate objects/types/etc. from Scala REPL? stackoverflow</a></li>\\n<li><a href=\\\"https://www.parleys.com/tutorial/51c38751e4b0d38b54f4625e/chapter0/about\\\">Practical Type Mining in Scala ,  scaladay 2013</a></li>\\n<li><a href=\\\"http://hongjiang.info/scala-repl-modes/\\\">REPL的几种模式, hongjiang</a></li>\\n<li><a href=\\\"http://docs.scala-lang.org/overviews/reflection/symbols-trees-types.html\\\">Symbols, Trees, and Types, scalaDoc</a></li>\\n<li><a href=\\\"http://www.scala-lang.org/old/node/9313\\\">Difference between -Y and -X compiler options, scala user forum</a></li>\\n<li><a href=\\\"http://paulbutcher.com/2010/04/26/scala-compiler-advanced-options/\\\">Scala Compiler Advanced Options</a></li>\\n</ol>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Scala雾里看花.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2015-04-23T19:16:45.000Z\",\"path\":\"/2015/scala-trouble-shooting\",\"title\":\"Scala雾里看花\",\"excerpt\":\"Scala的学习过程中，经常会碰到一些莫名其妙的现象，很多时候，这些语言层面的“怪象”都与scala编译器或者scala的类型系统有关。本文不是对编译器和类型系统的介绍，而是重点介绍遇到这些现象的时候，用什么样的方式，拨开云雾见蓝天，通过这些工具获取一些细节帮你了解编译器和类型系统如何工作。工欲善其事，必先利其器。\",\"tags\":[\"scala\",\"trouble shooting\"]}}},{\"node\":{\"html\":\"<h2>Pull Mysql Docker Image</h2>\\n<!-- language: bash -->\\n<pre><code>docker pull mysql:5.6\\n</code></pre>\\n<h2>Create MySQL Config Files</h2>\\n<p>For Master, create a <code>mysql.cnf</code> file and add the following content:</p>\\n<!-- language: bash -->\\n<pre><code>[mysqld]\\n\\nserver-id = 1\\nlog_bin\\nbinlog_format = ROW\\nbind-address = 0.0.0.0\\n\\nsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES\\n</code></pre>\\n<p>For Slave, create another <code>mysql.cnf</code> and add the following content:</p>\\n<!-- language: bash -->\\n<pre><code>[mysqld]\\n\\nserver-id = 2\\nlog_bin\\nbinlog_format = ROW\\nbind-address = 0.0.0.0\\n\\nsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES\\n</code></pre>\\n<h2>Start Master/Slave MySQL Containers</h2>\\n<p>Start Master:</p>\\n<!-- language: bash -->\\n<pre><code>docker run --name master -v /my/master:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:5.6\\n</code></pre>\\n<p>Start Slave:</p>\\n<!-- language: bash -->\\n<pre><code>docker run --name slave -v /my/slave:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw --link master:master -d mysql:5.6\\n</code></pre>\\n<p>The slave node needs to link to master node.</p>\\n<h2>Setup Replication</h2>\\n<p>Check the master status:</p>\\n<!-- language: bash -->\\n<pre><code>mysql> show master status \\\\G\\n*************************** 1. row ***************************\\n             File: mysql-bin.000003\\n         Position: 120\\n     Binlog_Do_DB: \\n Binlog_Ignore_DB: \\nExecuted_Gtid_Set: \\n1 row in set (0.00 sec)\\n</code></pre>\\n<p>the above information is necessary for the slave configuration, especially the <code>File</code> and <code>Position</code>.</p>\\n<p>Connect to Slave node, in Mysql Shell:</p>\\n<!-- language: bash -->\\n<pre><code>mysql> change master to master_host='master',master_user='root',master_password='my-secret-pw',master_log_file='mysql-bin.000003',master_log_pos=120;  \\nQuery OK, 0 rows affected (0.00 sec)  \\n\\nmysql> start slave;\\nQuery OK, 0 rows affected (0.01 sec)\\n\\nmysql> show slave status\\\\G\\n\\n// until you see the following two options are 'Yes'\\nSlave_IO_Running: Yes  \\nSlave_SQL_Running: Yes  \\n</code></pre>\\n<p>You need to change the parameters like <code>master_log_file</code> and <code>master_log_pos</code> based on previous <code>show master status</code> output.</p>\\n<h2>Test</h2>\\n<p>Create some tables and insert some data on master, and check if those data are synced to slave. </p>\\n<h2>Change Data Capture (CDC)</h2>\\n<p>Here I used an open source library <a href=\\\"https://github.com/whitesock/open-replicator\\\">open-replicator</a></p>\\n<!-- language: scala -->\\n<pre><code>import com.google.code.or._\\nimport com.google.code.or.binlog._\\nimport com.google.code.or.binlog.impl.event.FormatDescriptionEvent\\n\\nval or = new OpenReplicator()\\nor.setUser(\\\"root\\\")\\nor.setPassword(\\\"my-secret-pw\\\")\\nor.setServerId(2);\\nor.setHost(\\\"slave\\\")\\nor.setPort(3306)\\nor.setBinlogPosition(120)\\nor.setBinlogFileName(\\\"mysql-bin.000004\\\")\\n\\nor.setBinlogEventListener(new BinlogEventListener() {\\n  def onEvents(event: BinlogEventV4) = {\\n\\n  }\\n})\\n\\nor.start()\\n</code></pre>\\n<p>TBD.\\nSee <code>com.linkedin.databus2.producers.ORListener</code></p>\\n<h2>References</h2>\\n<ol>\\n<li><a href=\\\"https://registry.hub.docker.com/_/mysql/\\\">Mysql Docker Official Repo</a></li>\\n<li><a href=\\\"https://github.com/linkedin/databus/wiki/Databus-for-MySQL\\\">Databus for MySQL</a></li>\\n</ol>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Docker创建MySQL主从复制以及CDC测试.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2015-04-21T07:16:45.000Z\",\"path\":\"/2015/mysql-replication-on-docker\",\"title\":\"MySQL Master/Slave Replication on Docker\",\"excerpt\":\"How to setup Mysql master/slave replication.\",\"tags\":[\"docker\",\"mysql\"]}}},{\"node\":{\"html\":\"<p>经常看到很多示例代码，简洁的让人爱不释手，可是真正自己实现的时候，不得不添加各种各样的异常处理逻辑，最后发现代码总量的80%都是再做异常处理，而真正的代码逻辑只有很少的一部分。</p>\\n<p>异常处理对于指令式和函数式编程都是同样需要的，只是因为实现方式的不同，让函数式编程看上去更加简洁，优雅，不需要像指令式那么繁琐。</p>\\n<p>本文的目的，就是介绍函数式编程中常用的一些异常处理策略。记得把这些瑞士军刀放到你的百宝箱中，以后一定用得上。</p>\\n<h2>空判断Option</h2>\\n<p>如果采访100个程序员，让所有人投票他们在编程时最讨厌做的事情，但又经常犯错误的地方，我估计十有八九会是“空判断”了。</p>\\n<p><code>Null</code>代表着一个对象还没有被初始化，具体点是对象的指针还没有一个确切的地址。在面向对象编程时，因为操作的都是对象，为了避免在一个<code>null</code>上面调用方法，或者 get一个<code>null</code>上的属性，而导致“空值异常”，程序员不得不做下面的事情：</p>\\n<p>假设有下面一个场景：</p>\\n<!-- language:uml -->\\n<pre><code>Selling --> Store\\nSelling --> Product\\n</code></pre>\\n<p>简单说，一个商场内有很多商店(Store)，每个商店卖(Selling)很多种商品(Product)，如果希望找出所有销售玩具的商店：</p>\\n<!-- language:java -->\\n<pre><code>public List&#x3C;Store> findByProductCategory(Category category) {\\n  if (category == null)               &#x3C;1>\\n    return null;\\n  List&#x3C;Product> allProducts = getAllProducts(); // DB lookup\\n  for (Product prod : allProducts) {\\n    if (prod.category == null)        &#x3C;2>\\n      continue; \\n    if (category.equals(prod.category)){\\n    \\n</code></pre>\\n<h2>参考</h2>\\n<ol>\\n<li><a href=\\\"https://tersesystems.com/2012/12/27/error-handling-in-scala/\\\">Error Handling in Scala. https://tersesystems.com/2012/12/27/error-handling-in-scala. 2012</a></li>\\n</ol>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2014/Scala函数式异常处理.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2014-05-04T07:16:45.000Z\",\"path\":\"/2014/scala-error-handling-in-fp-style\",\"title\":\"Scala函数式异常处理\",\"excerpt\":\"经常看到很多示例代码，简洁的让人爱不释手，可是真正自己实现的时候，不得不添加各种各样的异常处理逻辑，最后发现代码总量的80%都是再做异常处理，而真正的代码逻辑只有很少的一部分。\",\"tags\":[\"scala\",\"functional programming\",\"exception handling\"]}}},{\"node\":{\"html\":\"<p>译者按语：很多翻译中将Kind和Type都翻译为“类型”，但实际上两者还是有不同的，本文中，将<code>Kind</code>翻译为“种类”，取王侯将相宁有种乎之意，是骨子里的东西。而将<code>type</code>译为“类型”。</p>\\n<p>学习函数式语言如果想真正入门，一个不可避免的话题就是monad/monoid，而这些范畴论中的词汇都异常抽象，难于理解，尤其是对于从java领域转过来的同学，在很多FP的基础东西不了解情况下来研究monad就更加的困难，比如高种泛型。</p>\\n<p><code>泛型</code> 我们都知道，就是某种类型的泛化（一般化），就是将某些特殊类型进行抽象，抽出一种一般化的类型<code>T</code>。而<code>高种泛型</code>就是在泛型的基础上再进行一次抽象。</p>\\n<ul>\\n<li>\\n<p>First Order Abstraction</p>\\n<p>first-order可以理解为”单次抽象“，将特定类型抽象一次，比如类型：<code>T</code>, <code>T</code>是什么？可以是任何具体类型，String，Integer，Date等等，不难发现，这就是Java中的泛型。</p>\\n</li>\\n<li>\\n<p>Higher Order Abstraction</p>\\n<p>对应first-order的单次抽象，高阶抽象就是再次抽象，也就是说：在某个东东的抽象上再进行抽象，抽象的抽象。晕了吧！</p>\\n</li>\\n</ul>\\n<p>在继续之前，我们还得熟悉几个概念：</p>\\n<ul>\\n<li>\\n<p>值构造器</p>\\n<p>值构造器是一个function / method，接受特定值参数来构造一个特定的值(value)</p>\\n<p>值构造器可以有多态：接受不同类型的参数，也可以是抽象abstract的。</p>\\n</li>\\n<li>\\n<p>类型构造器</p>\\n<p>类型构造器是一个类型，接受一个特定类型参数来构造一个特定的类型。</p>\\n<p>和值构造器一样，类型构造器也可以有多态，这是高阶类型的关键。</p>\\n</li>\\n</ul>\\n<p>先说这么多概念有什么用呢？我们还是先看一个具体的例子。</p>\\n<h2>例子：Iterable</h2>\\n<p>观察下面代码，我们来玩个找不同的游戏：</p>\\n<!-- language:scala -->\\n<pre><code>trait Iterable[T] {\\n  def filter(p: T => Boolean): Iterable[T]\\n  def remove(p: T => Boolean): Iterable[T] = filter(x => !p(x))\\n}\\n\\ntrait List[T] extends Iterable[T] {\\n  def filter(p: T => Boolean): List[T]\\n  override def remove(p: T => Boolean): List[T] = filter(x => !p(x))\\n}\\n</code></pre>\\n<p>看到两段代码有什么不同了吗？什么代码重复了？</p>\\n<p>很容易发现：在<code>List[T]</code>中的两个方法主体结构和<code>Iterable[T]</code>中的几乎完全相同，只是返回类型不同，都期望返回自身类型。如果我们能够将返回类型也复用，那是否就可以完全去除这些重复代码呢？</p>\\n<h3>通过类型构造器多态来去除重复代码</h3>\\n<p>看下面代码：</p>\\n<!-- language:scala -->\\n<pre><code>trait Iterable[T, Container[X]] {\\n  def filter(p: T => Boolean): Container[T]\\n  def remove(p: T => Boolean): Container[T] = filter(x => !p(x))\\n}\\n\\ntrait List[T] extends Iterable[T, List]\\n</code></pre>\\n<p>这是怎么做到的？很简单，引入了<strong>类型构造器多态</strong>的概念。上面例子中：<code>Iterable[T, Container[X]]</code>的<code>Iterable</code>是类型构造器，接受两个类型参数，引入多态概念，同样的类型构造器，让其可以接受不同类型的类型参数<code>List</code>。是不是和普通方法多态没什么区别？</p>\\n<!-- language:java -->\\n<pre><code>public Iterable iterable(T t, Container&#x3C;X> container) { ... }\\npublic Iterable iterable(T t, List list) { ... }\\n</code></pre>\\n<p>因为Java的泛型没有类型构造器多态的概念，所以Java泛型无法解决上述重复代码的问题。最多只能将返回类型设为超类Iterable，然后在调用子类实现时将其强制类型转换为具体子类。</p>\\n<p>有了上面的例子为上下文，我们再来看两个概念：</p>\\n<h3>类型参数、类型成员</h3>\\n<ul>\\n<li>\\n<p>Type Parameter</p>\\n<p>类型参数，比如: <code>List[T]</code>，List具有一个类型参数<code>T</code>。这里的List就是一个类型构造器。List[Int]就是这个类型构造器接受类型参数Int之后构造的具体类型。</p>\\n</li>\\n<li>\\n<p>Type Member</p>\\n<p>类型成员，比如：<code>trait List { type T }</code></p>\\n<p>这里<code>T</code>变成了一个trait的成员（抽象的）。在List子类实现中，指定其具体类型，比如：<code>List { type T = Int }</code>。而这里的类型成员也可能参数化，比如：<code>type Container[T]</code></p>\\n<p>注意：这里的List只用来示意，并不是scala中的List实现。</p>\\n</li>\\n<li>\\n<p>Type Parameter Vs. Type Member</p>\\n<p>两者很像，只是作用范围和可见性不同:</p>\\n<ul>\\n<li>参数类型只是被参数化的类型的一部分（local，private）。</li>\\n<li>类型变量就和不同变量一样，被封装在整个body中，可以被继承，显式地引用。</li>\\n<li>两者可以相互补充。比如类型成员也可以被参数化。</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>改进Iteratable</h2>\\n<p>对于集合（collection）来说，很多方法，比如：map, flatMap, filter，各有作用，但是其实这些方法都有以下两个共同点：</p>\\n<ol>\\n<li>遍历一个集合</li>\\n<li>产生一个新的集合</li>\\n</ol>\\n<p>仔细想想，是不是所有的这些操作都满足呢？</p>\\n<ul>\\n<li>map遍历一个collection，将其中的元素变形为另外类型并产生一个新的集合。</li>\\n<li>flatMap遍历一个集合，将集合中元素转换为一个集合，并最后将“集合的集合”拉平，形成一个新的集合。</li>\\n<li>filter遍历一个集合，判断是否符合过滤条件，并返回所有符合过滤条件的新的集合。</li>\\n</ul>\\n<p>找到共同点，我们就可以将其抽象出来，进而达到复用、减少重复代码的目的。对上面两个共同点，我们可以用Iterator和Builder来进行抽象实现。</p>\\n<!-- language:scala -->\\n<pre><code>// 产生新集合\\ntrait Builder[Container[X], T] {\\n  def +=(ele: T): Unit\\n  def finalise(): Container[X]\\n}\\n// 遍历（迭代）器\\ntrait Iterator[T] {\\n  def next(): T\\n  def hasNext(): Boolean\\n  def foreach(op: T => Unit): Unit = {\\n    while(hasNext()) { op(next()) }\\n  }\\n}\\n</code></pre>\\n<p>有了这两点抽象，那我们就可以对Iteratable进行改进：</p>\\n<!-- language:scala -->\\n<pre><code>// 类型参数Container\\ntrait Buildable[Container[X]] {\\n  // build方法只是返回一个Builder\\n  def build[T]: Builder[Container[X], T]\\n}\\n\\n// Iteratable没有类型参数Container\\ntrait Iteratable[T] {\\n  // 类型成员Container\\n  type Container[X] &#x3C;: Iteratable[X]\\n  def elements: Iterator[T]\\n  \\n  def mapTo[U, C[X]](f: T => U)(b: Buildable[C]): C[U] = {\\n    val buff = b.build[U]\\n    val elems = elements\\n    while(elems.hasNext) {\\n      buff += f(elems.next)\\n    }\\n    buff.finalise\\n  }\\n  \\n  def filterTo[C[X]](f: T => Boolean)(b: Buildable[C]): C[T] = {\\n    val buff = build[T]\\n    val elems = elements\\n    while(elems.hasNext) {\\n      val elem = elems.next\\n      if (f(elem)) buff += elem\\n    }\\n    buff.finalise\\n  }\\n  \\n  def flatMapTo[U, C[X]](f: T => Iterable[U])(b: Buildable[C]): C[U] = {\\n    val buff = build[U]\\n    val elems = elements\\n    while(elems.hasNext) {\\n      f(elems.next).elements.foreach(buff += _)\\n    }\\n    buff.finalise\\n  }\\n  \\n  def map[U](f: T => U)(b: Buildable[Container]): Container[U] = mapTo[U, Container](f)(b)\\n  \\n  def filterTo(f: T => Boolean)(b: Buildable[Container]) : Container[T] =\\n    filterTo[Container](f)(b)\\n  \\n  def flatMap[U](f: T => Iteratable[U])(b: Buildable[Container]): Container[U] = \\n    flatMapTo[U, Container](f, b)\\n    \\n}\\n</code></pre>\\n<p>上面的代码中，我们用<code>Buildable</code>和<code>Iterator</code>将前文提到的两个共同点进行抽象，并在<code>Iteratable</code>的实现中，利用这两个抽象：Curried的参数<code>b: Buildable[C]</code>以及<code>def elements: Iterator[T]</code>抽象方法，分别实现了：<code>map</code>, <code>filter</code>, <code>flatMap</code>。</p>\\n<p>而Iteratable的具体实现，只需要具化上面两个抽象就可以了。比如List的实现：</p>\\n<!-- language:scala -->\\n<pre><code>object ListBuildable extends Buildable[List] {\\n  def build[T]: Builder[List, T] = new ListBuffer[T] with Builder[List, T]() {\\n    // `+=` 是scala标准库中ListBuffer的方法\\n    def finalise(): List[T] = toList\\n  }\\n}\\n\\nclass List[T] extends Iteratable[T] {\\n  type Container[X] = List[X]\\n  def elements: Iterator[T] = new Iterator {\\n    ......\\n  }\\n}\\n</code></pre>\\n<p>有了上面的实现，我们就可以利用scala的另外一个机制：implicit来实现根据类型来自动选择匹配的<code>Buildable</code>了。</p>\\n<h3>Scala标准库实现</h3>\\n<p>掌握上面的思想，我们回头再看scala标准库中collection的实现机制，就很容易理解了。scala的collection架构正是基于<code>builders</code>和<code>traversals</code>思想实现的。</p>\\n<!-- language:scala -->\\n<pre><code>package scala.collection.mutable\\nclass Builder[-Elem, +To] {\\n  def +=(elem: Elem): this.type\\n  def result(): To\\n  def clear(): Unit\\n  def mapResult[NewTo](f: To => NewTo): Builder[Elem, NewTo] = ...\\n}\\n</code></pre>\\n<p>可以看出上面的<code>result</code>方法就是：我们例子中的<code>finalise</code>，此外多了<code>clear</code>, <code>mapResult</code>两个方法。</p>\\n<p>再看看<code>Buildable</code>的实现：</p>\\n<!-- language:scala -->\\n<pre><code>package scala.collection.generic\\ntrait CanBuildFrom[-From, -Elem, +To] {\\n  // Creates a new builder \\n  def apply(from: From): Builder[Elem, To] \\n}\\n</code></pre>\\n<p>在scala中，换了个名字：<code>CanBuildFrom</code>，感觉会更贴切一些（不过从dual的角度就感觉不那么好了）。</p>\\n<p>上面的<code>apply</code>就是<code>build</code>只是多了一个参数。</p>\\n<p>再来看<code>Iteratable</code>:</p>\\n<!-- language:scala -->\\n<pre><code>package scala.collection\\nclass TraversableLike[+Elem, +Repr] {\\n  def newBuilder: Builder[Elem, Repr] // deferred\\n  def foreach[U](f: Elem => U)        // deferred\\n          ...\\n  def filter(p: Elem => Boolean): Repr = {\\n    val b = newBuilder\\n    foreach { elem => if (p(elem)) b += elem }\\n    b.result\\n  } \\n}\\n</code></pre>\\n<h3>类型参数 vs. 类型成员</h3>\\n<p>在上面的例子中，我们同时使用了类型参数和类型成员。</p>\\n<ul>\\n<li>Buildable的主要目的是构建某种类型的Container，因此使用类型参数将其显式地暴露给客户端。</li>\\n<li>对于Iterable，用户更关心的是其中包含的元素类型，而不是容器(Iterable本身就类似个容器了)，所以我们采用类型成员。</li>\\n</ul>\\n<h2>关于类型(Type)和种类(Kind)</h2>\\n<p>其实中文“类型”在这里很混淆，将英文中的两个词type、kind都翻译为“类型”了，其实是有差别的，我们这里将type翻译为\\\"类型\\\"，kind翻译为\\\"种类\\\"。</p>\\n<p>值、特定类型和种类的关系可以从下图中得到解答。</p>\\n<p><img src=\\\"http://i.stack.imgur.com/K0dwL.jpg\\\" alt=\\\"values, types and kinds的关系图\\\"></p>\\n<ul>\\n<li>特定类型是对某种特定类型的值进行分类，比如Int是对1，2，3，4等值的分类，1，2，3是值，Int是Type(类型)。</li>\\n<li>种类是对特定类型的归类，比如对Int, String, List[Int]等类型，我们进行高阶抽象，可以认为这些特定类型都是相同种类的，可以用<code>*</code>来描述。这里<code>*</code>不是用来描述任意值的，而是<em>任意一个特定类型</em>。</li>\\n<li>种类<code>K</code>可以是<code>*</code> (看下面定义)，也可以是<code>K → K</code>，其中<code>→</code>是<em>种类构造器</em>，用来构造一个<strong>用于归纳类型构造器的种类</strong>，绕口吧，简单地说就是<code>K → K</code>接受一个种类参数，返回一个新的种类.</li>\\n</ul>\\n<h3>Kind的定义</h3>\\n<pre><code>Kind ::= '*(' Type ',' Type ')' | [id '@' ] Kind '→' Kind\\n</code></pre>\\n<p><code>*(T, U)</code>种类中<code>T</code>用来描述类型下边界(lower bound)，<code>U</code>为类型上边界(upper bound)。在Scala中，最低边界是<code>Nothing</code>因为它使一切类型的子类，最高边界是<code>Any</code>，它使所有类型的超类。因为我们经常使用upper bound, 所以，我们用<code>*(Nothing, U)</code>，简化为<code>*(U)</code>来描述一个种类，特别地，<code>*(Nothing, Any)</code>可以简化为<code>*</code>。</p>\\n<p>上文的几个例子：</p>\\n<table>\\n<thead>\\n<tr>\\n<th align=\\\"center\\\">Scala 类型定义</th>\\n<th align=\\\"center\\\">Kind 定义</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td align=\\\"center\\\">Container\\n[\\nX\\n]</td>\\n<td align=\\\"center\\\">*\\n → \\n*</td>\\n</tr>\\n<tr>\\n<td align=\\\"center\\\">Pair\\n[\\nT, U\\n]</td>\\n<td align=\\\"center\\\">*\\n → \\n*\\n → \\n*</td>\\n</tr>\\n<tr>\\n<td align=\\\"center\\\">Container\\n[\\nX\\n]\\n &#x3C;: Iterable\\n[\\nX\\n]</td>\\n<td align=\\\"center\\\">X @ \\n*\\n → \\n*\\n(Iterable\\n[\\nX\\n]\\n)</td>\\n</tr>\\n<tr>\\n<td align=\\\"center\\\">C[X &#x3C;: Ordered\\n[\\nX\\n]\\n] &#x3C;: Iterable\\n[\\nX\\n]</td>\\n<td align=\\\"center\\\">X @ \\n*\\n(Ordered\\n[\\nX\\n]\\n) → \\n*\\n(Iterable\\n[\\nX\\n]\\n)</td>\\n</tr>\\n</tbody>\\n</table>\\n<p>有了Kind定义，我们就可以通过其进行Kind推导，比如<code>T</code>的种类是<code>X @ K → K'</code>，如果<code>U</code>的Kind是<code>K</code>，那么很简单的通过替换，我们就可以知道<code>T[U]</code>的Kind是<code>K'</code>。</p>\\n<h3>子种类Subkinding</h3>\\n<p>scala中，我们通过<code>&#x3C;:</code>或者<code>>:</code>来表述两个类型（type）之间的关系。比如：<code>Int &#x3C;: Number</code>。</p>\\n<p>对于种类，我们可以重载<code>&#x3C;:</code> and <code>>:</code>，用来描述两个种类之间的关系。比如：<code>*(T, U) &#x3C;: *(T', U')</code>，当且仅当：<code>T' &#x3C;: T</code> AND <code>U &#x3C;: U'</code>时上述关系成立。这个相对容易理解，因为<code>T</code>/<code>T'</code>是类型参数，和方法参数一样，是逆变(contravariance)的。</p>\\n<p>scala编译器正是通过应用这些规则来进行type/kind检查的。比如，scala编译器将对下面代码报错：</p>\\n<!-- language:scala run -->\\n<pre><code>class Iterable[Container[X], T]\\ntrait NumericList[T &#x3C;: Number] extends Iterable[NumericList, T]\\n</code></pre>\\n<p>你可以点击<code>run</code>按钮试试，看看编译会出现什么结果。</p>\\n<p>之所以报错，是因为<code>Iterable[NumericList, T]</code>的问题。我们可以应用上面学到的subkinding来分析一下。</p>\\n<p><code>NumericList[T &#x3C;: Number]</code>的种类是：<code>*(Number) → *</code>，很显然，它必须是<code>Iterable</code>的第一个类型参数<code>NumericList</code>的子种类， 也就是：<code>*(Number) → * &#x3C;: * → *</code>。在<code>→</code>左边的是种类参数，是逆变的(contravariant)，所以这里我们需要：<code>* &#x3C;: *(Number)</code>，但是这显然是不成立的。所以scala编译器会报错：<code>type T's bounds &#x3C;: Number are stricter than type X's declared bounds >: Nothing &#x3C;: Any</code>。</p>\\n<p>OK then, how to make it work ? 我们需要引入一个新的类型参数：Bound</p>\\n<!-- language:scala run -->\\n<pre><code>class Iterable[Container[X &#x3C;: Bound], T &#x3C;: Bound, Bound]\\ntrait NumericList[T &#x3C;: Number] extends Iterable[NumericList, T, Number]\\n</code></pre>\\n<p><code>Iterable[Container[X &#x3C;: Bound], T &#x3C;: Bound, Bound]</code>的种类是：<code>*(Bound) → * → *(Bound) → * → *</code></p>\\n<p><code>NumericList[T &#x3C;: Number]</code>的种类是：<code>*(Number) → *</code>，该种类必须是<code>Iterable</code>第一个参数的子种类，也就是：<code>*(Number) → * &#x3C;: *(Bound) → *</code>，而<code>Bound</code>已经指定为<code>Number</code>，经过替换，就有了：<code>*(Number) → * &#x3C;: *(Number) → *</code>，左右两边相同，自然是满足要求了。</p>\\n<h3>高种类型</h3>\\n<p>如果你使用scala 2.11.x版本，在REPL中，就可以通过<code>:type</code>来查看一个类型的种类（Kind）了。比如：</p>\\n<!-- language:scala run -->\\n<pre><code>scala> :kind -v List\\nscala.collection.immutable.List's kind is F[+A]\\n* -(+)-> *\\nThis is a type constructor: a 1st-order-kinded type.\\n\\nscala> :kind -v Pair[_, _]\\nscala.Tuple2's kind is F[+A1,+A2]\\n* -(+)-> * -(+)-> *\\nThis is a type constructor: a 1st-order-kinded type.\\n</code></pre>\\n<p>可以看到，两者的类型一个是：<code>* → *</code> 另外一个是 <code>* → * → *</code>，而且，两个都是：<code>1st-order-kinded type</code>。那怎么才算是一个<code>higher order kinded type</code>呢？</p>\\n<p>在上面的图中:<code>Functor[List]</code>是<code>higher order kinded type</code>: <code>(* → *) → *</code>，这个和<code>Pair[_, _]</code>的<code>* → * → *</code>相比，不就多了个括号吗？玄机就再这个括号上：<code>(* → *) → *</code>表示你接受一个一阶类型* → *，然后产生一个最终的类型。类型的类型，所以是高阶类型。</p>\\n<h2>Implicit机制</h2>\\n<p><code>implicit</code>是scala中一个很强大的东西，其主要出发点是“偷懒”，没错，就是偷懒，让程序员可以偷懒，将本来应该码农干的活交给“编译器”完成。</p>\\n<p>implicit能帮我们码农的有两个地方：隐式参数和隐式转换。</p>\\n<h3>隐式参数</h3>\\n<p>具体来说，就是你可以将一个方法调用的参数（显式注为implicit）省略掉，编译器会在当前上下文中找能用于补充缺失掉参数的值，如果能找到，就自动填充，找不到就会在编译时报错。比如下面例子：</p>\\n<!-- language:scala run -->\\n<pre><code>def foo[T](t: T)(implicit integral: Integral[T]) = { println(integral) }\\nfoo(1)\\n</code></pre>\\n<p>注意<code>foo(1)</code>中只提供了第一个参数，一个<code>Int</code>值，但是第二个参数被省略了，scala编译器就会查找当前scope中有没有类型为<code>Integral[Int]</code>的<code>implicit</code>值。很幸运，scala.math.Numeric中定义了<code>implicit object IntIsIntegral extends IntIsIntegral with Ordering.IntOrdering</code>，所以编译器会找到<code>IntIsIntegral</code>对象然后自动补充第二个参数。</p>\\n<p>那我们再试一下<code>foo(1.0)</code>，这个时候，编译器会报错。为什么呢？查查scala.math.Numeric源码，我们就会发现：scala为Double提供了implicit Fractional对象，make sense，double不是整数嘛。同时scala还是提供了一个对象<code>DoubleAsIfIntegral</code>，但并没有标记为<code>implicit</code>，所以编译器找不到。了解了原因，简单做如下改动：</p>\\n<!-- language:scala run -->\\n<pre><code>def foo[T](t: T)(implicit integral: Integral[T]) = { println(integral) }\\nfoo(1)\\nimplicit val doubleAsIfIntegral = scala.math.Numeric.DoubleAsIfIntegral\\nfoo(1.0)\\n</code></pre>\\n<p>现在大家都happy了。</p>\\n<p>你可以通过<code>implicitly[Integral[Double]]</code>来自行查找是否有符合条件的隐式参数。</p>\\n<h3>隐式转换</h3>\\n<p>implicit的另外一个作用是隐式转换，同样也是帮助码农的。具体讲，就是当你在调用某个方法在某个对象上的时候，如果这个对象的类A并没有定义这个方法，scala的编译器先不会报错，会尝试着在当前scope中查找：</p>\\n<ol>\\n<li>具有该方法定义的类型 B</li>\\n<li>能够将A转换为B的转换器</li>\\n</ol>\\n<p>如果能找到，那么scala将自动进行上述转换，找不到，报错。例如：</p>\\n<!-- language:scala -->\\n<pre><code>\\\"123\\\".map(_.toInt)\\n</code></pre>\\n<p><code>\\\"123\\\"</code>是一个<code>java.lang.String</code>类型，String上并没有定义<code>map</code>方法，但是编译器也没有报错，而且顺利执行了。这就是隐式转换：scala编译器会在上下文中找到<code>implicit def augmentString(x: String): StringOps = new StringOps(x)</code>，可以将<code>String</code>转换为有<code>map</code>定义的<code>StringOps</code>。</p>\\n<p>你可以通过<code>implicitly[String => StringOps]</code>进行自行查找符合条件的转换器。</p>\\n<p>基于隐式参数和隐式转换，在Scala的类型系统中，有两个语法糖：view bound (CC &#x3C;% Seq[T]) 和 context bound (T : Integral)。</p>\\n<h3>View Bounds</h3>\\n<p>说实话不知道这个翻译为什么好，在微博上和几位国内scala大牛们探讨过，一些人认为应该直译为：“视界”，我自己倒是觉得应该叫“化界”？因为：</p>\\n<ol>\\n<li>“视界”，可见到的边界，太笼统，含义模糊，“化界”顾名思义，可“转化到的边界”</li>\\n<li>化界听上去比较炫，像是玄幻小说中很高深的境界，^_^</li>\\n</ol>\\n<p>You can think of <code>T &#x3C;% Ordered[T]</code> as saying, “I can use any T, so long as T can be treated as an Ordered[T].” This is different from saying that T is an Ordered[T], which is what an upper bound, <code>T &#x3C;: Ordered[T]</code>, would say.</p>\\n<p>有时候隐式参数和隐式转换可以同时存在、起作用，比如下面代码：</p>\\n<!-- language:scala run -->\\n<pre><code>def getIndex[T, CC](seq: CC, value: T)(implicit converter: CC => Seq[T]) = seq.indexOf(value)\\n\\ngetIndex(\\\"abcde\\\", 'c')\\ngetIndex(List(1,3,2,5), 3)\\n</code></pre>\\n<p>上面代码中<code>CC</code>可以是任何能转换为<code>Seq</code>的类型，所以<code>String</code>和<code>List</code>都可以应用。</p>\\n<p>首先，<code>converter</code>是一个隐式参数，其次，因为<code>seq</code>对象的类型是<code>CC</code>，其上面并没有定义<code>indexOf</code>方法，所以“隐式转换”介入。</p>\\n<p>事实上，这个用法非常普遍，所以scala专门为其提供了一个语法糖：view bound <code>CC &#x3C;% Seq[T]</code>，重写上面代码：</p>\\n<!-- language:scala run -->\\n<pre><code>def getIndex[T, CC &#x3C;% Seq[T]](seq: CC, value: T) = seq.indexOf(value)\\n</code></pre>\\n<p>运行上面代码，你可以从输出看到scala编译器会将方法重新定义为：<code>getIndex: [T, CC](list: CC, value: T)(implicit evidence$1: CC => Seq[T])Int</code>，和第一种方法一样。</p>\\n<h3>Context Bounds</h3>\\n<p>再看下面一个例子：</p>\\n<!-- language:scala run -->\\n<pre><code>def sum[T](list: List[T])(implicit integral: Integral[T]): T = {\\n    import integral._   // get the implicits in question into scope\\n    list.foldLeft(integral.zero)(_ + _)\\n}\\n</code></pre>\\n<p>这里有一个隐式参数<code>integral</code>类型为<code>Integral[T]</code>，如果方法传入<code>Int</code>，那么scala编译器就会找<code>implicitly[Integral[Int]]</code>，这个我们在隐式参数小节已经说过了。</p>\\n<p>这里主要关注另外一个问题：<code>list.foldLeft(integral.zero)(_ + _)</code>，其中<code>_</code>的类型应该是<code>T</code>，但是<code>T</code>上面有定义<code>+</code>方法吗？我们先把<code>import integral._</code>去掉，就会发现编译出错：</p>\\n<!-- language:scala -->\\n<pre><code>&#x3C;console>:8: error: type mismatch;\\n found   : T\\n required: String\\n           list.foldLeft(integral.zero)(_ + _)\\n                                        ^\\n</code></pre>\\n<p>原来scala编译器尝试着将<code>T</code>转换为<code>String</code>了，这里应该是<code>Predef.any2string</code>起了作用。</p>\\n<p>加上<code>import integral._</code>，一切工作了。</p>\\n<p>回头想一下，其实挺有意思的：我们给一个泛型<code>T</code>动态地添加了<code>+</code>方法，但是并不改变<code>T</code>的代码。而这就是context bound的意义。</p>\\n<p>这个在流行框架<code>Scalaz</code>中应用非常广泛。scala同样为其创建了专门的语法糖：<code>[T : Ordering]</code>。采用语法糖，这个例子可以重写为：</p>\\n<!-- language:scala run -->\\n<pre><code>def sum[T : Integral](list: List[T]): T = {\\n  val integral = implicitly[Integral[T]]\\n  import integral._\\n  list.foldLeft(integral.zero)(_ + _)\\n}\\n</code></pre>\\n<p>编译器编译之后，会生成一个<code>sum: [T](list: List[T])(implicit evidence$1: Integral[T])T</code>的方法。</p>\\n<p>这里有点让人confusing的地方是：<code>T: Integral</code>的写法感觉像是说：<code>T</code>是<code>Integral</code>的类型，就像：<code>m: T</code>，可实际上应该认为是：<code>T</code>在<code>Integral</code>的<code>Context</code>中。</p>\\n<h2>结束语</h2>\\n<p>scala的类型系统确实是一个难点，但同时也是要真正掌握scala语言所必须的知识点。很多概念都很晦涩，对于像我们这些凡人，要想掌握没有太好的办法，只能多看、多练、多想。</p>\\n<h2>参考</h2>\\n<ol>\\n<li><a href=\\\"http://stackoverflow.com/questions/6246719/what-is-a-higher-kinded-type-in-scala\\\">Adriaan Moors. What is a higher kinded type in scala. StackOverflow. http://stackoverflow.com/questions/6246719/what-is-a-higher-kinded-type-in-scala. 2011</a></li>\\n<li><a href=\\\"http://docs.scala-lang.org/overviews/core/architecture-of-scala-collections.html\\\">Martin Odersky and Lex Spoon. Architecture of Scala Collection. scala-lang website. http://docs.scala-lang.org/overviews/core/architecture-of-scala-collections.html. 2013</a></li>\\n<li><a href=\\\"http://stackoverflow.com/questions/5598085/where-does-scala-look-for-implicits\\\">Daniel C. Sobral. Types of Implicits. StackOverflow. http://stackoverflow.com/questions/5598085/where-does-scala-look-for-implicits. 2011</a></li>\\n<li><a href=\\\"http://blogs.atlassian.com/2013/09/scala-types-of-a-higher-kind/\\\">Jed Wesley-Smith. Scala Types Of a Higher Kind. http://blogs.atlassian.com/2013/09/scala-types-of-a-higher-kind/</a></li>\\n</ol>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2014/高种泛型.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2014-01-08T19:16:45.000Z\",\"path\":\"/2014/generics-of-a-higher-kind\",\"title\":\"高种泛型 (Generics of a Higher Kind)\",\"excerpt\":\"Generics of a Higher Kind翻译加自我理解。\",\"tags\":[\"scala\",\"functional programming\",\"Generics\"]}}}],\"pathPrefix\":\"/\",\"first\":true,\"last\":false,\"index\":1,\"pageCount\":2}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/index.json\n// module id = 364\n// module chunks = 60335399758886","module.exports = {\"layoutContext\":{}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/layout-index.json\n// module id = 109\n// module chunks = 60335399758886 114276838955818"],"sourceRoot":""}