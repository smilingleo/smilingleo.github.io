webpackJsonp([0x81b8806e4260],{398:function(e,n){e.exports={data:{allMarkdownRemark:{totalCount:21,edges:[{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2018/为Gatsby博客添加分页功能.md absPath of file >>> MarkdownRemark",frontmatter:{title:"为Gatsby博客添加分页功能",date:"March 12, 2018",path:"/2018/support-pagination-for-gatsby-blog",tags:["blog","gatsby"],excerpt:"根据Egghead上的教程，做出的博客站点有个缺陷，那就是没有分页功能，对于勤奋的博主来说，在一个页面上显示所有文章列表有点不完美，这里我们改造一下，加入分页功能。"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2018/为你的Gatsby博客添加评论功能.md absPath of file >>> MarkdownRemark",frontmatter:{title:"为你的Gatsby博客添加评论功能",date:"March 12, 2018",path:"/2018/enable-comments-for-gatsby-blog",tags:["blog"],excerpt:"Gatsby打造的博客已经很不错了，但是缺少一个评论功能。本文简单介绍如何集成Disqus评论服务到你的博客站点。"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2018/转用Gatsby搭建博客.md absPath of file >>> MarkdownRemark",frontmatter:{title:"转用Gatsby打造基于github的博客站点",date:"March 08, 2018",path:"/2018/blog-with-gatsby",tags:["blog","github","gatsby"],excerpt:"如何用Gatsby打造一个博客"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2018/一则奇怪的Toubleshooting.md absPath of file >>> MarkdownRemark",frontmatter:{title:"记一次奇怪的troubleshooting",date:"March 08, 2018",path:"/2018/skipper-sni-domain-fronting",tags:["skipper","SNI","domain fronting"],excerpt:"在Skipper转发请求到一个https站点的时候，返回莫名404."}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2016/JSON解析利器JQ.md absPath of file >>> MarkdownRemark",frontmatter:{title:"JSON解析利器---JQ",date:"March 25, 2016",path:"/2013/jq",tags:["bash","jq","json"],excerpt:"在API first的时代，json作为最常用的格式，充斥着程序猿的屏幕各个角落，掌握一门解析、过滤、转换json输出的工具，已经成为程序猿们安身立命的必要技能。 这里隆重向大家介绍[jq](https://stedolan.github.io/jq/)."}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2016/Function的协变.md absPath of file >>> MarkdownRemark",frontmatter:{title:"Function的协、逆变",date:"February 04, 2016",path:"/2016/function-covariant-contravariant",tags:["scala","functional programming"],excerpt:"泛型编程的时候，协变(covariant)还是逆变(contravariant)很重要，在设计上层API接口的时候，正确的使用协变、逆变可以更好地约束程序员的行为，让实现变得安全、一致。"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2015/如何在Scala中实现AOP.md absPath of file >>> MarkdownRemark",frontmatter:{title:"用Mixin组合实现Scala中的AOP",date:"August 13, 2015",path:"/2015/aop-by-mixin-in-scala",tags:["scala","functional programming","AOP","mixin"],excerpt:"在Java世界，AOP（Aspect Oriented Programming， 面向方面编程)是很多框架的基础。这种将关注点按照“方面”来切分的编程模型极大地简化了编程的复杂度，尤其是在多维度因子交织在一起的时候的各种场景。对于代码的可读性、可维护性、可重用性都是极大的帮助。"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Scala雾里看花.md absPath of file >>> MarkdownRemark",frontmatter:{title:"Scala雾里看花",date:"April 23, 2015",path:"/2015/scala-trouble-shooting",tags:["scala","trouble shooting"],excerpt:"Scala的学习过程中，经常会碰到一些莫名其妙的现象，很多时候，这些语言层面的“怪象”都与scala编译器或者scala的类型系统有关。本文不是对编译器和类型系统的介绍，而是重点介绍遇到这些现象的时候，用什么样的方式，拨开云雾见蓝天，通过这些工具获取一些细节帮你了解编译器和类型系统如何工作。工欲善其事，必先利其器。"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Docker创建MySQL主从复制以及CDC测试.md absPath of file >>> MarkdownRemark",frontmatter:{title:"MySQL Master/Slave Replication on Docker",date:"April 21, 2015",path:"/2015/mysql-replication-on-docker",tags:["docker","mysql"],excerpt:"How to setup Mysql master/slave replication."}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2014/Scala函数式异常处理.md absPath of file >>> MarkdownRemark",frontmatter:{title:"Scala函数式异常处理",date:"May 04, 2014",path:"/2014/scala-error-handling-in-fp-style",tags:["scala","functional programming","exception handling"],excerpt:"经常看到很多示例代码，简洁的让人爱不释手，可是真正自己实现的时候，不得不添加各种各样的异常处理逻辑，最后发现代码总量的80%都是再做异常处理，而真正的代码逻辑只有很少的一部分。"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2014/高种泛型.md absPath of file >>> MarkdownRemark",frontmatter:{title:"高种泛型 (Generics of a Higher Kind)",date:"January 08, 2014",path:"/2014/generics-of-a-higher-kind",tags:["scala","functional programming","Generics"],excerpt:"Generics of a Higher Kind翻译加自我理解。"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2013/map-flatMap-for.md absPath of file >>> MarkdownRemark",frontmatter:{title:"map/flatMap/for in Action",date:"December 01, 2013",path:"/2013/map-flatmap-for",tags:["scala","functional programming"],excerpt:"前文说过了，高阶函数式函数式语言中的基石，而`map`, `flatMap`更是重要。"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2013/fold编程.md absPath of file >>> MarkdownRemark",frontmatter:{title:"折纸的艺术：fold编程",date:"November 27, 2013",path:"/2013/fold",tags:["scala","functional programming","fold"],excerpt:"Eric Meijer说：递归是函数式编程的GOTO，应该尽可能避免。如何避免，OO中我们用while循环，FP中我们用`fold`。"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Monad.md absPath of file >>> MarkdownRemark",frontmatter:{title:"Monad",date:"November 26, 2013",path:"/2013/monad",tags:["scala","functional programming","monad"],excerpt:"函数式语言与OO（确切地讲是指令式编程）的思维方式是完全不同的，很多OO中的经验在函数式语言中不是很匹配，比如设计模式，那就是一个OO中的特定术语，而在FP中，大家常谈的是对于习惯OO思维的程序员来说玄而又玄的Monad。"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2013/高阶函数.md absPath of file >>> MarkdownRemark",frontmatter:{title:"高阶函数",date:"November 21, 2013",path:"/2013/high-order-function",tags:["scala","functional programming","high order function"],excerpt:"所谓高阶函数（high order function），其实就是可以接受其他函数作为参数的函数。"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Actor协调并发场景下的集合操作.md absPath of file >>> MarkdownRemark",frontmatter:{title:"边建边学-3：Actor协调并发场景下的集合操作",date:"November 17, 2013",path:"/2013/actor-collection-collabration",tags:["scala","functional programming"],excerpt:"很多时候为了提高性能，减少IO操作，都会将数据load出来之后缓存在内存中。本站的实现过程中也遇到类似的问题，不希望每次有人访问的时候就读取一次md文件，或者从MongoDB中查一次，而是直接在内存中读取。"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Enumerator-Iteratee-Enumeratee.md absPath of file >>> MarkdownRemark",frontmatter:{title:"Enumerator / Iteratee / Enumeratee",date:"November 11, 2013",path:"/2013/enumerator-iteratee-enumeratee",tags:["scala","playframework","blog"],excerpt:"Stream对于指令式编程已经比较成熟了，有大量的类库，丰富的API。但是对于强调不可变量，尽可能无副作用的FP来说，要考虑语言适配的问题，而目前，流行的解决方案就是：Enumerator/Iteratee。"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2013/集成PlantUML和Markdown.md absPath of file >>> MarkdownRemark",frontmatter:{title:"边建边学-2：集成PlantUML和Markdown",date:"November 07, 2013",path:"/2013/markdown-plantuml-integration",tags:["markdown","plantuml","blog"],excerpt:"如何用Markdown+PlantUML结合来写图文并茂的博客。"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2013/EssentialAction-in-Playframework.md absPath of file >>> MarkdownRemark",frontmatter:{title:"EssentialAction in Playframework",date:"November 05, 2013",path:"/2013/essential-action-in-play",tags:["scala","playframework"],excerpt:"Playframework中EssentialAction理解"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2013/用markdown写博客.markdown absPath of file >>> MarkdownRemark",frontmatter:{title:"边建边学-1: 用Markdown写博文",date:"November 01, 2013",path:"/2013/blogging-with-markdown",tags:["markdown","blog"],excerpt:"本文将是一个系列文章，循序渐进地介绍本站的构建过程，不只是简单的技术介绍，重点是建站过程遇到的问题分析，以及解决的过程，所以起名**“边建边学”**系列。"}}},{node:{id:"/Users/lliu/github/smilingleo.github.io/src/pages/2013/开篇.md absPath of file >>> MarkdownRemark",frontmatter:{title:"开篇",date:"October 25, 2013",path:"/2013/start",tags:[],excerpt:"网络博客"}}}]}},pathContext:{group:[{node:{html:'<p>根据Egghead上的教程，做出的博客站点有个缺陷，那就是没有分页功能，对于勤奋的博主来说，在一个页面上显示所有文章列表有点不完美，这里我们改造一下，加入分页功能。</p>\n<h2>步骤</h2>\n<ol>\n<li>引入<code>gatsby-paginate</code>组件</li>\n</ol>\n<pre><code class="language-bash">yarn add gatsby-paginate\n</code></pre>\n<ol start="2">\n<li>增加一个分页链接组件</li>\n</ol>\n<!-- language: lang-js -->\n<pre><code>import React from \'react\'\nimport Link from \'gatsby-link\'\n\nconst PaginateLink = ({ tag, url, text }) => {\n    if (!tag) {\n        return &#x3C;span>&#x3C;Link to={ url }>{ text }&#x3C;/Link>&#x3C;/span>\n    } else {\n        return &#x3C;span>{ text }&#x3C;/span>\n    }\n}\n\nexport default PaginateLink\n</code></pre>\n<ol start="3">\n<li><code>mv pages/index.js templates/</code> 然后编辑</li>\n</ol>\n<!-- language: lang-js -->\n<pre><code>import React from \'react\'\nimport Link from \'gatsby-link\'\n+import PaginateLink from \'./paginateLink\'\n+\n+const IndexPage = ({ data, pathContext }) => {\n+  // for pagination\n+  const { group, index, first, last } = pathContext;\n+  const prevUrl = index - 1 == 1 ? "" : (index - 1).toString();\n+  const nextUrl = (index + 1).toString();\n+  const total = data.allMarkdownRemark.edges.length;\n\n-const IndexPage = ({ data }) => {\nconst { edges: posts } = data.allMarkdownRemark\nreturn (\n    &#x3C;div>\n-      {posts.map(({ node: post }, pIdx) => {\n+      &#x3C;div className="posts">\n+      {group.map(({ node: post }, pIdx) => {\n        const { frontmatter } = post\n-        \n+\n        return (\n        &#x3C;div key={`post_${pIdx}`}>\n            &#x3C;h2>\n@@ -27,6 +35,18 @@ const IndexPage = ({ data }) => {\n        &#x3C;/div>\n        )\n    })}\n+      &#x3C;/div>\n+      &#x3C;div className="paginatation">\n+        &#x3C;div className="prevLink">\n+            &#x3C;PaginateLink tag={ first } url={ prevUrl } text="Prev Page" />\n+        &#x3C;/div>\n+\n+        &#x3C;p>{index} of { Math.ceil(total/12)}&#x3C;/p>\n+\n+        &#x3C;div className="nextLink">\n+            &#x3C;PaginateLink tag={ last } url={ nextUrl } text="Next Page" />\n+        &#x3C;/div>\n+      &#x3C;/div>      \n    &#x3C;/div>\n)\n}\n</code></pre>\n<ol start="4">\n<li>编辑<code>gatsby-node.js</code></li>\n</ol>\n<!-- language: lang-js -->\n<pre><code>+const pagination = require(\'gatsby-paginate\');\n\nconst createTagPages = (createPage, posts) => {\nconst tagPageTemplate = path.resolve(`src/templates/tags.js`)\n@@ -72,6 +73,15 @@ exports.createPages = ({ boundActionCreators, graphql }) => {\n\n    createTagPages(createPage, posts)\n\n+      // default pagination to 10.\n+      pagination({\n+        edges: posts,\n+        createPage: createPage,\n+        pageTemplate: "src/templates/index.js",\n+        pageLength: 10\n+      });\n+\n+\n    posts.forEach(({node}, index) => {\n        createPage({\n        path: node.frontmatter.path,\n</code></pre>\n<ol start="5">\n<li>编辑样式</li>\n<li>重新发布<code>yarn deploy</code></li>\n</ol>',id:"/Users/lliu/github/smilingleo.github.io/src/pages/2018/为Gatsby博客添加分页功能.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2018-03-12T11:31:26.000+08:00",path:"/2018/support-pagination-for-gatsby-blog",title:"为Gatsby博客添加分页功能",excerpt:"根据Egghead上的教程，做出的博客站点有个缺陷，那就是没有分页功能，对于勤奋的博主来说，在一个页面上显示所有文章列表有点不完美，这里我们改造一下，加入分页功能。",tags:["blog","gatsby"]}}},{node:{html:"<p>Gatsby打造的博客已经很不错了，但是缺少一个评论功能。</p>\n<p>本文简单介绍如何集成Disqus评论服务到你的博客站点。</p>\n<h2>How To</h2>\n<p>首先，添加<code>react-disqus-thread</code>组件。</p>\n<pre><code>yarn add react-disqus-thread\n</code></pre>\n<p>之后，新建一个<code>Comments</code>的React组件。</p>\n<!-- language: lang-js -->\n<pre><code>const React = require('react');\nconst ReactDisqusThread = require('react-disqus-thread');\n\nclass Comments extends React.Component{\n\n    constructor(props) {\n        super(props);\n    }\n    \n    handleNewComment (comment) {\n        \n    }\n\n    render () {\n        const id = `smilingleo/${window.location.pathname}`;\n        return (\n            &#x3C;ReactDisqusThread\n                shortname=\"smilingleo\"\n                identifier={id}\n                title={this.props.title}\n                onNewComment={this.handleNewComment}/>\n        );\n    }\n};\n\nexport default Comments;\n</code></pre>\n<p>注意:</p>\n<ul>\n<li><code>identifier</code>需要是唯一的，这里我用了<code>smilingleo</code>作为前缀，加上<code>pathname</code>。</li>\n<li><code>onNewComment</code>的响应函数中，可以做一些有意思的东西，比如给你的IM发一条消息，尝试了Slack Webhook，可惜不支持CORS.</li>\n</ul>\n<p>最后，在<code>templates/blog-post.js</code>文件中添加：</p>\n<!-- language: lang-html -->\n<pre><code>&#x3C;hr />\n&#x3C;Comments title={title} />\n</code></pre>\n<p>搞定.</p>\n<h2>References</h2>\n<ol>\n<li><a href=\"https://github.com/mzabriskie/react-disqus-thread\">React Disqus thread component</a></li>\n</ol>",id:"/Users/lliu/github/smilingleo.github.io/src/pages/2018/为你的Gatsby博客添加评论功能.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2018-03-12T10:07:43.000+08:00",path:"/2018/enable-comments-for-gatsby-blog",title:"为你的Gatsby博客添加评论功能",excerpt:"Gatsby打造的博客已经很不错了，但是缺少一个评论功能。本文简单介绍如何集成Disqus评论服务到你的博客站点。",tags:["blog"]}}},{node:{html:'<h2>起因</h2>\n<p>原来的博客站点基于Jekyll搭建，各种问题，感觉很不爽。后来看到Gatsby，基于ReactJS, GraphQL，都是我的最爱，于是果断投诚！</p>\n<h2>遇到的问题</h2>\n<h3>和prettyprint集成的问题</h3>\n<p>原来的prettyprint机制是在页面加载的时候调用<code>init()</code>，检查DOM中的<code>pre.code</code>元素。但是转到React之后，全部是前端Routing，原来写的<code>window.onload = init</code>不工作了。每次都要手动刷新。</p>\n<p>解决办法是在Gatsby Link元素的<code>onClick</code>事件中注册一个timer:</p>\n<!-- language: js -->\n<pre><code>&#x3C;Link to={frontmatter.path} onClick={() => setTimeout(init, 100)}>{frontmatter.title}&#x3C;/Link>\n</code></pre>\n<p>这样，在点击链接打开页面之后，就会调用<code>init</code>了。</p>\n<p><strong>更新：</strong>\n上面的方法更像是一个Hack，因为毕竟Link的目的只是指向一个target，不应该把不属于Link的职责(解析页面DOM并设置pre.code的style)绑定到Link上。</p>\n<p>重新思考了一下之后，重构了<code>templates/blog-post.js</code>，原来的<code>Template</code>是一个ES6箭头函数，因为我们希望的是在页面组件都Mount之后，调用<code>init</code>，所以，我们将其修改为一个扩展<code>React.Component</code>的class.</p>\n<!-- language:lang-js -->\n<pre><code>class Template extends React.Component {\n    constructor(props) {\n        super(props);\n    }\n    \n    /*\n    * Once the blog page is loaded, run init() to prettyprint the code.\n    */\n    componentDidMount() {\n        init();\n    }\n\n    render() {\n        const { markdownRemark: post } = this.props.data\n        const { frontmatter, html } = post\n        const { title, date } = frontmatter\n        const { next, prev } = this.props.pathContext\n    \n        return (\n            ...\n        )  \n    }\n}\n</code></pre>\n<p>这样，就达到目的了。</p>\n<h3>发布方法</h3>\n<p>原来以为是将这些源码直接push到 <code>smilingleo.github.io</code>，后来发现不对。</p>\n<p>需要有两个github repos，一个 <code>my-blog-code</code>, 另外一个 <code>smilingleo.github.io</code>。</p>\n<p>新的博文写完之后，需要<code>yarn deploy</code>，这样会发布到<code>public/</code>，然后将<code>public</code>目录指向<code>smilingleo.github.io</code>这个repo。</p>\n<p>所以，一篇博客需要提交两个git repos。</p>\n<h3>date格式问题</h3>\n<p>原来用Jekyll的时候，date可以是<code>YYYY-MM-dd HH:mm:ss</code>的格式，但是用Gatsby必须是<code>YYYY-MM-dd\'T\'HH:mm:ss</code>。</p>\n<h2>参考资料</h2>\n<ol>\n<li><a href="https://egghead.io/courses/build-a-blog-with-react-and-markdown-using-gatsby">Egghead教程</a></li>\n<li><a href="https://stackoverflow.com/questions/37170809/react-createclass-vs-es6-arrow-function/37170998#37170998">React.createClass vs. ES6 arrow function</a></li>\n</ol>\n<p>In summary:</p>\n<p>The short answer is that you want to use Stateless Functional Components (SFC) as often as you can; the majority of your components should be SFC\'s.</p>\n<p>Use the traditional Component class when:</p>\n<p>You need local state (<code>this.setState</code>)\nYou need a lifecycle hook (<code>componentWillMount</code>, <code>componentDidUpdate</code>, etc)\nYou need to access backing instances via refs (eg. <code>&#x3C;div ref={elem => this.elem = elem}></code>)</p>',id:"/Users/lliu/github/smilingleo.github.io/src/pages/2018/转用Gatsby搭建博客.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2018-03-08T17:00:00.000+08",path:"/2018/blog-with-gatsby",title:"转用Gatsby打造基于github的博客站点",excerpt:"如何用Gatsby打造一个博客",tags:["blog","github","gatsby"]}}},{node:{html:'<h2>问题描述</h2>\n<p>因为我们的项目中用到了<a href="http://github.com/zalando/skipper">Skipper</a>作为UI层的gateway，在支持一个新上线的UI应用的时候，发现一个奇怪的现象，假定：</p>\n<pre><code>Skipper Domain: https://ui.example.com\nWebapp Internal Domain：https://webapp.internal.example.com\n</code></pre>\n<p>在Skipper收到一个请求 <code>GET https://ui.example.com/webapp</code>的时候，根据Routing规则：</p>\n<pre><code>Path("/webapp") -> "https://webapp.internal.example.com"\n</code></pre>\n<p>请求应该是会被转到这个地址的。测试发现：</p>\n<!-- language: lang-bash -->\n<pre><code># 正常工作，返回200\ncurl -i https://webapp.internal.example.com\n\n# 返回404\ncurl -i https://ui.example.com\n</code></pre>\n<p>神奇的就是后面的测试，返回404，而且来源于一个<code>nginx</code>服务器。</p>\n<h2>调试</h2>\n<p>通过 <code>curl -vv</code> 比较两个请求的差异，发现两个服务器的证书CN不同，一个是 <code>*.example.com</code>，另外一个是 <code>*.internal.example.com</code>，怀疑是不是SNI相关的问题，尝试了一下：</p>\n<pre><code class="language-bash">curl -i -H "Host: webapp.internal.example.com" https://ui.example.com\n</code></pre>\n<p>哈，成功返回200.</p>\n<p>查阅了一下SNI相关资料，发现了疑惑：SNI中hello_name来源于 URL中的domain name，而不是被加密的Header。一个web server如果host多个domains，在request过来的时候，会根据URI中的domain name来查找对应domain的证书，然后用来SSL握手，如果找不到证书，才会返回一个默认的页面，比如404.</p>\n<p>但是根据我们的试验，证书应该是正确的，所以应该不是SNI的问题。</p>\n<h2>真相大白</h2>\n<p>问题是解决了，但是却不知道是什么原因，这让人很不舒服，继续找。无意中发现了这个<a href="https://github.com/golang/go/issues/22704">Issue</a>，其中提到：</p>\n<blockquote>\n<p>This would break usage of net/http for <a href="https://www.bamsoftware.com/papers/fronting/">domain fronting</a>, an anti-censorship technique specifically relying on sending different hosts in SNI and HTTP headers. Such a use of net/http is not rare: censorship-resistant tunneling software such as <a href="https://github.com/getlantern/lantern">Lantern</a> and my own project Geph both use net/http this way.</p>\n</blockquote>\n<p><code>domain fronting</code>？什么鬼，著名的<code>lantern</code>居然在用，查了一下，明白了。原来这个技术就是用来翻墙的，哈。</p>\n<p>具体来说：</p>\n<p><img src="https://www.bamsoftware.com/papers/fronting/fronting.svg" alt="domain fronting"></p>\n<p>比如你想访问被墙的网站<code>forbidden.example</code>,你可以用36计之张冠李戴，谎称我访问的是<code>allowed.example</code>, 然后在request header中指定<code>Host: forbidden.example</code>，用https，这样请求就会被加密，邪恶的探测器们就无法知道你真正的地址，而且这样也符合SNI的握手协议。</p>\n<p>现在很多网站都支持这种技术，比如google:</p>\n<pre><code class="language-bash">curl -vv -H "Host: maps.google.com" https://www.google.com\n</code></pre>\n<p>从URL上看，访问的是<code>www.google.com</code>，但是你看一下返回内容会发现，这个内容却是<code>maps.google.com</code>返回的。</p>\n<p>在我们的例子中，因为skipper中设置了<code>-proxy-preserve-host</code>，这样<code>Host</code> header会被传递给下面的目标app，而这个目标app因为支持domain fronting，尝试着去找那个 <code>ui.example.com</code>对应的证书，当然没有，所以返回<code>404</code>.</p>\n<h2>参考资料</h2>\n<ol>\n<li><a href="https://www.bamsoftware.com/papers/fronting/">Domain Fronting</a></li>\n<li><a href="https://en.wikipedia.org/wiki/Server_Name_Indication">Server Name Indication</a></li>\n</ol>',id:"/Users/lliu/github/smilingleo.github.io/src/pages/2018/一则奇怪的Toubleshooting.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2018-03-08T08:30:00.000+08:00",path:"/2018/skipper-sni-domain-fronting",title:"记一次奇怪的troubleshooting",excerpt:"在Skipper转发请求到一个https站点的时候，返回莫名404.",tags:["skipper","SNI","domain fronting"]}}},{node:{html:"<p>在API first的时代，json作为最常用的格式，充斥着程序猿的屏幕各个角落，掌握一门解析、过滤、转换json输出的工具，已经成为程序猿们安身立命的必要技能。\n这里隆重向大家介绍<a href=\"https://stedolan.github.io/jq/\">jq</a>.</p>\n<h2>常用命令</h2>\n<h3>pipe: |</h3>\n<p>和unix管道一样。</p>\n<h3>.[]</h3>\n<p>用来将数组中内容传递给后面命令，而不是把整个数组传过去（脱包）\n还可以用<code>.[n]</code>来获取数组中第n个元素。</p>\n<h3>has(key)</h3>\n<p>检查json对象中是否有key属性。一般结合<code>select()</code>使用。</p>\n<h3>select(boolean_expr)</h3>\n<p>用来过滤输入。比如，只输出具有<code>name</code>项的json对象，可以用：<code>jq 'has(\"name\") as $hasName | select($hasName=true)'</code></p>\n<h2>实战</h2>\n<p>我们将使用<code>docker inspect</code>输出结果作为例子进行解析。</p>\n<h3>列出所有docker images的inspect结果</h3>\n<!-- language:bash -->\n<pre><code>docker inspect $(docker images | tail -n +2 | awk '{print $1\":\"$2}')\n</code></pre>\n<h3>只列出所有volumes不为空的images</h3>\n<!-- language:bash -->\n<pre><code>docker inspect $(docker images | tail -n +2 | awk '{print $1\":\"$2}') | jq '.[] | select(.Config.Volumes!=null)'\n</code></pre>\n<h3>将json转换为csv</h3>\n<!-- language:bash -->\n<pre><code>docker inspect $(docker images | tail -n +2 | awk '{print $1\":\"$2}') | jq '.[] | [(.RepoTags|.[0]), .DockerVersion] | @csv'\n</code></pre>\n<p>上面例子中：</p>\n<ul>\n<li><code>.[]</code>将数组中每个单项传递给后面命令</li>\n<li><code>(.RepoTags|.[0])</code>取出第一个RepoTags的内容也就是image的name:tag</li>\n<li><code>.DockerVersion</code>取出docker版本</li>\n<li><code>将上面两个命令用</code>,`连接，表示将前面的输入同时传递给这两个命令</li>\n<li>用<code>[]</code>将上面两个命令包起来，表示将两个命令的输出结果作为数组中的一个item</li>\n<li><code>@csv</code>将前面的数组输出转换为csv格式。</li>\n</ul>",id:"/Users/lliu/github/smilingleo.github.io/src/pages/2016/JSON解析利器JQ.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2016-03-25T19:16:45.000Z",path:"/2013/jq",title:"JSON解析利器---JQ",excerpt:"在API first的时代，json作为最常用的格式，充斥着程序猿的屏幕各个角落，掌握一门解析、过滤、转换json输出的工具，已经成为程序猿们安身立命的必要技能。 这里隆重向大家介绍[jq](https://stedolan.github.io/jq/).",tags:["bash","jq","json"]}}},{node:{html:'<p>泛型编程的时候，协变(covariant)还是逆变(contravariant)很重要，在设计上层API接口的时候，正确的使用协变、逆变可以更好地约束程序员的行为，让实现变得安全、一致。</p>\n<p>协变、逆变在一般时候是比较容易理解的，但是来到FP世界之后，Function的协变、逆变就变得比较复杂。</p>\n<p>比如： 对于<code>trait List[+T]</code></p>\n<!-- language:uml -->\n<pre><code>class Animal\nclass Dog\nclass "List[Animal]" as LA\nclass "List[Dog]" as LD\n\nAnimal &#x3C;|-- Dog\nLA &#x3C;|-- LD\n</code></pre>\n<p>那对于<code>trait CList[-T]</code></p>\n<!-- language:uml -->\n<pre><code>class Animal\nclass Dog\nclass "CList[Animal]" as LA\nclass "CList[Dog]" as LD\n\nAnimal &#x3C;|-- Dog\nLA --|> LD\n</code></pre>\n<p>这些还都容易理解，对于<code>trait Func[-I, +O]</code>的理解就比较费劲了。</p>\n<!-- language:lang-scala -->\n<pre><code>import scala.reflect.runtime.universe._\n\nclass Animal\ncase class Dog(name: String) extends Animal\n\nclass Material\ncase class Wood(color: String) extends Material\n\ntrait Func[-I, +O] {\n  def apply(input: I): O\n}\n\ntypeOf[Dog] &#x3C;:&#x3C; typeOf[Animal]  // return true\ntypeOf[Func[Material, Dog]] &#x3C;:&#x3C; typeOf[Func[Wood, Animal]]    // retrun true\n</code></pre>\n<!-- language:uml -->\n<pre><code>class Animal\nclass Dog\nclass Wood\nclass Material\n\nclass "Func[Wood, Animal]" as LA\nclass "Func[Material, Dog]" as LD\n\n\nWood --|> Material\nLA &#x3C;|-- LD\nAnimal &#x3C;|-- Dog\n</code></pre>\n<p>理解这个的关键是理解“里氏替换原则”，也就是，任何父类出现的地方，如果用其子类来替换都应该是安全的。从这个角度看，这个<code>Func</code>完成的工作是用某种材料来制作某种动物，<code>Func[Wood, Animal]</code>是输入木头制作任何动物，<code>Func[Material, Dog]</code>是输入任何材料来制作狗。考虑下面的应用场景：</p>\n<!-- language:lang-scala -->\n<pre><code>val woods: List[Wood] = ...         //给定一堆木头\n\nval makeAnimalWithWood: Func[Wood, Animal] = ...\nval makeDogWithMaterial: Func[Material, Dog] = ...\n\nval describer: Animal -> String = ...\n\nwoods.map(makeAnimalWithWood)       // return List[Animal]\n     .map(describer)                // 接受Animal返回String\n</code></pre>\n<p>根据里氏替换原则，用<code>makeDogWithMaterial</code>替换<code>makeAnimalWithWood</code>是安全的。反过来，看下面代码：</p>\n<!-- language:lang-scala -->\n<pre><code>val materials: List[Material] = ...           // 给定一堆材料\n\nval makeAnimalWithWood: Func[Wood, Animal] = ...\nval makeDogWithMaterial: Func[Material, Dog] = ...\n\nval describer: Dog -> String = ...\n\nmaterials.map(makeDogWithMaterial)       // return List[Dog]\n     .map(describer)                // 接受Dog返回String\n</code></pre>\n<p>这时候，用<code>makeAnimalWithWood</code>来替换<code>makeDogWithMaterial</code>就不行了，因为<code>materials.map(makeAnimalWithWood)</code>就会编译错误了，因为<code>makeAnimalWithWood</code>只接受<code>Wood</code>，而代码传递过来的是<code>Material</code>.</p>',id:"/Users/lliu/github/smilingleo.github.io/src/pages/2016/Function的协变.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2016-02-04T17:16:45.000Z",path:"/2016/function-covariant-contravariant",title:"Function的协、逆变",excerpt:"泛型编程的时候，协变(covariant)还是逆变(contravariant)很重要，在设计上层API接口的时候，正确的使用协变、逆变可以更好地约束程序员的行为，让实现变得安全、一致。",tags:["scala","functional programming"]}}},{node:{html:'<h2>Java中的AOP</h2>\n<p>在Java世界，AOP（Aspect Oriented Programming， 面向方面编程)是很多框架的基础。这种将关注点按照“方面”来切分的编程模型极大地简化了编程的复杂度，尤其是在多维度因子交织在一起的时候的各种场景。对于代码的可读性、可维护性、可重用性都是极大的帮助。</p>\n<p>不过AOP一个令人诟病的地方是其透明性，也就是说对于开发人员来说，我不知道我的某个方法会不会被某个Aspect切面一刀，有些时候，会造成一些意想不到的后果，比如Spring的transaction管理，如果通过aop的方式来定义，比如：</p>\n<!-- language: xml -->\n<pre><code>&#x3C;tx:advice id="txCommonAdvice" transaction-manager="transactionManager">\n    &#x3C;tx:attributes>\n        &#x3C;tx:method name="save*" propagation="REQUIRED"/>\n        &#x3C;tx:method name="remove*" propagation="REQUIRED"/>\n        &#x3C;tx:method name="update*" propagation="REQUIRED"/>\n        &#x3C;tx:method name="delete*" propagation="REQUIRED"/>\n        &#x3C;tx:method name="*" propagation="REQUIRED" read-only="true"/>\n    &#x3C;/tx:attributes>\n&#x3C;/tx:advice>\n</code></pre>\n<p>那么被这个切面拦截的任何方法都会导致Spring Transaction Manager启动一个事务，甚至是像<code>toString()</code>, <code>equal(other)</code>等这样的方法，而且因为其透明性，开发人员往往意识不到这个问题。</p>\n<h2>Scala中的AOP</h2>\n<p>在Scala的世界里，AOP的思想其实也是适用的，当然，因为Scala就运行在jvm上面，很多code weaver工具也照样是可以用的，比如aspectj, asm等等，个人不是很喜欢这些东西，更喜欢用显式的方式来告诉我的代码读者，我的代码会做哪些事情。No Magic，是我的一个信条。</p>\n<p>Scala的Mixin机制trait，可以很好地实现显式的AOP，举个例子：</p>\n<!-- language: scala run -->\n<pre><code>trait Task { def execute }\ntrait TaskLogging extends Task {\n    abstract override def execute = {\n        println("before execute")\n        super.execute\n        println("after execute")\n    }\n}\nclass MyTask extends Task {\n    override def execute = {\n        println("do something")\n    }\n}\n\nval task = new MyTask\ntask.execute    // 输出 \'do something\'，没什么稀奇的\n\nval task2 = new MyTask with TaskLogging\ntask2.execute   // 点击\'run\'看看会输出什么？\n</code></pre>\n<p>在上面代码中，<code>MyTask</code>和<code>TaskLogging</code>都是只关注于自己的逻辑（Aspect），在运行时，可以构建一个<code>MyTask with TaskLogging</code>的<code>task2</code>instance，就可以将两个方面组合在一起了。当然你还可以增加新的方面，比如：</p>\n<!-- language: scala -->\n<pre><code>trait Transactional extends Task {\n    abstract override def execute = {\n        println("begin transaction")\n        try {\n            super.execute\n            println("commit transaction")\n        } catch {\n            case _: Exception =>\n                println("rollback transaction")\n        }\n    }\n}\n\nval task3 = new MyTask with TaskLogging with Transactional\ntask3.execute\n</code></pre>\n<p>这样，就可以构建一个有事务，有logging的task。</p>\n<p>总结一下，定义一个Aspect的步骤：</p>\n<ol>\n<li>重载trait中的方法</li>\n<li>方法前逻辑，比如logging、begin transaction等等</li>\n<li>调用<code>super</code>对象的方法</li>\n<li>方法后逻辑，比如logging、commit transaction等</li>\n</ol>\n<p>这里，主要的知识点是调用<code>super.execute</code>的执行顺序，在用<code>with Trait</code>定义一个新类型的时候，多个Trait会形成一个Stack，执行的时候会按照出栈顺序执行，比如：</p>\n<!-- language: scala -->\n<pre><code>val task = new MyTask with TaskLogging with Transactional\ntask.execute\n</code></pre>\n<p>TaskLogging先入栈，Transactional后入，那么执行的时候，先执行Transactional，后执行TaskLogging，就会输出：</p>\n<!-- language -->\n<pre><code>begin transaction\nbefore execute\ndo something\nafter execute\ncommit transaction\n</code></pre>\n<p>换一个顺序：</p>\n<!-- language: scala -->\n<pre><code>val task = new MyTask with TaskLogging with Transactional\ntask.execute\n</code></pre>\n<p>那么输出将会是另外一个顺序。    </p>\n<h3>抽象方法中的super call</h3>\n<p>注意一个细节，在<code>TaskLogging.execute</code>中，我们调用了<code>super.execute</code>，仔细想想，感觉很奇怪，几个疑点：</p>\n<ol>\n<li>TaskLogging的super是谁？</li>\n<li>为什么<code>MyTask.execute</code>是最后执行的？</li>\n</ol>\n<p>查询《Programming in Scala》“traits as stackable modifications“章节后，我们可以了解到：</p>\n<ol>\n<li>trait中的super call是动态绑定，是在另外一个trait或者class实现一个具体的方法之后。</li>\n<li>所以trait中的方法必须标注: <code>abstract override</code>，以此来告诉编译器，你是故意这么来用的。</li>\n</ol>\n<p>用scalac编译上述源文件，生成.class文件之后，用<code>jad</code>等工具查看反编译类，会发现其实<code>MyTask with TaskLogging</code>会产生一个匿名类，继承MyTask，实现TaskLogging接口，回头再看TaskLogging中定义的<code>super.execute</code>，就能理解了，原来在调用TaskLogging.execute方法的时候的<code>this</code>，已经是匿名类的实例了，当然其super是合法的。然后其执行顺序也就能理解了。</p>\n<p>但是这里明显有一个矛盾：从代码执行角度看，生成的匿名类是MyTask和TaskLogging的子类，这点可以通过<code>task.isInstanceOf[MyTask] &#x26;&#x26; task.isInstanceOf[TaskLogging]</code>中判断得出，但是从字面上看，在trait TaskLogging中调用<code>super.execute</code>，又给人感觉莫名其妙。可能这也是scala需要在jvm上运行所做的妥协吧。</p>\n<h2>Stackable Actor模式</h2>\n<p>在Akka中，这种Mixin的用法非常的有帮助，比如在对actor进行监控的时候，我们希望能记录每个actor发送消息的路径，每个actor接收消息之后处理所花费的时间、调用次数等等，如果不用这种trait mixin的话，代码将非常凌乱。</p>\n<p>之所以单独将这个模式提出来，其实还因为这个模式中利用了PartialFunction的特性，让代码更加的优雅。看例子：</p>\n<!-- language: scala run -->\n<pre><code>type Receive = PartialFunction[Any, Unit]\n\ntrait Actor {\n    def receive: Receive\n    def unhandled(msg: Any): Unit = println(s"unhandled message: $msg")\n}\n\ntrait StackableActor extends Actor {\n    def wrapped: Receive\n    def receive: Receive = {\n        case x => if (wrapped.isDefinedAt(x)) wrapped(x) else unhandled(x)\n    }\n}\n\n trait LoggingActor extends StackableActor { \n    override def wrapped: Receive = { \n        case x => \n            println(s"start processing message: $x")\n            super.receive(x)\n            println("end of processing message:" + x) \n    }\n}\n\nclass MyActor extends StackableActor with LoggingActor {\n    override def wrapped: Receive = {\n        case "something" =>\n            println("I can only do \'something\'")\n    }\n}\n\nnew MyActor() receive ("something")\nnew MyActor() receive ("else")\n</code></pre>',id:"/Users/lliu/github/smilingleo.github.io/src/pages/2015/如何在Scala中实现AOP.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2015-08-13T10:16:45.000Z",path:"/2015/aop-by-mixin-in-scala",title:"用Mixin组合实现Scala中的AOP",excerpt:"在Java世界，AOP（Aspect Oriented Programming， 面向方面编程)是很多框架的基础。这种将关注点按照“方面”来切分的编程模型极大地简化了编程的复杂度，尤其是在多维度因子交织在一起的时候的各种场景。对于代码的可读性、可维护性、可重用性都是极大的帮助。",tags:["scala","functional programming","AOP","mixin"]}}},{node:{html:'<p>Scala的学习过程中，经常会碰到一些莫名其妙的现象，很多时候，这些语言层面的“怪象”都与scala编译器或者scala的类型系统有关。</p>\n<p>本文不是对编译器和类型系统的介绍，而是重点介绍遇到这些现象的时候，用什么样的方式，拨开云雾见蓝天，通过这些工具获取一些细节帮你了解编译器和类型系统如何工作。工欲善其事，必先利其器。</p>\n<h2>REPL</h2>\n<p>Read-Evaluate-Print-Loop, 是一个所有学习scala的同学都要掌握的工具，可以帮你快速测试一些代码，了解一些library怎么使用。</p>\n<p>在安装scala之后，命令行下执行<code>scala</code>，就会进入REPL.</p>\n<!-- language: bash -->\n<pre><code>$ scala\nWelcome to Scala version 2.11.1 (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_65).\nType in expressions to have them evaluated.\nType :help for more information.\n\nscala>\n</code></pre>\n<p>如果是SBT项目，可以用<code>sbt console</code>进入，之后操作类型，不再重复。</p>\n<h3>模式</h3>\n<p>scala REPL有<a href="http://hongjiang.info/scala-repl-modes/">几种模式</a>，其中比较常用的就是<code>:paste</code>，可以比较方便的输入多行，不过要注意，拷贝粘贴的代码中，不要有Tab，否则会触发auto code completion，出现一堆错误提示。</p>\n<h3>反射</h3>\n<h2>命令行参数</h2>\n<p>通过<code>man scala</code>, <code>man scalac</code>，可以了解scala都有哪些参数可用。注意的是：scala的命令行参数中import了scalac的参数，所以可以在scala命令后面使用任何scalac的参数。其中比较有用的参数有：</p>\n<ul>\n<li><code>-X</code>系列，用于输出高级选项概要。也就是正式支持的选项，向后兼容。</li>\n<li><code>-Y</code>系列。用于输出私有选项信息，可能随版本变化。参见<a href="http://www.scala-lang.org/old/node/9313">[6]</a><a href="http://paulbutcher.com/2010/04/26/scala-compiler-advanced-options/">[7]</a></li>\n</ul>\n<p><code>scala -X</code>，<code>scala -Y</code>可以分别列出当前版本所支持的所有选项。</p>\n<h2>参考</h2>\n<ol>\n<li><a href="http://stackoverflow.com/questions/11055210/whats-the-easiest-way-to-use-reify-get-an-ast-of-an-expression-in-scala">What\'s the easiest way to use reify (get an AST of) an expression in Scala? stackoverflow</a></li>\n<li><a href="http://stackoverflow.com/questions/11392622/how-to-investigate-objects-types-etc-from-scala-repl">How to investigate objects/types/etc. from Scala REPL? stackoverflow</a></li>\n<li><a href="https://www.parleys.com/tutorial/51c38751e4b0d38b54f4625e/chapter0/about">Practical Type Mining in Scala ,  scaladay 2013</a></li>\n<li><a href="http://hongjiang.info/scala-repl-modes/">REPL的几种模式, hongjiang</a></li>\n<li><a href="http://docs.scala-lang.org/overviews/reflection/symbols-trees-types.html">Symbols, Trees, and Types, scalaDoc</a></li>\n<li><a href="http://www.scala-lang.org/old/node/9313">Difference between -Y and -X compiler options, scala user forum</a></li>\n<li><a href="http://paulbutcher.com/2010/04/26/scala-compiler-advanced-options/">Scala Compiler Advanced Options</a></li>\n</ol>',id:"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Scala雾里看花.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2015-04-23T19:16:45.000Z",path:"/2015/scala-trouble-shooting",title:"Scala雾里看花",excerpt:"Scala的学习过程中，经常会碰到一些莫名其妙的现象，很多时候，这些语言层面的“怪象”都与scala编译器或者scala的类型系统有关。本文不是对编译器和类型系统的介绍，而是重点介绍遇到这些现象的时候，用什么样的方式，拨开云雾见蓝天，通过这些工具获取一些细节帮你了解编译器和类型系统如何工作。工欲善其事，必先利其器。",tags:["scala","trouble shooting"]
}}},{node:{html:'<h2>Pull Mysql Docker Image</h2>\n<!-- language: bash -->\n<pre><code>docker pull mysql:5.6\n</code></pre>\n<h2>Create MySQL Config Files</h2>\n<p>For Master, create a <code>mysql.cnf</code> file and add the following content:</p>\n<!-- language: bash -->\n<pre><code>[mysqld]\n\nserver-id = 1\nlog_bin\nbinlog_format = ROW\nbind-address = 0.0.0.0\n\nsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES\n</code></pre>\n<p>For Slave, create another <code>mysql.cnf</code> and add the following content:</p>\n<!-- language: bash -->\n<pre><code>[mysqld]\n\nserver-id = 2\nlog_bin\nbinlog_format = ROW\nbind-address = 0.0.0.0\n\nsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES\n</code></pre>\n<h2>Start Master/Slave MySQL Containers</h2>\n<p>Start Master:</p>\n<!-- language: bash -->\n<pre><code>docker run --name master -v /my/master:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:5.6\n</code></pre>\n<p>Start Slave:</p>\n<!-- language: bash -->\n<pre><code>docker run --name slave -v /my/slave:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw --link master:master -d mysql:5.6\n</code></pre>\n<p>The slave node needs to link to master node.</p>\n<h2>Setup Replication</h2>\n<p>Check the master status:</p>\n<!-- language: bash -->\n<pre><code>mysql> show master status \\G\n*************************** 1. row ***************************\n             File: mysql-bin.000003\n         Position: 120\n     Binlog_Do_DB: \n Binlog_Ignore_DB: \nExecuted_Gtid_Set: \n1 row in set (0.00 sec)\n</code></pre>\n<p>the above information is necessary for the slave configuration, especially the <code>File</code> and <code>Position</code>.</p>\n<p>Connect to Slave node, in Mysql Shell:</p>\n<!-- language: bash -->\n<pre><code>mysql> change master to master_host=\'master\',master_user=\'root\',master_password=\'my-secret-pw\',master_log_file=\'mysql-bin.000003\',master_log_pos=120;  \nQuery OK, 0 rows affected (0.00 sec)  \n\nmysql> start slave;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql> show slave status\\G\n\n// until you see the following two options are \'Yes\'\nSlave_IO_Running: Yes  \nSlave_SQL_Running: Yes  \n</code></pre>\n<p>You need to change the parameters like <code>master_log_file</code> and <code>master_log_pos</code> based on previous <code>show master status</code> output.</p>\n<h2>Test</h2>\n<p>Create some tables and insert some data on master, and check if those data are synced to slave. </p>\n<h2>Change Data Capture (CDC)</h2>\n<p>Here I used an open source library <a href="https://github.com/whitesock/open-replicator">open-replicator</a></p>\n<!-- language: scala -->\n<pre><code>import com.google.code.or._\nimport com.google.code.or.binlog._\nimport com.google.code.or.binlog.impl.event.FormatDescriptionEvent\n\nval or = new OpenReplicator()\nor.setUser("root")\nor.setPassword("my-secret-pw")\nor.setServerId(2);\nor.setHost("slave")\nor.setPort(3306)\nor.setBinlogPosition(120)\nor.setBinlogFileName("mysql-bin.000004")\n\nor.setBinlogEventListener(new BinlogEventListener() {\n  def onEvents(event: BinlogEventV4) = {\n\n  }\n})\n\nor.start()\n</code></pre>\n<p>TBD.\nSee <code>com.linkedin.databus2.producers.ORListener</code></p>\n<h2>References</h2>\n<ol>\n<li><a href="https://registry.hub.docker.com/_/mysql/">Mysql Docker Official Repo</a></li>\n<li><a href="https://github.com/linkedin/databus/wiki/Databus-for-MySQL">Databus for MySQL</a></li>\n</ol>',id:"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Docker创建MySQL主从复制以及CDC测试.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2015-04-21T07:16:45.000Z",path:"/2015/mysql-replication-on-docker",title:"MySQL Master/Slave Replication on Docker",excerpt:"How to setup Mysql master/slave replication.",tags:["docker","mysql"]}}},{node:{html:'<p>经常看到很多示例代码，简洁的让人爱不释手，可是真正自己实现的时候，不得不添加各种各样的异常处理逻辑，最后发现代码总量的80%都是再做异常处理，而真正的代码逻辑只有很少的一部分。</p>\n<p>异常处理对于指令式和函数式编程都是同样需要的，只是因为实现方式的不同，让函数式编程看上去更加简洁，优雅，不需要像指令式那么繁琐。</p>\n<p>本文的目的，就是介绍函数式编程中常用的一些异常处理策略。记得把这些瑞士军刀放到你的百宝箱中，以后一定用得上。</p>\n<h2>空判断Option</h2>\n<p>如果采访100个程序员，让所有人投票他们在编程时最讨厌做的事情，但又经常犯错误的地方，我估计十有八九会是“空判断”了。</p>\n<p><code>Null</code>代表着一个对象还没有被初始化，具体点是对象的指针还没有一个确切的地址。在面向对象编程时，因为操作的都是对象，为了避免在一个<code>null</code>上面调用方法，或者 get一个<code>null</code>上的属性，而导致“空值异常”，程序员不得不做下面的事情：</p>\n<p>假设有下面一个场景：</p>\n<!-- language:uml -->\n<pre><code>Selling --> Store\nSelling --> Product\n</code></pre>\n<p>简单说，一个商场内有很多商店(Store)，每个商店卖(Selling)很多种商品(Product)，如果希望找出所有销售玩具的商店：</p>\n<!-- language:java -->\n<pre><code>public List&#x3C;Store> findByProductCategory(Category category) {\n  if (category == null)               &#x3C;1>\n    return null;\n  List&#x3C;Product> allProducts = getAllProducts(); // DB lookup\n  for (Product prod : allProducts) {\n    if (prod.category == null)        &#x3C;2>\n      continue; \n    if (category.equals(prod.category)){\n    \n</code></pre>\n<h2>参考</h2>\n<ol>\n<li><a href="https://tersesystems.com/2012/12/27/error-handling-in-scala/">Error Handling in Scala. https://tersesystems.com/2012/12/27/error-handling-in-scala. 2012</a></li>\n</ol>',id:"/Users/lliu/github/smilingleo.github.io/src/pages/2014/Scala函数式异常处理.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2014-05-04T07:16:45.000Z",path:"/2014/scala-error-handling-in-fp-style",title:"Scala函数式异常处理",excerpt:"经常看到很多示例代码，简洁的让人爱不释手，可是真正自己实现的时候，不得不添加各种各样的异常处理逻辑，最后发现代码总量的80%都是再做异常处理，而真正的代码逻辑只有很少的一部分。",tags:["scala","functional programming","exception handling"]}}}],pathPrefix:"",first:!0,last:!1,index:1,pageCount:3}}}});
//# sourceMappingURL=path---index-0b91ce32e1ef9e14e4fe.js.map