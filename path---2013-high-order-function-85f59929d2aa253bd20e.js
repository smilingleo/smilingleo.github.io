webpackJsonp([0xec313b042b5e],{394:function(n,e){n.exports={data:{markdownRemark:{html:'<p>所谓高阶函数（high order function），其实就是可以接受其他函数作为参数的函数。</p>\n<p>这里其实还有另外一个概念：<em>头等函数</em>（First Class Function），First Class应该是指头等公民的含义。在Java中的一个方法（函数），只能被调用，相比值Value就像个二等公民，不能像值Value一样，既可以在表达式中被引用，又可以作为参数传入其他方法。</p>\n<p>头等函数也就是可以将其作为一个值进行传递的函数。看上去很简单，可带来的变化是巨大的。</p>\n<p>头等函数加上高阶函数，可以极大地简化代码，实现DSL。</p>\n<h2>简化代码</h2>\n<h3>Java中的匿名类</h3>\n<!-- language:lang-java -->\n<pre><code>import java.util.*\n\nTimer timer = new Timer();\nTimerTask helloTimer = new TimerTask(){\n    public void run(){\n        System.out.println("Hello Timer");\n    }\n};\ntimer.schedule(helloTimer, 1);\n\nTimerTask helloWorld = new TimerTask(){\n    public void run(){\n        System.out.println("Hello World");\n    }\n};\ntimer.schedule(helloWorld, 1);\n</code></pre>\n<p>然后每次都需要new一个TimerTask匿名类，用起来真心不方便，尤其是当你有多个匿名类要一起使用的时候，那代码看起来简直就像一坨翔，丑陋无比！本来正常的、相同抽象层次的代码应该具有相同的缩进层次，这样阅读起来很易懂、顺畅。但是因为引入匿名类，就得放在不同的缩进层次中，加上不必要的类签名定义，方法定义等boilerplate code, 阅读起来那叫一个费劲！</p>\n<p>看看scala的方式：</p>\n<h1>Scala</h1>\n<!-- language:lang-scala run -->\n<pre><code>import scala.concurrent._\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nval timer = new java.util.Timer()\ndef timeout[A](a: => A, duration: Duration)(implicit ec: ExecutionContext): Future[A] = {\n    val p = Promise[A]()\n    timer.schedule(new java.util.TimerTask() {\n        def run() = {\n            p.success(a)\n        }\n    }, duration.toMillis)\n    p.future\n}\n\ntimeout(println("Hello World"), 1 millisecond)\ntimeout(println("Hello Timer"), 1 millisecond)\n</code></pre>\n<p>定义一个timeout高阶函数，接受一个<code>=> A</code>函数作为参数，然后就可以方便地重复调用了。\n</p>\n<h2>自定义控制结构+鸭子类型</h2>\n<h3>try with resources</h3>\n<p>在Java中，在处理一些资源相关的数据时，经常需要用一个<code>try .... catch ... finally { res.close(); }</code>的结构，同样地，这种结构使得代码的缩进层次和逻辑抽象层次不同而影响阅读。另外更严重的问题是常常忘记关闭资源。</p>\n<p>Java中的一种解决方案是用<code>template method</code>模式，比如Spring JdbcTemplate，传入一个匿名类，比如：</p>\n<!-- language: lang-java -->\n<pre><code>jdbcTemplate.execute(new StatementCallback(){\n    public Object doInStatement(Statement stmt) throws SQLException, DataAccessException {\n        // your real logic here\n    }\n}\n</code></pre>\n<p>可以看到，真正的逻辑被缩进了两层，有很多boilerplate代码。</p>\n<p>Java 1.7中引入了try with resources的语法，一定程度上解决了这个问题：</p>\n<!-- language: lang-java -->\n<pre><code>try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}\n</code></pre>\n<p>但是要求在try里面的资源必须实现<code>AutoCloseable</code>接口。当然了，Java中很多东西都是围绕接口转。接口就意味着规约，要使用try-with-resources语法，就必须符合这个规约。</p>\n<p>再看看Scala中如何实现：</p>\n<!-- language: lang-scala run -->\n<pre><code>def using[T &#x3C;: { def close() }](resource: T)(block: T => Unit) {\n  try {\n    block(resource)\n  }finally {\n    if (resource != null) resource.close()\n  }\n}\ncase class Resource {\n    def close() = println("I\'m closing")\n    def doSomething() = println("boring")\n}\n\nval res = Resource()\n\nusing[Resource](res){ res =>\n    res.doSomething()\n}\n</code></pre>\n<p>和<code>try-with-resources</code>的语法比较像吧，不过不同的是，<code>using</code>不要求传入的resource必须实现某种接口，只需要该类型定义了一个<code>def close(): Unit</code>方法。这就是所谓的鸭子类型，只要你走起来像鸭子，那你就是鸭子，不是一个很好的比喻，不过将就吧。</p>\n<h3>break</h3>\n<p>当你学习scala的时候，你会发现很多java中的关键字在scala中是不支持的，其中一个就是：<code>break</code>。</p>\n<p>在一个循环的时候，当满足某个条件就退出当前循环，是一个很普遍的用法，为什么scala中会不是一个关键字呢？我自己感觉是scala强调FP，而break有很浓的指令式编程的味道。</p>\n<p>那我就是想用break怎么办？不要紧，我们可以自己定义一个自己的break。</p>\n<!-- language: lang-scala run -->\n<pre><code>class Breaks {\n  private class BreakControl extends RuntimeException\n  private val breakException = new BreakControl\n\n  // breakable接受一个() => Unit的函数作为参数，是一个高阶函数。\n  def breakable(op: => Unit) {\n    try {\n      op\n    } catch {\n      case ex: BreakControl =>\n        if (ex ne breakException) throw ex\n    }\n  }\n\n  def break(): Nothing = { throw breakException }\n}\nobject Breaks extends Breaks\n\n\nimport Breaks.{break, breakable}\n// 通过高阶函数来实现break\nbreakable {\n  for (i &#x3C;- (1 to 1000)) {\n    if (i > 10){\n      break\n    } else {\n      println(i)\n    }\n  }\n}\n</code></pre>\n<p>是不是很棒？！scala没有我们可以自己造。这就是高阶函数的用处之一。</p>',frontmatter:{title:"高阶函数",date:"November 21, 2013",path:"/2013/high-order-function",tags:["scala","functional programming","high order function"],excerpt:"所谓高阶函数（high order function），其实就是可以接受其他函数作为参数的函数。"}}},pathContext:{prev:{html:"<p>函数式语言与OO（确切地讲是指令式编程）的思维方式是完全不同的，很多OO中的经验在函数式语言中不是很匹配，比如设计模式，那就是一个OO中的特定术语，而在FP中，大家常谈的是对于习惯OO思维的程序员来说玄而又玄的Monad。</p>\n<p>虽然术语不同，其实要解决的问题是相同的，设计模式也好、Monad也好，都是为了如何更好地处理异常、让代码更加简洁易懂、容易扩展等等。【所以透彻地了解问题本身，比学习一个新的技术更加重要。】</p>\n<p>本系列文章试图能够将Monad这个及其抽象的东东具体化，将其落地，变为能够理解的例子，看看在具体问题下如何使用Monad来抽象问题，简化代码。</p>\n<h2>什么是Monad</h2>\n<h3>定义</h3>\n<p>一个Monad就是一个实现了flatMap, unit等函数，包含某种数据类型的容器，更加术语化一点是参数化类型<code>M[T]</code>.</p>\n<!-- language:lang-scala -->\n<pre><code>trait M[T] {\n  def flatMap[U](f: T => M[U]) : M[U]\n  def unit[T](x: T) : M[T]\n}\n</code></pre>\n<p>Monad需要满足三个定理（没错，就是定理，感觉回到了小学、初中的数学课堂）。</p>\n<ul>\n<li>\n<p>组合律</p>\n<p><code>(x flatMap f) flatMap g == x flatMap (y => f(y) flatMap g)</code></p>\n<p>有些人可能会问，右边为什么不是 <code>x flatMap (f flatMap g)</code>呢？ 你试一下就知道了，编译器报类型匹配错误，这里<code>x</code>是一个monad，<code>f</code>, <code>g</code>都是函数，所以<code>f flatMap g</code>会类型不匹配。</p>\n</li>\n<li>\n<p>左单一</p>\n<p><code>unit(x) flatMap f == f(x)</code></p>\n</li>\n<li>\n<p>右单一</p>\n<p><code>x flatMap unit == x</code></p>\n</li>\n</ul>\n<h3>Monad举例</h3>\n<p>在Scala中Monad不是新鲜玩意，其实只要你学scala，那你就会天天用，常用的Monad有：</p>\n<ul>\n<li>Collection类，比如：List, Set, Map</li>\n<li>描述可能性的Option  (Some, None)</li>\n<li>异常处理类 Try, scalaz中的Validation等</li>\n<li>描述未来的 Future</li>\n<li>封装状态变化的State</li>\n<li>封装IO的IO</li>\n</ul>\n<h2>Monad解决什么问题</h2>\n<p>正如上面列举的几个Monad，每种Monad都是为了解决某种具体问题而存在的，正如OO中设计模式一样，只不过Monad的侧重点是：</p>\n<ul>\n<li>\n<p>让你只关注代码主流程，而将异常等分支交给flatMap来处理。</p>\n</li>\n<li>\n<p>每个Monad是一个容器或者一个平行空间，让你可以在该容器（空间）中安全地、方便地操作容器中的数据类型，而不用关心相关问题。比如：在Option空间中，你不用考虑是否有返回值的问题，不需要像指令式编程那样<code>if (rtn == null) ... else ...</code>，再比如Future，让你能够在“未来的时空”中对数据进行操作，不用担心同步的问题，因为你的运算都发生在“未来”空间中。</p>\n</li>\n<li>\n<p>结合for表达式，让你的代码更加简洁、易读。</p>\n<p><code>for { x &#x3C;- monad; y &#x3C;- f(x); ...}</code></p>\n<p>而前面讲的定律（主要是结合律和右单一），可以确保monad在for表达式中使用的正确性，比如结合律：</p>\n</li>\n</ul>\n<!-- language:lang-scala -->\n<pre><code>for {\n  y &#x3C;- for (x &#x3C;- m; y &#x3C;- f(x)) yield y\n  z &#x3C;- g(y)\n} yield z\n</code></pre>\n<p>因为满足结合律，就可以简化为：</p>\n<!-- language:lang-scala -->\n<pre><code>for {\n  x &#x3C;- m\n  y &#x3C;- f(x)\n  z &#x3C;- g(y)\n} yield z\n</code></pre>\n<p>如果翻译为map/flatMap，前者翻译为：<code>m flatMap f flatMap g</code>，后者翻译为：<code>m flatMap (x => f(x) flatMap g)</code>.</p>\n<p>而右单一定律可以保证：<code>for {x &#x3C;- m} yield x == m</code>，如果你看过scalaz，你就了解为什么scalaz中需要有专门的test case来测试这些定律了。</p>\n<p>一般来说我们不太需要关注这些定律的问题，但是如果你需要自己开发一个自己的Monad，那么你就得保证你的Monad符合这些定律，因为这样才能让你的Monad安全地应用在for表达式中。</p>",id:"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Monad.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2013-11-26T07:16:45.000Z",path:"/2013/monad",title:"Monad",excerpt:"函数式语言与OO（确切地讲是指令式编程）的思维方式是完全不同的，很多OO中的经验在函数式语言中不是很匹配，比如设计模式，那就是一个OO中的特定术语，而在FP中，大家常谈的是对于习惯OO思维的程序员来说玄而又玄的Monad。",tags:["scala","functional programming","monad"]}},next:{html:'<h2>上下文</h2>\n<p>很多时候为了提高性能，减少IO操作，都会将数据load出来之后缓存在内存中。本站的实现过程中也遇到类似的问题，不希望每次有人访问的时候就读取一次md文件，或者从MongoDB中查一次，而是直接在内存中读取。</p>\n<p>带来因减少IO而提升性能的好处的同时，也出现一个人和“缓存”解决方案都会遇到的问题：数据一致性。</p>\n<p>简单来说，就是你有同样的一份数据，冗余存放在两个地方，如何确保这两个地方的数据是一致的？再具体一点，可能的问题有：</p>\n<ul>\n<li>\n<p>数据更新的原子性</p>\n<p>更新数据的时候，同时将两个地方的数据都同步更新，任何一个地方更新失败，则整体更新失败。</p>\n</li>\n<li>\n<p>缓存线程安全的问题</p>\n<p>如果缓存既可以被读取，又可能被更新，那么就又线程安全问题：多个线程同时操作同一个值的时候怎么协调？</p>\n</li>\n</ul>\n<h2>具体问题</h2>\n<p>开始的时候，我将所有的文章列表放在一个<code>scala.collection.mutable.ListBuffer</code>中：</p>\n<!-- language:lang-scala -->\n<pre><code>object Application extends Controller {\n  lazy val allPosts: ListBuffer[Post] = ...\n\n}\n</code></pre>\n<p>因为新发布博客会增加集合内数据，所以这里用ListBuffer比较自然。当然用<code>var</code> + immutable collection也可以。</p>\n<p>对<code>allPost</code>的操作主要有三个：</p>\n<ol>\n<li>\n<p>在线编写一个博客的时候需要添加到集合中</p>\n</li>\n<li>\n<p>该集合本身是无序的，因为排序的规则可能有多种，展现的时候再排序</p>\n</li>\n<li>\n<p>更新一篇博文的时候同时更新集合中内容。</p>\n</li>\n</ol>\n<p>因为本身Application Object是单例的，多个线程共同运行的场景下就会出现线程安全的问题，类似Servlet中instance级别变量的问题。</p>\n<h2>解决方案</h2>\n<p>直观地想，理想的解决方案就是将所有对<code>allPost</code>的写操作都串行起来，这样即使有多个线程同时操作，也没问题了。但是如何将实现串行呢？</p>\n<p>在指令式编程的世界里，这个问题比较难于解答，一般需要通过加锁来解决。而一般的程序员看到<code>lock</code>, <code>synchronized</code>这些关键字就头疼了，即使经过无数次盲试之后侥幸实现了，也会在产品上线的时候出现这样那样、莫名其妙、让你大呼“这不科学”，“WTF”的惊呼！</p>\n<p>但是在scala中，我们却不用担心，因为我们有<code>Akka Actor</code>。</p>\n<p>Actor是另外一种并行计算方式，不同于线程共享内存的并发模型，Actor是基于消息的，强调不同Actor之间不共享数据。有了Actor，问题就迎刃而解了。</p>\n<p>具体思路是：重建一个单例Actor，由该Actor来维护ListBuffer变量，所有的写操作，全部通过该消息提交任务交给其处理，这样就将并发的多个写请求串行起来了。</p>\n<p>代码片段：</p>\n<!-- language:lang-scala -->\n<pre><code>object PostManager {\n  // 单例manager actor\n  lazy val manager = Akka.system.actorOf(Props[PostManager])\n  case class NewPost(post: Post)\n  \n  def saveOrUpdate(unsavedPost: Post) = {\n    manager ! NewPost(unsavedPost)\n  }\n}\n\nclass PostManager extends Actor {\n  import PostManager._\n  // actor是单例的，所以文章集合也是单例的。\n  // all posts, but not ordered.\n  lazy val allPosts: ListBuffer[Post] = Post.allPosts\n  \n  def receive = {\n    case NewPost(newPost) =>\n      // 先更新数据库，这样如果更新失败，就不会运行之后代码。一定程度上实现原子性。\n      Post.upsert(newPost)\n      \n      val idx = allPosts.indexWhere( _.fileName == newPost.fileName )\n      \n      if (idx == -1){\n        allPosts += newPost\n      } else {\n        allPosts.update(idx, newPost)\n      }\n  }\n}\n</code></pre>\n<p>全站一个文章集合变量感觉有点"玩具"的感觉，不过这个模型其实是可以扩展的，比如将来如果支持多用户、多博客系统，我们可以每个用户创建一个Actor、维护该用户自己的文章列表。这个Actor模型还是可以重用的。</p>',id:"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Actor协调并发场景下的集合操作.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2013-11-17T14:16:45.000Z",path:"/2013/actor-collection-collabration",title:"边建边学-3：Actor协调并发场景下的集合操作",excerpt:"很多时候为了提高性能，减少IO操作，都会将数据load出来之后缓存在内存中。本站的实现过程中也遇到类似的问题，不希望每次有人访问的时候就读取一次md文件，或者从MongoDB中查一次，而是直接在内存中读取。",tags:["scala","functional programming"]}}}}}});
//# sourceMappingURL=path---2013-high-order-function-85f59929d2aa253bd20e.js.map