{"version":3,"sources":["webpack:///path---2015-mysql-replication-on-docker-e9bfdc9d9cfdff079bd8.js","webpack:///./.cache/json/2015-mysql-replication-on-docker.json"],"names":["webpackJsonp","398","module","exports","data","markdownRemark","html","frontmatter","title","date","path","tags","excerpt","pathContext","prev","id","next"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,+1GAAyhGC,aAAgWC,MAAA,2CAAAC,KAAA,iBAAAC,KAAA,oCAAAC,MAAA,kBAAAC,QAAA,kDAA2MC,aAAgBC,MAAQR,KAAA,o1EAAAS,GAAA,yGAAAR,aAA2+EE,KAAA,2BAAAC,KAAA,+BAAAF,MAAA,YAAAI,QAAA,iKAAAD,MAAA,8BAA4SK,MAASV,KAAA,2vCAAiiCS,GAAA,4GAAAR,aAAmWE,KAAA,2BAAAC,KAAA,yCAAAF,MAAA,eAAAI,QAAA,2FAAAD,MAAA","file":"path---2015-mysql-replication-on-docker-e9bfdc9d9cfdff079bd8.js","sourcesContent":["webpackJsonp([138741863182975],{\n\n/***/ 398:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h2>Pull Mysql Docker Image</h2>\\n<!-- language: bash -->\\n<pre><code>docker pull mysql:5.6\\n</code></pre>\\n<h2>Create MySQL Config Files</h2>\\n<p>For Master, create a <code>mysql.cnf</code> file and add the following content:</p>\\n<!-- language: bash -->\\n<pre><code>[mysqld]\\n\\nserver-id = 1\\nlog_bin\\nbinlog_format = ROW\\nbind-address = 0.0.0.0\\n\\nsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES\\n</code></pre>\\n<p>For Slave, create another <code>mysql.cnf</code> and add the following content:</p>\\n<!-- language: bash -->\\n<pre><code>[mysqld]\\n\\nserver-id = 2\\nlog_bin\\nbinlog_format = ROW\\nbind-address = 0.0.0.0\\n\\nsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES\\n</code></pre>\\n<h2>Start Master/Slave MySQL Containers</h2>\\n<p>Start Master:</p>\\n<!-- language: bash -->\\n<pre><code>docker run --name master -v /my/master:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:5.6\\n</code></pre>\\n<p>Start Slave:</p>\\n<!-- language: bash -->\\n<pre><code>docker run --name slave -v /my/slave:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw --link master:master -d mysql:5.6\\n</code></pre>\\n<p>The slave node needs to link to master node.</p>\\n<h2>Setup Replication</h2>\\n<p>Check the master status:</p>\\n<!-- language: bash -->\\n<pre><code>mysql> show master status \\\\G\\n*************************** 1. row ***************************\\n             File: mysql-bin.000003\\n         Position: 120\\n     Binlog_Do_DB: \\n Binlog_Ignore_DB: \\nExecuted_Gtid_Set: \\n1 row in set (0.00 sec)\\n</code></pre>\\n<p>the above information is necessary for the slave configuration, especially the <code>File</code> and <code>Position</code>.</p>\\n<p>Connect to Slave node, in Mysql Shell:</p>\\n<!-- language: bash -->\\n<pre><code>mysql> change master to master_host='master',master_user='root',master_password='my-secret-pw',master_log_file='mysql-bin.000003',master_log_pos=120;  \\nQuery OK, 0 rows affected (0.00 sec)  \\n\\nmysql> start slave;\\nQuery OK, 0 rows affected (0.01 sec)\\n\\nmysql> show slave status\\\\G\\n\\n// until you see the following two options are 'Yes'\\nSlave_IO_Running: Yes  \\nSlave_SQL_Running: Yes  \\n</code></pre>\\n<p>You need to change the parameters like <code>master_log_file</code> and <code>master_log_pos</code> based on previous <code>show master status</code> output.</p>\\n<h2>Test</h2>\\n<p>Create some tables and insert some data on master, and check if those data are synced to slave. </p>\\n<h2>Change Data Capture (CDC)</h2>\\n<p>Here I used an open source library <a href=\\\"https://github.com/whitesock/open-replicator\\\">open-replicator</a></p>\\n<!-- language: scala -->\\n<pre><code>import com.google.code.or._\\nimport com.google.code.or.binlog._\\nimport com.google.code.or.binlog.impl.event.FormatDescriptionEvent\\n\\nval or = new OpenReplicator()\\nor.setUser(\\\"root\\\")\\nor.setPassword(\\\"my-secret-pw\\\")\\nor.setServerId(2);\\nor.setHost(\\\"slave\\\")\\nor.setPort(3306)\\nor.setBinlogPosition(120)\\nor.setBinlogFileName(\\\"mysql-bin.000004\\\")\\n\\nor.setBinlogEventListener(new BinlogEventListener() {\\n  def onEvents(event: BinlogEventV4) = {\\n\\n  }\\n})\\n\\nor.start()\\n</code></pre>\\n<p>TBD.\\nSee <code>com.linkedin.databus2.producers.ORListener</code></p>\\n<h2>References</h2>\\n<ol>\\n<li><a href=\\\"https://registry.hub.docker.com/_/mysql/\\\">Mysql Docker Official Repo</a></li>\\n<li><a href=\\\"https://github.com/linkedin/databus/wiki/Databus-for-MySQL\\\">Databus for MySQL</a></li>\\n</ol>\",\"frontmatter\":{\"title\":\"MySQL Master/Slave Replication on Docker\",\"date\":\"April 21, 2015\",\"path\":\"/2015/mysql-replication-on-docker\",\"tags\":[\"docker\",\"mysql\"],\"excerpt\":\"How to setup Mysql master/slave replication.\"}}},\"pathContext\":{\"prev\":{\"html\":\"<p>Scala的学习过程中，经常会碰到一些莫名其妙的现象，很多时候，这些语言层面的“怪象”都与scala编译器或者scala的类型系统有关。</p>\\n<p>本文不是对编译器和类型系统的介绍，而是重点介绍遇到这些现象的时候，用什么样的方式，拨开云雾见蓝天，通过这些工具获取一些细节帮你了解编译器和类型系统如何工作。工欲善其事，必先利其器。</p>\\n<h2>REPL</h2>\\n<p>Read-Evaluate-Print-Loop, 是一个所有学习scala的同学都要掌握的工具，可以帮你快速测试一些代码，了解一些library怎么使用。</p>\\n<p>在安装scala之后，命令行下执行<code>scala</code>，就会进入REPL.</p>\\n<!-- language: bash -->\\n<pre><code>$ scala\\nWelcome to Scala version 2.11.1 (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_65).\\nType in expressions to have them evaluated.\\nType :help for more information.\\n\\nscala>\\n</code></pre>\\n<p>如果是SBT项目，可以用<code>sbt console</code>进入，之后操作类型，不再重复。</p>\\n<h3>模式</h3>\\n<p>scala REPL有<a href=\\\"http://hongjiang.info/scala-repl-modes/\\\">几种模式</a>，其中比较常用的就是<code>:paste</code>，可以比较方便的输入多行，不过要注意，拷贝粘贴的代码中，不要有Tab，否则会触发auto code completion，出现一堆错误提示。</p>\\n<h3>反射</h3>\\n<h2>命令行参数</h2>\\n<p>通过<code>man scala</code>, <code>man scalac</code>，可以了解scala都有哪些参数可用。注意的是：scala的命令行参数中import了scalac的参数，所以可以在scala命令后面使用任何scalac的参数。其中比较有用的参数有：</p>\\n<ul>\\n<li><code>-X</code>系列，用于输出高级选项概要。也就是正式支持的选项，向后兼容。</li>\\n<li><code>-Y</code>系列。用于输出私有选项信息，可能随版本变化。参见<a href=\\\"http://www.scala-lang.org/old/node/9313\\\">[6]</a><a href=\\\"http://paulbutcher.com/2010/04/26/scala-compiler-advanced-options/\\\">[7]</a></li>\\n</ul>\\n<p><code>scala -X</code>，<code>scala -Y</code>可以分别列出当前版本所支持的所有选项。</p>\\n<h2>参考</h2>\\n<ol>\\n<li><a href=\\\"http://stackoverflow.com/questions/11055210/whats-the-easiest-way-to-use-reify-get-an-ast-of-an-expression-in-scala\\\">What's the easiest way to use reify (get an AST of) an expression in Scala? stackoverflow</a></li>\\n<li><a href=\\\"http://stackoverflow.com/questions/11392622/how-to-investigate-objects-types-etc-from-scala-repl\\\">How to investigate objects/types/etc. from Scala REPL? stackoverflow</a></li>\\n<li><a href=\\\"https://www.parleys.com/tutorial/51c38751e4b0d38b54f4625e/chapter0/about\\\">Practical Type Mining in Scala ,  scaladay 2013</a></li>\\n<li><a href=\\\"http://hongjiang.info/scala-repl-modes/\\\">REPL的几种模式, hongjiang</a></li>\\n<li><a href=\\\"http://docs.scala-lang.org/overviews/reflection/symbols-trees-types.html\\\">Symbols, Trees, and Types, scalaDoc</a></li>\\n<li><a href=\\\"http://www.scala-lang.org/old/node/9313\\\">Difference between -Y and -X compiler options, scala user forum</a></li>\\n<li><a href=\\\"http://paulbutcher.com/2010/04/26/scala-compiler-advanced-options/\\\">Scala Compiler Advanced Options</a></li>\\n</ol>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Scala雾里看花.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2015-04-23T19:16:45.000Z\",\"path\":\"/2015/scala-trouble-shooting\",\"title\":\"Scala雾里看花\",\"excerpt\":\"Scala的学习过程中，经常会碰到一些莫名其妙的现象，很多时候，这些语言层面的“怪象”都与scala编译器或者scala的类型系统有关。本文不是对编译器和类型系统的介绍，而是重点介绍遇到这些现象的时候，用什么样的方式，拨开云雾见蓝天，通过这些工具获取一些细节帮你了解编译器和类型系统如何工作。工欲善其事，必先利其器。\",\"tags\":[\"scala\",\"trouble shooting\"]}},\"next\":{\"html\":\"<p>经常看到很多示例代码，简洁的让人爱不释手，可是真正自己实现的时候，不得不添加各种各样的异常处理逻辑，最后发现代码总量的80%都是再做异常处理，而真正的代码逻辑只有很少的一部分。</p>\\n<p>异常处理对于指令式和函数式编程都是同样需要的，只是因为实现方式的不同，让函数式编程看上去更加简洁，优雅，不需要像指令式那么繁琐。</p>\\n<p>本文的目的，就是介绍函数式编程中常用的一些异常处理策略。记得把这些瑞士军刀放到你的百宝箱中，以后一定用得上。</p>\\n<h2>空判断Option</h2>\\n<p>如果采访100个程序员，让所有人投票他们在编程时最讨厌做的事情，但又经常犯错误的地方，我估计十有八九会是“空判断”了。</p>\\n<p><code>Null</code>代表着一个对象还没有被初始化，具体点是对象的指针还没有一个确切的地址。在面向对象编程时，因为操作的都是对象，为了避免在一个<code>null</code>上面调用方法，或者 get一个<code>null</code>上的属性，而导致“空值异常”，程序员不得不做下面的事情：</p>\\n<p>假设有下面一个场景：</p>\\n<!-- language:uml -->\\n<pre><code>Selling --> Store\\nSelling --> Product\\n</code></pre>\\n<p>简单说，一个商场内有很多商店(Store)，每个商店卖(Selling)很多种商品(Product)，如果希望找出所有销售玩具的商店：</p>\\n<!-- language:java -->\\n<pre><code>public List&#x3C;Store> findByProductCategory(Category category) {\\n  if (category == null)               &#x3C;1>\\n    return null;\\n  List&#x3C;Product> allProducts = getAllProducts(); // DB lookup\\n  for (Product prod : allProducts) {\\n    if (prod.category == null)        &#x3C;2>\\n      continue; \\n    if (category.equals(prod.category)){\\n    \\n</code></pre>\\n<h2>参考</h2>\\n<ol>\\n<li><a href=\\\"https://tersesystems.com/2012/12/27/error-handling-in-scala/\\\">Error Handling in Scala. https://tersesystems.com/2012/12/27/error-handling-in-scala. 2012</a></li>\\n</ol>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2014/Scala函数式异常处理.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2014-05-04T07:16:45.000Z\",\"path\":\"/2014/scala-error-handling-in-fp-style\",\"title\":\"Scala函数式异常处理\",\"excerpt\":\"经常看到很多示例代码，简洁的让人爱不释手，可是真正自己实现的时候，不得不添加各种各样的异常处理逻辑，最后发现代码总量的80%都是再做异常处理，而真正的代码逻辑只有很少的一部分。\",\"tags\":[\"scala\",\"functional programming\",\"exception handling\"]}}}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---2015-mysql-replication-on-docker-e9bfdc9d9cfdff079bd8.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h2>Pull Mysql Docker Image</h2>\\n<!-- language: bash -->\\n<pre><code>docker pull mysql:5.6\\n</code></pre>\\n<h2>Create MySQL Config Files</h2>\\n<p>For Master, create a <code>mysql.cnf</code> file and add the following content:</p>\\n<!-- language: bash -->\\n<pre><code>[mysqld]\\n\\nserver-id = 1\\nlog_bin\\nbinlog_format = ROW\\nbind-address = 0.0.0.0\\n\\nsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES\\n</code></pre>\\n<p>For Slave, create another <code>mysql.cnf</code> and add the following content:</p>\\n<!-- language: bash -->\\n<pre><code>[mysqld]\\n\\nserver-id = 2\\nlog_bin\\nbinlog_format = ROW\\nbind-address = 0.0.0.0\\n\\nsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES\\n</code></pre>\\n<h2>Start Master/Slave MySQL Containers</h2>\\n<p>Start Master:</p>\\n<!-- language: bash -->\\n<pre><code>docker run --name master -v /my/master:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:5.6\\n</code></pre>\\n<p>Start Slave:</p>\\n<!-- language: bash -->\\n<pre><code>docker run --name slave -v /my/slave:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw --link master:master -d mysql:5.6\\n</code></pre>\\n<p>The slave node needs to link to master node.</p>\\n<h2>Setup Replication</h2>\\n<p>Check the master status:</p>\\n<!-- language: bash -->\\n<pre><code>mysql> show master status \\\\G\\n*************************** 1. row ***************************\\n             File: mysql-bin.000003\\n         Position: 120\\n     Binlog_Do_DB: \\n Binlog_Ignore_DB: \\nExecuted_Gtid_Set: \\n1 row in set (0.00 sec)\\n</code></pre>\\n<p>the above information is necessary for the slave configuration, especially the <code>File</code> and <code>Position</code>.</p>\\n<p>Connect to Slave node, in Mysql Shell:</p>\\n<!-- language: bash -->\\n<pre><code>mysql> change master to master_host='master',master_user='root',master_password='my-secret-pw',master_log_file='mysql-bin.000003',master_log_pos=120;  \\nQuery OK, 0 rows affected (0.00 sec)  \\n\\nmysql> start slave;\\nQuery OK, 0 rows affected (0.01 sec)\\n\\nmysql> show slave status\\\\G\\n\\n// until you see the following two options are 'Yes'\\nSlave_IO_Running: Yes  \\nSlave_SQL_Running: Yes  \\n</code></pre>\\n<p>You need to change the parameters like <code>master_log_file</code> and <code>master_log_pos</code> based on previous <code>show master status</code> output.</p>\\n<h2>Test</h2>\\n<p>Create some tables and insert some data on master, and check if those data are synced to slave. </p>\\n<h2>Change Data Capture (CDC)</h2>\\n<p>Here I used an open source library <a href=\\\"https://github.com/whitesock/open-replicator\\\">open-replicator</a></p>\\n<!-- language: scala -->\\n<pre><code>import com.google.code.or._\\nimport com.google.code.or.binlog._\\nimport com.google.code.or.binlog.impl.event.FormatDescriptionEvent\\n\\nval or = new OpenReplicator()\\nor.setUser(\\\"root\\\")\\nor.setPassword(\\\"my-secret-pw\\\")\\nor.setServerId(2);\\nor.setHost(\\\"slave\\\")\\nor.setPort(3306)\\nor.setBinlogPosition(120)\\nor.setBinlogFileName(\\\"mysql-bin.000004\\\")\\n\\nor.setBinlogEventListener(new BinlogEventListener() {\\n  def onEvents(event: BinlogEventV4) = {\\n\\n  }\\n})\\n\\nor.start()\\n</code></pre>\\n<p>TBD.\\nSee <code>com.linkedin.databus2.producers.ORListener</code></p>\\n<h2>References</h2>\\n<ol>\\n<li><a href=\\\"https://registry.hub.docker.com/_/mysql/\\\">Mysql Docker Official Repo</a></li>\\n<li><a href=\\\"https://github.com/linkedin/databus/wiki/Databus-for-MySQL\\\">Databus for MySQL</a></li>\\n</ol>\",\"frontmatter\":{\"title\":\"MySQL Master/Slave Replication on Docker\",\"date\":\"April 21, 2015\",\"path\":\"/2015/mysql-replication-on-docker\",\"tags\":[\"docker\",\"mysql\"],\"excerpt\":\"How to setup Mysql master/slave replication.\"}}},\"pathContext\":{\"prev\":{\"html\":\"<p>Scala的学习过程中，经常会碰到一些莫名其妙的现象，很多时候，这些语言层面的“怪象”都与scala编译器或者scala的类型系统有关。</p>\\n<p>本文不是对编译器和类型系统的介绍，而是重点介绍遇到这些现象的时候，用什么样的方式，拨开云雾见蓝天，通过这些工具获取一些细节帮你了解编译器和类型系统如何工作。工欲善其事，必先利其器。</p>\\n<h2>REPL</h2>\\n<p>Read-Evaluate-Print-Loop, 是一个所有学习scala的同学都要掌握的工具，可以帮你快速测试一些代码，了解一些library怎么使用。</p>\\n<p>在安装scala之后，命令行下执行<code>scala</code>，就会进入REPL.</p>\\n<!-- language: bash -->\\n<pre><code>$ scala\\nWelcome to Scala version 2.11.1 (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_65).\\nType in expressions to have them evaluated.\\nType :help for more information.\\n\\nscala>\\n</code></pre>\\n<p>如果是SBT项目，可以用<code>sbt console</code>进入，之后操作类型，不再重复。</p>\\n<h3>模式</h3>\\n<p>scala REPL有<a href=\\\"http://hongjiang.info/scala-repl-modes/\\\">几种模式</a>，其中比较常用的就是<code>:paste</code>，可以比较方便的输入多行，不过要注意，拷贝粘贴的代码中，不要有Tab，否则会触发auto code completion，出现一堆错误提示。</p>\\n<h3>反射</h3>\\n<h2>命令行参数</h2>\\n<p>通过<code>man scala</code>, <code>man scalac</code>，可以了解scala都有哪些参数可用。注意的是：scala的命令行参数中import了scalac的参数，所以可以在scala命令后面使用任何scalac的参数。其中比较有用的参数有：</p>\\n<ul>\\n<li><code>-X</code>系列，用于输出高级选项概要。也就是正式支持的选项，向后兼容。</li>\\n<li><code>-Y</code>系列。用于输出私有选项信息，可能随版本变化。参见<a href=\\\"http://www.scala-lang.org/old/node/9313\\\">[6]</a><a href=\\\"http://paulbutcher.com/2010/04/26/scala-compiler-advanced-options/\\\">[7]</a></li>\\n</ul>\\n<p><code>scala -X</code>，<code>scala -Y</code>可以分别列出当前版本所支持的所有选项。</p>\\n<h2>参考</h2>\\n<ol>\\n<li><a href=\\\"http://stackoverflow.com/questions/11055210/whats-the-easiest-way-to-use-reify-get-an-ast-of-an-expression-in-scala\\\">What's the easiest way to use reify (get an AST of) an expression in Scala? stackoverflow</a></li>\\n<li><a href=\\\"http://stackoverflow.com/questions/11392622/how-to-investigate-objects-types-etc-from-scala-repl\\\">How to investigate objects/types/etc. from Scala REPL? stackoverflow</a></li>\\n<li><a href=\\\"https://www.parleys.com/tutorial/51c38751e4b0d38b54f4625e/chapter0/about\\\">Practical Type Mining in Scala ,  scaladay 2013</a></li>\\n<li><a href=\\\"http://hongjiang.info/scala-repl-modes/\\\">REPL的几种模式, hongjiang</a></li>\\n<li><a href=\\\"http://docs.scala-lang.org/overviews/reflection/symbols-trees-types.html\\\">Symbols, Trees, and Types, scalaDoc</a></li>\\n<li><a href=\\\"http://www.scala-lang.org/old/node/9313\\\">Difference between -Y and -X compiler options, scala user forum</a></li>\\n<li><a href=\\\"http://paulbutcher.com/2010/04/26/scala-compiler-advanced-options/\\\">Scala Compiler Advanced Options</a></li>\\n</ol>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Scala雾里看花.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2015-04-23T19:16:45.000Z\",\"path\":\"/2015/scala-trouble-shooting\",\"title\":\"Scala雾里看花\",\"excerpt\":\"Scala的学习过程中，经常会碰到一些莫名其妙的现象，很多时候，这些语言层面的“怪象”都与scala编译器或者scala的类型系统有关。本文不是对编译器和类型系统的介绍，而是重点介绍遇到这些现象的时候，用什么样的方式，拨开云雾见蓝天，通过这些工具获取一些细节帮你了解编译器和类型系统如何工作。工欲善其事，必先利其器。\",\"tags\":[\"scala\",\"trouble shooting\"]}},\"next\":{\"html\":\"<p>经常看到很多示例代码，简洁的让人爱不释手，可是真正自己实现的时候，不得不添加各种各样的异常处理逻辑，最后发现代码总量的80%都是再做异常处理，而真正的代码逻辑只有很少的一部分。</p>\\n<p>异常处理对于指令式和函数式编程都是同样需要的，只是因为实现方式的不同，让函数式编程看上去更加简洁，优雅，不需要像指令式那么繁琐。</p>\\n<p>本文的目的，就是介绍函数式编程中常用的一些异常处理策略。记得把这些瑞士军刀放到你的百宝箱中，以后一定用得上。</p>\\n<h2>空判断Option</h2>\\n<p>如果采访100个程序员，让所有人投票他们在编程时最讨厌做的事情，但又经常犯错误的地方，我估计十有八九会是“空判断”了。</p>\\n<p><code>Null</code>代表着一个对象还没有被初始化，具体点是对象的指针还没有一个确切的地址。在面向对象编程时，因为操作的都是对象，为了避免在一个<code>null</code>上面调用方法，或者 get一个<code>null</code>上的属性，而导致“空值异常”，程序员不得不做下面的事情：</p>\\n<p>假设有下面一个场景：</p>\\n<!-- language:uml -->\\n<pre><code>Selling --> Store\\nSelling --> Product\\n</code></pre>\\n<p>简单说，一个商场内有很多商店(Store)，每个商店卖(Selling)很多种商品(Product)，如果希望找出所有销售玩具的商店：</p>\\n<!-- language:java -->\\n<pre><code>public List&#x3C;Store> findByProductCategory(Category category) {\\n  if (category == null)               &#x3C;1>\\n    return null;\\n  List&#x3C;Product> allProducts = getAllProducts(); // DB lookup\\n  for (Product prod : allProducts) {\\n    if (prod.category == null)        &#x3C;2>\\n      continue; \\n    if (category.equals(prod.category)){\\n    \\n</code></pre>\\n<h2>参考</h2>\\n<ol>\\n<li><a href=\\\"https://tersesystems.com/2012/12/27/error-handling-in-scala/\\\">Error Handling in Scala. https://tersesystems.com/2012/12/27/error-handling-in-scala. 2012</a></li>\\n</ol>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2014/Scala函数式异常处理.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2014-05-04T07:16:45.000Z\",\"path\":\"/2014/scala-error-handling-in-fp-style\",\"title\":\"Scala函数式异常处理\",\"excerpt\":\"经常看到很多示例代码，简洁的让人爱不释手，可是真正自己实现的时候，不得不添加各种各样的异常处理逻辑，最后发现代码总量的80%都是再做异常处理，而真正的代码逻辑只有很少的一部分。\",\"tags\":[\"scala\",\"functional programming\",\"exception handling\"]}}}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/2015-mysql-replication-on-docker.json\n// module id = 398\n// module chunks = 138741863182975"],"sourceRoot":""}