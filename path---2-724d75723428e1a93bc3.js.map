{"version":3,"sources":["webpack:///path---2-724d75723428e1a93bc3.js","webpack:///./.cache/json/2.json"],"names":["webpackJsonp","388","module","exports","data","allMarkdownRemark","totalCount","edges","node","id","frontmatter","title","date","path","tags","excerpt","pathContext","group","html","pathPrefix","first","last","index","pageCount"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,mBAAqBC,WAAA,GAAAC,QAA0BC,MAAQC,GAAA,2HAAAC,aAA+IC,MAAA,8BAAAC,KAAA,iBAAAC,KAAA,0CAAAC,MAAA,6CAAAC,QAAA,uCAAqNP,MAAQC,GAAA,wHAAAC,aAA4IC,MAAA,2BAAAC,KAAA,gBAAAC,KAAA,iCAAAC,MAAA,QAAAC,QAAA,OAAmIP,MAAQC,GAAA,qHAAAC,aAAyIC,MAAA,0BAAAC,KAAA,iBAAAC,KAAA,8DAAAC,MAAA,eAAAC,QAAA,6BAA6LP,MAAQC,GAAA,6GAAAC,aAAiIC,MAAA,gBAAAC,KAAA,iBAAAC,KAAA,kDAAAC,MAAA,mCAAAC,QAAA,oCAAkMP,MAAQC,GAAA,+GAAAC,aAAmIC,MAAA,kBAAAC,KAAA,iBAAAC,KAAA,2CAAAC,MAAA,iBAAAC,QAAA,yFAAgOP,MAAQC,GAAA,iHAAAC,aAAqIC,MAAA,oBAAAC,KAAA,iBAAAC,KAAA,wCAAAC,MAAA,QAAAC,QAAA,gEAA6LP,MAAQC,GAAA,4GAAAC,aAAgIC,MAAA,0BAAAC,KAAA,iBAAAC,KAAA,yBAAAC,MAAA,0BAAAC,QAAA,sBAA4JP,MAAQC,GAAA,mHAAAC,aAAuIC,MAAA,wBAAAC,KAAA,iBAAAC,KAAA,oCAAAC,MAAA,mCAAAC,QAAA,yCAAiMP,MAAQC,GAAA,0GAAAC,aAA8HC,MAAA,gBAAAC,KAAA,iBAAAC,KAAA,WAAAC,MAAA,oBAAAC,QAAA,uIAA+OP,MAAQC,GAAA,2GAAAC,aAA+HC,MAAA,gBAAAC,KAAA,oBAAAC,KAAA,yCAAAC,MAAA,kCAAAC,QAAA,oGAA2PP,MAAQC,GAAA,8GAAAC,aAAkIC,MAAA,uBAAAC,KAAA,kBAAAC,KAAA,8BAAAC,MAAA,gDAAAC,QAAA,kJAAiTP,MAAQC,GAAA,yGAAAC,aAA6HC,MAAA,YAAAC,KAAA,iBAAAC,KAAA,+BAAAC,MAAA,4BAAAC,QAAA,qKAAqSP,MAAQC,GAAA,wHAAAC,aAA4IC,MAAA,2CAAAC,KAAA,iBAAAC,KAAA,oCAAAC,MAAA,kBAAAC,QAAA,mDAA6MP,MAAQC,GAAA,4GAAAC,aAAgIC,MAAA,eAAAC,KAAA,eAAAC,KAAA,yCAAAC,MAAA,uDAAAC,QAAA,+FAAqQP,MAAQC,GAAA,oGAAAC,aAAwHC,MAAA,mCAAAC,KAAA,mBAAAC,KAAA,kCAAAC,MAAA,6CAAAC,QAAA,wCAAqNP,MAAQC,GAAA,+GAAAC,aAAmIC,MAAA,4BAAAC,KAAA,oBAAAC,KAAA,wBAAAC,MAAA,kCAAAC,QAAA,kDAAoMP,MAAQC,GAAA,sGAAAC,aAA0HC,MAAA,eAAAC,KAAA,oBAAAC,KAAA,aAAAC,MAAA,yCAAAC,QAAA,0EAA2MP,MAAQC,GAAA,qGAAAC,aAAyHC,MAAA,QAAAC,KAAA,oBAAAC,KAAA,cAAAC,MAAA,0CAAAC,QAAA,sHAAkPP,MAAQC,GAAA,oGAAAC,aAAwHC,MAAA,OAAAC,KAAA,oBAAAC,KAAA,4BAAAC,MAAA,wDAAAC,QAAA,uDAA8MP,MAAQC,GAAA,iHAAAC,aAAqIC,MAAA,2BAAAC,KAAA,oBAAAC,KAAA,sCAAAC,MAAA,kCAAAC,QAAA,8GAA6QP,MAAQC,GAAA,8HAAAC,aAAkJC,MAAA,qCAAAC,KAAA,oBAAAC,KAAA,uCAAAC,MAAA,gCAAAC,QAAA,+GAAuRP,MAAQC,GAAA,mHAAAC,aAAuIC,MAAA,6BAAAC,KAAA,oBAAAC,KAAA,sCAAAC,MAAA,8BAAAC,QAAA,uCAAoMP,MAAQC,GAAA,gIAAAC,aAAoJC,MAAA,mCAAAC,KAAA,oBAAAC,KAAA,iCAAAC,MAAA,yBAAAC,QAAA,sCAA+LP,MAAQC,GAAA,kHAAAC,aAAsIC,MAAA,uBAAAC,KAAA,oBAAAC,KAAA,+BAAAC,MAAA,mBAAAC,QAAA,oFAAyNP,MAAQC,GAAA,kGAAAC,aAAsHC,MAAA,KAAAC,KAAA,mBAAAC,KAAA,cAAAC,QAAAC,QAAA,aAA4FC,aAAgBC,QAAUT,MAAQU,KAAA,+sKAAwqKT,GAAA,8GAAAC,aAA8NE,KAAA,2BAAAC,KAAA,8BAAAF,MAAA,uBAAAI,QAAA,8IAAAD,MAAA,oDAA0TN,MAAQU,KAAA,o1EAAAT,GAAA,yGAAAC,aAA2+EE,KAAA,2BAAAC,KAAA,+BAAAF,MAAA,YAAAI,QAAA,iKAAAD,MAAA,gCAA+SN,MAAQU,KAAA,+1GAAyhGT,GAAA,wHAAAC,aAA6dE,KAAA,2BAAAC,KAAA,oCAAAF,MAAA,2CAAAI,QAAA,+CAAAD,MAAA,sBAAuNN,MAAQU,KAAA,2vCAAiiCT,GAAA,4GAAAC,aAAmWE,KAAA,2BAAAC,KAAA,yCAAAF,MAAA,eAAAI,QAAA,2FAAAD,MAAA,2DAAiRN,MAAQU,KAAA;AAA29gBT,GAAA,oGAAAC,aAA4gDE,KAAA,2BAAAC,KAAA,kCAAAF,MAAA,mCAAAI,QAAA,oCAAAD,MAAA,iDAA6NN,MAAQU,KAAA,m+OAA29OT,GAAA,+GAAAC,aAAoJE,KAAA,2BAAAC,KAAA,wBAAAF,MAAA,4BAAAI,QAAA,8CAAAD,MAAA,sCAA2MN,MAAQU,KAAA,+pHAAupHT,GAAA,sGAAAC,aAA2IE,KAAA,2BAAAC,KAAA,aAAAF,MAAA,eAAAI,QAAA,sEAAAD,MAAA,6CAAkNN,MAAQU,KAAA,+7EAAqxET,GAAA,qGAAAC,aAA0SE,KAAA,2BAAAC,KAAA,cAAAF,MAAA,QAAAI,QAAA,kHAAAD,MAAA,8CAAyPN,MAAQU,KAAA,0/HAA+8HT,GAAA,oGAAAC,aAAqLE,KAAA,2BAAAC,KAAA,4BAAAF,MAAA,OAAAI,QAAA,mDAAAD,MAAA,4DAAqNN,MAAQU,KAAA,y6EAA+yET,GAAA,iHAAAC,aAAwQE,KAAA,2BAAAC,KAAA,sCAAAF,MAAA,2BAAAI,QAAA,0GAAAD,MAAA,sCAAkRK,WAAA,GAAAC,OAAA,EAAAC,MAAA,EAAAC,MAAA,EAAAC,UAAA","file":"path---2-724d75723428e1a93bc3.js","sourcesContent":["webpackJsonp([157285553617042],{\n\n/***/ 388:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"allMarkdownRemark\":{\"totalCount\":25,\"edges\":[{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2019/Tokio Future.poll返回NotReady.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Tokio Future.poll返回NotReady\",\"date\":\"March 01, 2019\",\"path\":\"/2019/rust-tokio-futures-poll-not-ready\",\"tags\":[\"rust\",\"tokio\",\"Future\",\"async programming\"],\"excerpt\":\"如何在Future.poll中返回Async::NotReady\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/How To Read Rust API Doc.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"How To Read Rust API Doc\",\"date\":\"June 01, 2018\",\"path\":\"/2018/how-to-read-rust-api-doc\",\"tags\":[\"rust\"],\"excerpt\":\"\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/简单比较下http2和http1.1的性能.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"简单比较下http/2和http/1.1的性能\",\"date\":\"March 19, 2018\",\"path\":\"/2018/simple-performance-comparison-between-http2-and-http1\",\"tags\":[\"http/2\",\"测试\"],\"excerpt\":\"简单对比http/1.1和http/2的性能\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/微服务架构下的开发环境问题.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"微服务架构下的开发环境问题\",\"date\":\"March 16, 2018\",\"path\":\"/2018/development-environment-for-microservices\",\"tags\":[\"微服务\",\"架构\",\"开发环境\",\"microservices\"],\"excerpt\":\"本文介绍如何在微服务架构下解决开发环境的搭建、共享的问题。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/为Gatsby博客添加分页功能.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"为Gatsby博客添加分页功能\",\"date\":\"March 12, 2018\",\"path\":\"/2018/support-pagination-for-gatsby-blog\",\"tags\":[\"blog\",\"gatsby\"],\"excerpt\":\"根据Egghead上的教程，做出的博客站点有个缺陷，那就是没有分页功能，对于勤奋的博主来说，在一个页面上显示所有文章列表有点不完美，这里我们改造一下，加入分页功能。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/为你的Gatsby博客添加评论功能.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"为你的Gatsby博客添加评论功能\",\"date\":\"March 12, 2018\",\"path\":\"/2018/enable-comments-for-gatsby-blog\",\"tags\":[\"blog\"],\"excerpt\":\"Gatsby打造的博客已经很不错了，但是缺少一个评论功能。本文简单介绍如何集成Disqus评论服务到你的博客站点。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/转用Gatsby搭建博客.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"转用Gatsby打造基于github的博客站点\",\"date\":\"March 08, 2018\",\"path\":\"/2018/blog-with-gatsby\",\"tags\":[\"blog\",\"github\",\"gatsby\"],\"excerpt\":\"如何用Gatsby打造一个博客\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/一则奇怪的Toubleshooting.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"记一次奇怪的troubleshooting\",\"date\":\"March 08, 2018\",\"path\":\"/2018/skipper-sni-domain-fronting\",\"tags\":[\"skipper\",\"SNI\",\"domain fronting\"],\"excerpt\":\"在Skipper转发请求到一个https站点的时候，返回莫名404.\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2016/JSON解析利器JQ.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"JSON解析利器---JQ\",\"date\":\"March 25, 2016\",\"path\":\"/2016/jq\",\"tags\":[\"bash\",\"jq\",\"json\"],\"excerpt\":\"在API first的时代，json作为最常用的格式，充斥着程序猿的屏幕各个角落，掌握一门解析、过滤、转换json输出的工具，已经成为程序猿们安身立命的必要技能。 这里隆重向大家介绍[jq](https://stedolan.github.io/jq/).\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2016/Function的协变.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Function的协、逆变\",\"date\":\"February 04, 2016\",\"path\":\"/2016/function-covariant-contravariant\",\"tags\":[\"scala\",\"functional programming\"],\"excerpt\":\"泛型编程的时候，协变(covariant)还是逆变(contravariant)很重要，在设计上层API接口的时候，正确的使用协变、逆变可以更好地约束程序员的行为，让实现变得安全、一致。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/如何在Scala中实现AOP.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"用Mixin组合实现Scala中的AOP\",\"date\":\"August 13, 2015\",\"path\":\"/2015/aop-by-mixin-in-scala\",\"tags\":[\"scala\",\"functional programming\",\"AOP\",\"mixin\"],\"excerpt\":\"在Java世界，AOP（Aspect Oriented Programming， 面向方面编程)是很多框架的基础。这种将关注点按照“方面”来切分的编程模型极大地简化了编程的复杂度，尤其是在多维度因子交织在一起的时候的各种场景。对于代码的可读性、可维护性、可重用性都是极大的帮助。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Scala雾里看花.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Scala雾里看花\",\"date\":\"April 23, 2015\",\"path\":\"/2015/scala-trouble-shooting\",\"tags\":[\"scala\",\"trouble shooting\"],\"excerpt\":\"Scala的学习过程中，经常会碰到一些莫名其妙的现象，很多时候，这些语言层面的“怪象”都与scala编译器或者scala的类型系统有关。本文不是对编译器和类型系统的介绍，而是重点介绍遇到这些现象的时候，用什么样的方式，拨开云雾见蓝天，通过这些工具获取一些细节帮你了解编译器和类型系统如何工作。工欲善其事，必先利其器。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Docker创建MySQL主从复制以及CDC测试.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"MySQL Master/Slave Replication on Docker\",\"date\":\"April 21, 2015\",\"path\":\"/2015/mysql-replication-on-docker\",\"tags\":[\"docker\",\"mysql\"],\"excerpt\":\"How to setup Mysql master/slave replication.\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2014/Scala函数式异常处理.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Scala函数式异常处理\",\"date\":\"May 04, 2014\",\"path\":\"/2014/scala-error-handling-in-fp-style\",\"tags\":[\"scala\",\"functional programming\",\"exception handling\"],\"excerpt\":\"经常看到很多示例代码，简洁的让人爱不释手，可是真正自己实现的时候，不得不添加各种各样的异常处理逻辑，最后发现代码总量的80%都是再做异常处理，而真正的代码逻辑只有很少的一部分。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2014/高种泛型.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"高种泛型 (Generics of a Higher Kind)\",\"date\":\"January 08, 2014\",\"path\":\"/2014/generics-of-a-higher-kind\",\"tags\":[\"scala\",\"functional programming\",\"Generics\"],\"excerpt\":\"Generics of a Higher Kind翻译加自我理解。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/map-flatMap-for.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"map/flatMap/for in Action\",\"date\":\"December 01, 2013\",\"path\":\"/2013/map-flatmap-for\",\"tags\":[\"scala\",\"functional programming\"],\"excerpt\":\"前文说过了，高阶函数式函数式语言中的基石，而`map`, `flatMap`更是重要。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/fold编程.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"折纸的艺术：fold编程\",\"date\":\"November 27, 2013\",\"path\":\"/2013/fold\",\"tags\":[\"scala\",\"functional programming\",\"fold\"],\"excerpt\":\"Eric Meijer说：递归是函数式编程的GOTO，应该尽可能避免。如何避免，OO中我们用while循环，FP中我们用`fold`。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Monad.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Monad\",\"date\":\"November 26, 2013\",\"path\":\"/2013/monad\",\"tags\":[\"scala\",\"functional programming\",\"monad\"],\"excerpt\":\"函数式语言与OO（确切地讲是指令式编程）的思维方式是完全不同的，很多OO中的经验在函数式语言中不是很匹配，比如设计模式，那就是一个OO中的特定术语，而在FP中，大家常谈的是对于习惯OO思维的程序员来说玄而又玄的Monad。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/高阶函数.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"高阶函数\",\"date\":\"November 21, 2013\",\"path\":\"/2013/high-order-function\",\"tags\":[\"scala\",\"functional programming\",\"high order function\"],\"excerpt\":\"所谓高阶函数（high order function），其实就是可以接受其他函数作为参数的函数。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Actor协调并发场景下的集合操作.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"边建边学-3：Actor协调并发场景下的集合操作\",\"date\":\"November 17, 2013\",\"path\":\"/2013/actor-collection-collabration\",\"tags\":[\"scala\",\"functional programming\"],\"excerpt\":\"很多时候为了提高性能，减少IO操作，都会将数据load出来之后缓存在内存中。本站的实现过程中也遇到类似的问题，不希望每次有人访问的时候就读取一次md文件，或者从MongoDB中查一次，而是直接在内存中读取。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Enumerator-Iteratee-Enumeratee.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Enumerator / Iteratee / Enumeratee\",\"date\":\"November 11, 2013\",\"path\":\"/2013/enumerator-iteratee-enumeratee\",\"tags\":[\"scala\",\"playframework\",\"blog\"],\"excerpt\":\"Stream对于指令式编程已经比较成熟了，有大量的类库，丰富的API。但是对于强调不可变量，尽可能无副作用的FP来说，要考虑语言适配的问题，而目前，流行的解决方案就是：Enumerator/Iteratee。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/集成PlantUML和Markdown.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"边建边学-2：集成PlantUML和Markdown\",\"date\":\"November 07, 2013\",\"path\":\"/2013/markdown-plantuml-integration\",\"tags\":[\"markdown\",\"plantuml\",\"blog\"],\"excerpt\":\"如何用Markdown+PlantUML结合来写图文并茂的博客。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/EssentialAction-in-Playframework.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"EssentialAction in Playframework\",\"date\":\"November 05, 2013\",\"path\":\"/2013/essential-action-in-play\",\"tags\":[\"scala\",\"playframework\"],\"excerpt\":\"Playframework中EssentialAction理解\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/用markdown写博客.markdown absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"边建边学-1: 用Markdown写博文\",\"date\":\"November 01, 2013\",\"path\":\"/2013/blogging-with-markdown\",\"tags\":[\"markdown\",\"blog\"],\"excerpt\":\"本文将是一个系列文章，循序渐进地介绍本站的构建过程，不只是简单的技术介绍，重点是建站过程遇到的问题分析，以及解决的过程，所以起名**“边建边学”**系列。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/开篇.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"开篇\",\"date\":\"October 25, 2013\",\"path\":\"/2013/start\",\"tags\":[],\"excerpt\":\"网络博客\"}}}]}},\"pathContext\":{\"group\":[{\"node\":{\"html\":\"<h2>Java中的AOP</h2>\\n<p>在Java世界，AOP（Aspect Oriented Programming， 面向方面编程)是很多框架的基础。这种将关注点按照“方面”来切分的编程模型极大地简化了编程的复杂度，尤其是在多维度因子交织在一起的时候的各种场景。对于代码的可读性、可维护性、可重用性都是极大的帮助。</p>\\n<p>不过AOP一个令人诟病的地方是其透明性，也就是说对于开发人员来说，我不知道我的某个方法会不会被某个Aspect切面一刀，有些时候，会造成一些意想不到的后果，比如Spring的transaction管理，如果通过aop的方式来定义，比如：</p>\\n<!-- language: xml -->\\n<pre><code>&#x3C;tx:advice id=\\\"txCommonAdvice\\\" transaction-manager=\\\"transactionManager\\\">\\n    &#x3C;tx:attributes>\\n        &#x3C;tx:method name=\\\"save*\\\" propagation=\\\"REQUIRED\\\"/>\\n        &#x3C;tx:method name=\\\"remove*\\\" propagation=\\\"REQUIRED\\\"/>\\n        &#x3C;tx:method name=\\\"update*\\\" propagation=\\\"REQUIRED\\\"/>\\n        &#x3C;tx:method name=\\\"delete*\\\" propagation=\\\"REQUIRED\\\"/>\\n        &#x3C;tx:method name=\\\"*\\\" propagation=\\\"REQUIRED\\\" read-only=\\\"true\\\"/>\\n    &#x3C;/tx:attributes>\\n&#x3C;/tx:advice>\\n</code></pre>\\n<p>那么被这个切面拦截的任何方法都会导致Spring Transaction Manager启动一个事务，甚至是像<code>toString()</code>, <code>equal(other)</code>等这样的方法，而且因为其透明性，开发人员往往意识不到这个问题。</p>\\n<h2>Scala中的AOP</h2>\\n<p>在Scala的世界里，AOP的思想其实也是适用的，当然，因为Scala就运行在jvm上面，很多code weaver工具也照样是可以用的，比如aspectj, asm等等，个人不是很喜欢这些东西，更喜欢用显式的方式来告诉我的代码读者，我的代码会做哪些事情。No Magic，是我的一个信条。</p>\\n<p>Scala的Mixin机制trait，可以很好地实现显式的AOP，举个例子：</p>\\n<!-- language: scala run -->\\n<pre><code>trait Task { def execute }\\ntrait TaskLogging extends Task {\\n    abstract override def execute = {\\n        println(\\\"before execute\\\")\\n        super.execute\\n        println(\\\"after execute\\\")\\n    }\\n}\\nclass MyTask extends Task {\\n    override def execute = {\\n        println(\\\"do something\\\")\\n    }\\n}\\n\\nval task = new MyTask\\ntask.execute    // 输出 'do something'，没什么稀奇的\\n\\nval task2 = new MyTask with TaskLogging\\ntask2.execute   // 点击'run'看看会输出什么？\\n</code></pre>\\n<p>在上面代码中，<code>MyTask</code>和<code>TaskLogging</code>都是只关注于自己的逻辑（Aspect），在运行时，可以构建一个<code>MyTask with TaskLogging</code>的<code>task2</code>instance，就可以将两个方面组合在一起了。当然你还可以增加新的方面，比如：</p>\\n<!-- language: scala -->\\n<pre><code>trait Transactional extends Task {\\n    abstract override def execute = {\\n        println(\\\"begin transaction\\\")\\n        try {\\n            super.execute\\n            println(\\\"commit transaction\\\")\\n        } catch {\\n            case _: Exception =>\\n                println(\\\"rollback transaction\\\")\\n        }\\n    }\\n}\\n\\nval task3 = new MyTask with TaskLogging with Transactional\\ntask3.execute\\n</code></pre>\\n<p>这样，就可以构建一个有事务，有logging的task。</p>\\n<p>总结一下，定义一个Aspect的步骤：</p>\\n<ol>\\n<li>重载trait中的方法</li>\\n<li>方法前逻辑，比如logging、begin transaction等等</li>\\n<li>调用<code>super</code>对象的方法</li>\\n<li>方法后逻辑，比如logging、commit transaction等</li>\\n</ol>\\n<p>这里，主要的知识点是调用<code>super.execute</code>的执行顺序，在用<code>with Trait</code>定义一个新类型的时候，多个Trait会形成一个Stack，执行的时候会按照出栈顺序执行，比如：</p>\\n<!-- language: scala -->\\n<pre><code>val task = new MyTask with TaskLogging with Transactional\\ntask.execute\\n</code></pre>\\n<p>TaskLogging先入栈，Transactional后入，那么执行的时候，先执行Transactional，后执行TaskLogging，就会输出：</p>\\n<!-- language -->\\n<pre><code>begin transaction\\nbefore execute\\ndo something\\nafter execute\\ncommit transaction\\n</code></pre>\\n<p>换一个顺序：</p>\\n<!-- language: scala -->\\n<pre><code>val task = new MyTask with TaskLogging with Transactional\\ntask.execute\\n</code></pre>\\n<p>那么输出将会是另外一个顺序。    </p>\\n<h3>抽象方法中的super call</h3>\\n<p>注意一个细节，在<code>TaskLogging.execute</code>中，我们调用了<code>super.execute</code>，仔细想想，感觉很奇怪，几个疑点：</p>\\n<ol>\\n<li>TaskLogging的super是谁？</li>\\n<li>为什么<code>MyTask.execute</code>是最后执行的？</li>\\n</ol>\\n<p>查询《Programming in Scala》“traits as stackable modifications“章节后，我们可以了解到：</p>\\n<ol>\\n<li>trait中的super call是动态绑定，是在另外一个trait或者class实现一个具体的方法之后。</li>\\n<li>所以trait中的方法必须标注: <code>abstract override</code>，以此来告诉编译器，你是故意这么来用的。</li>\\n</ol>\\n<p>用scalac编译上述源文件，生成.class文件之后，用<code>jad</code>等工具查看反编译类，会发现其实<code>MyTask with TaskLogging</code>会产生一个匿名类，继承MyTask，实现TaskLogging接口，回头再看TaskLogging中定义的<code>super.execute</code>，就能理解了，原来在调用TaskLogging.execute方法的时候的<code>this</code>，已经是匿名类的实例了，当然其super是合法的。然后其执行顺序也就能理解了。</p>\\n<p>但是这里明显有一个矛盾：从代码执行角度看，生成的匿名类是MyTask和TaskLogging的子类，这点可以通过<code>task.isInstanceOf[MyTask] &#x26;&#x26; task.isInstanceOf[TaskLogging]</code>中判断得出，但是从字面上看，在trait TaskLogging中调用<code>super.execute</code>，又给人感觉莫名其妙。可能这也是scala需要在jvm上运行所做的妥协吧。</p>\\n<h2>Stackable Actor模式</h2>\\n<p>在Akka中，这种Mixin的用法非常的有帮助，比如在对actor进行监控的时候，我们希望能记录每个actor发送消息的路径，每个actor接收消息之后处理所花费的时间、调用次数等等，如果不用这种trait mixin的话，代码将非常凌乱。</p>\\n<p>之所以单独将这个模式提出来，其实还因为这个模式中利用了PartialFunction的特性，让代码更加的优雅。看例子：</p>\\n<!-- language: scala run -->\\n<pre><code>type Receive = PartialFunction[Any, Unit]\\n\\ntrait Actor {\\n    def receive: Receive\\n    def unhandled(msg: Any): Unit = println(s\\\"unhandled message: $msg\\\")\\n}\\n\\ntrait StackableActor extends Actor {\\n    def wrapped: Receive\\n    def receive: Receive = {\\n        case x => if (wrapped.isDefinedAt(x)) wrapped(x) else unhandled(x)\\n    }\\n}\\n\\n trait LoggingActor extends StackableActor { \\n    override def wrapped: Receive = { \\n        case x => \\n            println(s\\\"start processing message: $x\\\")\\n            super.receive(x)\\n            println(\\\"end of processing message:\\\" + x) \\n    }\\n}\\n\\nclass MyActor extends StackableActor with LoggingActor {\\n    override def wrapped: Receive = {\\n        case \\\"something\\\" =>\\n            println(\\\"I can only do 'something'\\\")\\n    }\\n}\\n\\nnew MyActor() receive (\\\"something\\\")\\nnew MyActor() receive (\\\"else\\\")\\n</code></pre>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/如何在Scala中实现AOP.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2015-08-13T10:16:45.000Z\",\"path\":\"/2015/aop-by-mixin-in-scala\",\"title\":\"用Mixin组合实现Scala中的AOP\",\"excerpt\":\"在Java世界，AOP（Aspect Oriented Programming， 面向方面编程)是很多框架的基础。这种将关注点按照“方面”来切分的编程模型极大地简化了编程的复杂度，尤其是在多维度因子交织在一起的时候的各种场景。对于代码的可读性、可维护性、可重用性都是极大的帮助。\",\"tags\":[\"scala\",\"functional programming\",\"AOP\",\"mixin\"]}}},{\"node\":{\"html\":\"<p>Scala的学习过程中，经常会碰到一些莫名其妙的现象，很多时候，这些语言层面的“怪象”都与scala编译器或者scala的类型系统有关。</p>\\n<p>本文不是对编译器和类型系统的介绍，而是重点介绍遇到这些现象的时候，用什么样的方式，拨开云雾见蓝天，通过这些工具获取一些细节帮你了解编译器和类型系统如何工作。工欲善其事，必先利其器。</p>\\n<h2>REPL</h2>\\n<p>Read-Evaluate-Print-Loop, 是一个所有学习scala的同学都要掌握的工具，可以帮你快速测试一些代码，了解一些library怎么使用。</p>\\n<p>在安装scala之后，命令行下执行<code>scala</code>，就会进入REPL.</p>\\n<!-- language: bash -->\\n<pre><code>$ scala\\nWelcome to Scala version 2.11.1 (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_65).\\nType in expressions to have them evaluated.\\nType :help for more information.\\n\\nscala>\\n</code></pre>\\n<p>如果是SBT项目，可以用<code>sbt console</code>进入，之后操作类型，不再重复。</p>\\n<h3>模式</h3>\\n<p>scala REPL有<a href=\\\"http://hongjiang.info/scala-repl-modes/\\\">几种模式</a>，其中比较常用的就是<code>:paste</code>，可以比较方便的输入多行，不过要注意，拷贝粘贴的代码中，不要有Tab，否则会触发auto code completion，出现一堆错误提示。</p>\\n<h3>反射</h3>\\n<h2>命令行参数</h2>\\n<p>通过<code>man scala</code>, <code>man scalac</code>，可以了解scala都有哪些参数可用。注意的是：scala的命令行参数中import了scalac的参数，所以可以在scala命令后面使用任何scalac的参数。其中比较有用的参数有：</p>\\n<ul>\\n<li><code>-X</code>系列，用于输出高级选项概要。也就是正式支持的选项，向后兼容。</li>\\n<li><code>-Y</code>系列。用于输出私有选项信息，可能随版本变化。参见<a href=\\\"http://www.scala-lang.org/old/node/9313\\\">[6]</a><a href=\\\"http://paulbutcher.com/2010/04/26/scala-compiler-advanced-options/\\\">[7]</a></li>\\n</ul>\\n<p><code>scala -X</code>，<code>scala -Y</code>可以分别列出当前版本所支持的所有选项。</p>\\n<h2>参考</h2>\\n<ol>\\n<li><a href=\\\"http://stackoverflow.com/questions/11055210/whats-the-easiest-way-to-use-reify-get-an-ast-of-an-expression-in-scala\\\">What's the easiest way to use reify (get an AST of) an expression in Scala? stackoverflow</a></li>\\n<li><a href=\\\"http://stackoverflow.com/questions/11392622/how-to-investigate-objects-types-etc-from-scala-repl\\\">How to investigate objects/types/etc. from Scala REPL? stackoverflow</a></li>\\n<li><a href=\\\"https://www.parleys.com/tutorial/51c38751e4b0d38b54f4625e/chapter0/about\\\">Practical Type Mining in Scala ,  scaladay 2013</a></li>\\n<li><a href=\\\"http://hongjiang.info/scala-repl-modes/\\\">REPL的几种模式, hongjiang</a></li>\\n<li><a href=\\\"http://docs.scala-lang.org/overviews/reflection/symbols-trees-types.html\\\">Symbols, Trees, and Types, scalaDoc</a></li>\\n<li><a href=\\\"http://www.scala-lang.org/old/node/9313\\\">Difference between -Y and -X compiler options, scala user forum</a></li>\\n<li><a href=\\\"http://paulbutcher.com/2010/04/26/scala-compiler-advanced-options/\\\">Scala Compiler Advanced Options</a></li>\\n</ol>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Scala雾里看花.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2015-04-23T19:16:45.000Z\",\"path\":\"/2015/scala-trouble-shooting\",\"title\":\"Scala雾里看花\",\"excerpt\":\"Scala的学习过程中，经常会碰到一些莫名其妙的现象，很多时候，这些语言层面的“怪象”都与scala编译器或者scala的类型系统有关。本文不是对编译器和类型系统的介绍，而是重点介绍遇到这些现象的时候，用什么样的方式，拨开云雾见蓝天，通过这些工具获取一些细节帮你了解编译器和类型系统如何工作。工欲善其事，必先利其器。\",\"tags\":[\"scala\",\"trouble shooting\"]}}},{\"node\":{\"html\":\"<h2>Pull Mysql Docker Image</h2>\\n<!-- language: bash -->\\n<pre><code>docker pull mysql:5.6\\n</code></pre>\\n<h2>Create MySQL Config Files</h2>\\n<p>For Master, create a <code>mysql.cnf</code> file and add the following content:</p>\\n<!-- language: bash -->\\n<pre><code>[mysqld]\\n\\nserver-id = 1\\nlog_bin\\nbinlog_format = ROW\\nbind-address = 0.0.0.0\\n\\nsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES\\n</code></pre>\\n<p>For Slave, create another <code>mysql.cnf</code> and add the following content:</p>\\n<!-- language: bash -->\\n<pre><code>[mysqld]\\n\\nserver-id = 2\\nlog_bin\\nbinlog_format = ROW\\nbind-address = 0.0.0.0\\n\\nsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES\\n</code></pre>\\n<h2>Start Master/Slave MySQL Containers</h2>\\n<p>Start Master:</p>\\n<!-- language: bash -->\\n<pre><code>docker run --name master -v /my/master:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:5.6\\n</code></pre>\\n<p>Start Slave:</p>\\n<!-- language: bash -->\\n<pre><code>docker run --name slave -v /my/slave:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw --link master:master -d mysql:5.6\\n</code></pre>\\n<p>The slave node needs to link to master node.</p>\\n<h2>Setup Replication</h2>\\n<p>Check the master status:</p>\\n<!-- language: bash -->\\n<pre><code>mysql> show master status \\\\G\\n*************************** 1. row ***************************\\n             File: mysql-bin.000003\\n         Position: 120\\n     Binlog_Do_DB: \\n Binlog_Ignore_DB: \\nExecuted_Gtid_Set: \\n1 row in set (0.00 sec)\\n</code></pre>\\n<p>the above information is necessary for the slave configuration, especially the <code>File</code> and <code>Position</code>.</p>\\n<p>Connect to Slave node, in Mysql Shell:</p>\\n<!-- language: bash -->\\n<pre><code>mysql> change master to master_host='master',master_user='root',master_password='my-secret-pw',master_log_file='mysql-bin.000003',master_log_pos=120;  \\nQuery OK, 0 rows affected (0.00 sec)  \\n\\nmysql> start slave;\\nQuery OK, 0 rows affected (0.01 sec)\\n\\nmysql> show slave status\\\\G\\n\\n// until you see the following two options are 'Yes'\\nSlave_IO_Running: Yes  \\nSlave_SQL_Running: Yes  \\n</code></pre>\\n<p>You need to change the parameters like <code>master_log_file</code> and <code>master_log_pos</code> based on previous <code>show master status</code> output.</p>\\n<h2>Test</h2>\\n<p>Create some tables and insert some data on master, and check if those data are synced to slave. </p>\\n<h2>Change Data Capture (CDC)</h2>\\n<p>Here I used an open source library <a href=\\\"https://github.com/whitesock/open-replicator\\\">open-replicator</a></p>\\n<!-- language: scala -->\\n<pre><code>import com.google.code.or._\\nimport com.google.code.or.binlog._\\nimport com.google.code.or.binlog.impl.event.FormatDescriptionEvent\\n\\nval or = new OpenReplicator()\\nor.setUser(\\\"root\\\")\\nor.setPassword(\\\"my-secret-pw\\\")\\nor.setServerId(2);\\nor.setHost(\\\"slave\\\")\\nor.setPort(3306)\\nor.setBinlogPosition(120)\\nor.setBinlogFileName(\\\"mysql-bin.000004\\\")\\n\\nor.setBinlogEventListener(new BinlogEventListener() {\\n  def onEvents(event: BinlogEventV4) = {\\n\\n  }\\n})\\n\\nor.start()\\n</code></pre>\\n<p>TBD.\\nSee <code>com.linkedin.databus2.producers.ORListener</code></p>\\n<h2>References</h2>\\n<ol>\\n<li><a href=\\\"https://registry.hub.docker.com/_/mysql/\\\">Mysql Docker Official Repo</a></li>\\n<li><a href=\\\"https://github.com/linkedin/databus/wiki/Databus-for-MySQL\\\">Databus for MySQL</a></li>\\n</ol>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Docker创建MySQL主从复制以及CDC测试.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2015-04-21T07:16:45.000Z\",\"path\":\"/2015/mysql-replication-on-docker\",\"title\":\"MySQL Master/Slave Replication on Docker\",\"excerpt\":\"How to setup Mysql master/slave replication.\",\"tags\":[\"docker\",\"mysql\"]}}},{\"node\":{\"html\":\"<p>经常看到很多示例代码，简洁的让人爱不释手，可是真正自己实现的时候，不得不添加各种各样的异常处理逻辑，最后发现代码总量的80%都是再做异常处理，而真正的代码逻辑只有很少的一部分。</p>\\n<p>异常处理对于指令式和函数式编程都是同样需要的，只是因为实现方式的不同，让函数式编程看上去更加简洁，优雅，不需要像指令式那么繁琐。</p>\\n<p>本文的目的，就是介绍函数式编程中常用的一些异常处理策略。记得把这些瑞士军刀放到你的百宝箱中，以后一定用得上。</p>\\n<h2>空判断Option</h2>\\n<p>如果采访100个程序员，让所有人投票他们在编程时最讨厌做的事情，但又经常犯错误的地方，我估计十有八九会是“空判断”了。</p>\\n<p><code>Null</code>代表着一个对象还没有被初始化，具体点是对象的指针还没有一个确切的地址。在面向对象编程时，因为操作的都是对象，为了避免在一个<code>null</code>上面调用方法，或者 get一个<code>null</code>上的属性，而导致“空值异常”，程序员不得不做下面的事情：</p>\\n<p>假设有下面一个场景：</p>\\n<!-- language:uml -->\\n<pre><code>Selling --> Store\\nSelling --> Product\\n</code></pre>\\n<p>简单说，一个商场内有很多商店(Store)，每个商店卖(Selling)很多种商品(Product)，如果希望找出所有销售玩具的商店：</p>\\n<!-- language:java -->\\n<pre><code>public List&#x3C;Store> findByProductCategory(Category category) {\\n  if (category == null)               &#x3C;1>\\n    return null;\\n  List&#x3C;Product> allProducts = getAllProducts(); // DB lookup\\n  for (Product prod : allProducts) {\\n    if (prod.category == null)        &#x3C;2>\\n      continue; \\n    if (category.equals(prod.category)){\\n    \\n</code></pre>\\n<h2>参考</h2>\\n<ol>\\n<li><a href=\\\"https://tersesystems.com/2012/12/27/error-handling-in-scala/\\\">Error Handling in Scala. https://tersesystems.com/2012/12/27/error-handling-in-scala. 2012</a></li>\\n</ol>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2014/Scala函数式异常处理.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2014-05-04T07:16:45.000Z\",\"path\":\"/2014/scala-error-handling-in-fp-style\",\"title\":\"Scala函数式异常处理\",\"excerpt\":\"经常看到很多示例代码，简洁的让人爱不释手，可是真正自己实现的时候，不得不添加各种各样的异常处理逻辑，最后发现代码总量的80%都是再做异常处理，而真正的代码逻辑只有很少的一部分。\",\"tags\":[\"scala\",\"functional programming\",\"exception handling\"]}}},{\"node\":{\"html\":\"<p>译者按语：很多翻译中将Kind和Type都翻译为“类型”，但实际上两者还是有不同的，本文中，将<code>Kind</code>翻译为“种类”，取王侯将相宁有种乎之意，是骨子里的东西。而将<code>type</code>译为“类型”。</p>\\n<p>学习函数式语言如果想真正入门，一个不可避免的话题就是monad/monoid，而这些范畴论中的词汇都异常抽象，难于理解，尤其是对于从java领域转过来的同学，在很多FP的基础东西不了解情况下来研究monad就更加的困难，比如高种泛型。</p>\\n<p><code>泛型</code> 我们都知道，就是某种类型的泛化（一般化），就是将某些特殊类型进行抽象，抽出一种一般化的类型<code>T</code>。而<code>高种泛型</code>就是在泛型的基础上再进行一次抽象。</p>\\n<ul>\\n<li>\\n<p>First Order Abstraction</p>\\n<p>first-order可以理解为”单次抽象“，将特定类型抽象一次，比如类型：<code>T</code>, <code>T</code>是什么？可以是任何具体类型，String，Integer，Date等等，不难发现，这就是Java中的泛型。</p>\\n</li>\\n<li>\\n<p>Higher Order Abstraction</p>\\n<p>对应first-order的单次抽象，高阶抽象就是再次抽象，也就是说：在某个东东的抽象上再进行抽象，抽象的抽象。晕了吧！</p>\\n</li>\\n</ul>\\n<p>在继续之前，我们还得熟悉几个概念：</p>\\n<ul>\\n<li>\\n<p>值构造器</p>\\n<p>值构造器是一个function / method，接受特定值参数来构造一个特定的值(value)</p>\\n<p>值构造器可以有多态：接受不同类型的参数，也可以是抽象abstract的。</p>\\n</li>\\n<li>\\n<p>类型构造器</p>\\n<p>类型构造器是一个类型，接受一个特定类型参数来构造一个特定的类型。</p>\\n<p>和值构造器一样，类型构造器也可以有多态，这是高阶类型的关键。</p>\\n</li>\\n</ul>\\n<p>先说这么多概念有什么用呢？我们还是先看一个具体的例子。</p>\\n<h2>例子：Iterable</h2>\\n<p>观察下面代码，我们来玩个找不同的游戏：</p>\\n<!-- language:scala -->\\n<pre><code>trait Iterable[T] {\\n  def filter(p: T => Boolean): Iterable[T]\\n  def remove(p: T => Boolean): Iterable[T] = filter(x => !p(x))\\n}\\n\\ntrait List[T] extends Iterable[T] {\\n  def filter(p: T => Boolean): List[T]\\n  override def remove(p: T => Boolean): List[T] = filter(x => !p(x))\\n}\\n</code></pre>\\n<p>看到两段代码有什么不同了吗？什么代码重复了？</p>\\n<p>很容易发现：在<code>List[T]</code>中的两个方法主体结构和<code>Iterable[T]</code>中的几乎完全相同，只是返回类型不同，都期望返回自身类型。如果我们能够将返回类型也复用，那是否就可以完全去除这些重复代码呢？</p>\\n<h3>通过类型构造器多态来去除重复代码</h3>\\n<p>看下面代码：</p>\\n<!-- language:scala -->\\n<pre><code>trait Iterable[T, Container[X]] {\\n  def filter(p: T => Boolean): Container[T]\\n  def remove(p: T => Boolean): Container[T] = filter(x => !p(x))\\n}\\n\\ntrait List[T] extends Iterable[T, List]\\n</code></pre>\\n<p>这是怎么做到的？很简单，引入了<strong>类型构造器多态</strong>的概念。上面例子中：<code>Iterable[T, Container[X]]</code>的<code>Iterable</code>是类型构造器，接受两个类型参数，引入多态概念，同样的类型构造器，让其可以接受不同类型的类型参数<code>List</code>。是不是和普通方法多态没什么区别？</p>\\n<!-- language:java -->\\n<pre><code>public Iterable iterable(T t, Container&#x3C;X> container) { ... }\\npublic Iterable iterable(T t, List list) { ... }\\n</code></pre>\\n<p>因为Java的泛型没有类型构造器多态的概念，所以Java泛型无法解决上述重复代码的问题。最多只能将返回类型设为超类Iterable，然后在调用子类实现时将其强制类型转换为具体子类。</p>\\n<p>有了上面的例子为上下文，我们再来看两个概念：</p>\\n<h3>类型参数、类型成员</h3>\\n<ul>\\n<li>\\n<p>Type Parameter</p>\\n<p>类型参数，比如: <code>List[T]</code>，List具有一个类型参数<code>T</code>。这里的List就是一个类型构造器。List[Int]就是这个类型构造器接受类型参数Int之后构造的具体类型。</p>\\n</li>\\n<li>\\n<p>Type Member</p>\\n<p>类型成员，比如：<code>trait List { type T }</code></p>\\n<p>这里<code>T</code>变成了一个trait的成员（抽象的）。在List子类实现中，指定其具体类型，比如：<code>List { type T = Int }</code>。而这里的类型成员也可能参数化，比如：<code>type Container[T]</code></p>\\n<p>注意：这里的List只用来示意，并不是scala中的List实现。</p>\\n</li>\\n<li>\\n<p>Type Parameter Vs. Type Member</p>\\n<p>两者很像，只是作用范围和可见性不同:</p>\\n<ul>\\n<li>参数类型只是被参数化的类型的一部分（local，private）。</li>\\n<li>类型变量就和不同变量一样，被封装在整个body中，可以被继承，显式地引用。</li>\\n<li>两者可以相互补充。比如类型成员也可以被参数化。</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>改进Iteratable</h2>\\n<p>对于集合（collection）来说，很多方法，比如：map, flatMap, filter，各有作用，但是其实这些方法都有以下两个共同点：</p>\\n<ol>\\n<li>遍历一个集合</li>\\n<li>产生一个新的集合</li>\\n</ol>\\n<p>仔细想想，是不是所有的这些操作都满足呢？</p>\\n<ul>\\n<li>map遍历一个collection，将其中的元素变形为另外类型并产生一个新的集合。</li>\\n<li>flatMap遍历一个集合，将集合中元素转换为一个集合，并最后将“集合的集合”拉平，形成一个新的集合。</li>\\n<li>filter遍历一个集合，判断是否符合过滤条件，并返回所有符合过滤条件的新的集合。</li>\\n</ul>\\n<p>找到共同点，我们就可以将其抽象出来，进而达到复用、减少重复代码的目的。对上面两个共同点，我们可以用Iterator和Builder来进行抽象实现。</p>\\n<!-- language:scala -->\\n<pre><code>// 产生新集合\\ntrait Builder[Container[X], T] {\\n  def +=(ele: T): Unit\\n  def finalise(): Container[X]\\n}\\n// 遍历（迭代）器\\ntrait Iterator[T] {\\n  def next(): T\\n  def hasNext(): Boolean\\n  def foreach(op: T => Unit): Unit = {\\n    while(hasNext()) { op(next()) }\\n  }\\n}\\n</code></pre>\\n<p>有了这两点抽象，那我们就可以对Iteratable进行改进：</p>\\n<!-- language:scala -->\\n<pre><code>// 类型参数Container\\ntrait Buildable[Container[X]] {\\n  // build方法只是返回一个Builder\\n  def build[T]: Builder[Container[X], T]\\n}\\n\\n// Iteratable没有类型参数Container\\ntrait Iteratable[T] {\\n  // 类型成员Container\\n  type Container[X] &#x3C;: Iteratable[X]\\n  def elements: Iterator[T]\\n  \\n  def mapTo[U, C[X]](f: T => U)(b: Buildable[C]): C[U] = {\\n    val buff = b.build[U]\\n    val elems = elements\\n    while(elems.hasNext) {\\n      buff += f(elems.next)\\n    }\\n    buff.finalise\\n  }\\n  \\n  def filterTo[C[X]](f: T => Boolean)(b: Buildable[C]): C[T] = {\\n    val buff = build[T]\\n    val elems = elements\\n    while(elems.hasNext) {\\n      val elem = elems.next\\n      if (f(elem)) buff += elem\\n    }\\n    buff.finalise\\n  }\\n  \\n  def flatMapTo[U, C[X]](f: T => Iterable[U])(b: Buildable[C]): C[U] = {\\n    val buff = build[U]\\n    val elems = elements\\n    while(elems.hasNext) {\\n      f(elems.next).elements.foreach(buff += _)\\n    }\\n    buff.finalise\\n  }\\n  \\n  def map[U](f: T => U)(b: Buildable[Container]): Container[U] = mapTo[U, Container](f)(b)\\n  \\n  def filterTo(f: T => Boolean)(b: Buildable[Container]) : Container[T] =\\n    filterTo[Container](f)(b)\\n  \\n  def flatMap[U](f: T => Iteratable[U])(b: Buildable[Container]): Container[U] = \\n    flatMapTo[U, Container](f, b)\\n    \\n}\\n</code></pre>\\n<p>上面的代码中，我们用<code>Buildable</code>和<code>Iterator</code>将前文提到的两个共同点进行抽象，并在<code>Iteratable</code>的实现中，利用这两个抽象：Curried的参数<code>b: Buildable[C]</code>以及<code>def elements: Iterator[T]</code>抽象方法，分别实现了：<code>map</code>, <code>filter</code>, <code>flatMap</code>。</p>\\n<p>而Iteratable的具体实现，只需要具化上面两个抽象就可以了。比如List的实现：</p>\\n<!-- language:scala -->\\n<pre><code>object ListBuildable extends Buildable[List] {\\n  def build[T]: Builder[List, T] = new ListBuffer[T] with Builder[List, T]() {\\n    // `+=` 是scala标准库中ListBuffer的方法\\n    def finalise(): List[T] = toList\\n  }\\n}\\n\\nclass List[T] extends Iteratable[T] {\\n  type Container[X] = List[X]\\n  def elements: Iterator[T] = new Iterator {\\n    ......\\n  }\\n}\\n</code></pre>\\n<p>有了上面的实现，我们就可以利用scala的另外一个机制：implicit来实现根据类型来自动选择匹配的<code>Buildable</code>了。</p>\\n<h3>Scala标准库实现</h3>\\n<p>掌握上面的思想，我们回头再看scala标准库中collection的实现机制，就很容易理解了。scala的collection架构正是基于<code>builders</code>和<code>traversals</code>思想实现的。</p>\\n<!-- language:scala -->\\n<pre><code>package scala.collection.mutable\\nclass Builder[-Elem, +To] {\\n  def +=(elem: Elem): this.type\\n  def result(): To\\n  def clear(): Unit\\n  def mapResult[NewTo](f: To => NewTo): Builder[Elem, NewTo] = ...\\n}\\n</code></pre>\\n<p>可以看出上面的<code>result</code>方法就是：我们例子中的<code>finalise</code>，此外多了<code>clear</code>, <code>mapResult</code>两个方法。</p>\\n<p>再看看<code>Buildable</code>的实现：</p>\\n<!-- language:scala -->\\n<pre><code>package scala.collection.generic\\ntrait CanBuildFrom[-From, -Elem, +To] {\\n  // Creates a new builder \\n  def apply(from: From): Builder[Elem, To] \\n}\\n</code></pre>\\n<p>在scala中，换了个名字：<code>CanBuildFrom</code>，感觉会更贴切一些（不过从dual的角度就感觉不那么好了）。</p>\\n<p>上面的<code>apply</code>就是<code>build</code>只是多了一个参数。</p>\\n<p>再来看<code>Iteratable</code>:</p>\\n<!-- language:scala -->\\n<pre><code>package scala.collection\\nclass TraversableLike[+Elem, +Repr] {\\n  def newBuilder: Builder[Elem, Repr] // deferred\\n  def foreach[U](f: Elem => U)        // deferred\\n          ...\\n  def filter(p: Elem => Boolean): Repr = {\\n    val b = newBuilder\\n    foreach { elem => if (p(elem)) b += elem }\\n    b.result\\n  } \\n}\\n</code></pre>\\n<h3>类型参数 vs. 类型成员</h3>\\n<p>在上面的例子中，我们同时使用了类型参数和类型成员。</p>\\n<ul>\\n<li>Buildable的主要目的是构建某种类型的Container，因此使用类型参数将其显式地暴露给客户端。</li>\\n<li>对于Iterable，用户更关心的是其中包含的元素类型，而不是容器(Iterable本身就类似个容器了)，所以我们采用类型成员。</li>\\n</ul>\\n<h2>关于类型(Type)和种类(Kind)</h2>\\n<p>其实中文“类型”在这里很混淆，将英文中的两个词type、kind都翻译为“类型”了，其实是有差别的，我们这里将type翻译为\\\"类型\\\"，kind翻译为\\\"种类\\\"。</p>\\n<p>值、特定类型和种类的关系可以从下图中得到解答。</p>\\n<p><img src=\\\"http://i.stack.imgur.com/K0dwL.jpg\\\" alt=\\\"values, types and kinds的关系图\\\"></p>\\n<ul>\\n<li>特定类型是对某种特定类型的值进行分类，比如Int是对1，2，3，4等值的分类，1，2，3是值，Int是Type(类型)。</li>\\n<li>种类是对特定类型的归类，比如对Int, String, List[Int]等类型，我们进行高阶抽象，可以认为这些特定类型都是相同种类的，可以用<code>*</code>来描述。这里<code>*</code>不是用来描述任意值的，而是<em>任意一个特定类型</em>。</li>\\n<li>种类<code>K</code>可以是<code>*</code> (看下面定义)，也可以是<code>K → K</code>，其中<code>→</code>是<em>种类构造器</em>，用来构造一个<strong>用于归纳类型构造器的种类</strong>，绕口吧，简单地说就是<code>K → K</code>接受一个种类参数，返回一个新的种类.</li>\\n</ul>\\n<h3>Kind的定义</h3>\\n<pre><code>Kind ::= '*(' Type ',' Type ')' | [id '@' ] Kind '→' Kind\\n</code></pre>\\n<p><code>*(T, U)</code>种类中<code>T</code>用来描述类型下边界(lower bound)，<code>U</code>为类型上边界(upper bound)。在Scala中，最低边界是<code>Nothing</code>因为它使一切类型的子类，最高边界是<code>Any</code>，它使所有类型的超类。因为我们经常使用upper bound, 所以，我们用<code>*(Nothing, U)</code>，简化为<code>*(U)</code>来描述一个种类，特别地，<code>*(Nothing, Any)</code>可以简化为<code>*</code>。</p>\\n<p>上文的几个例子：</p>\\n<table>\\n<thead>\\n<tr>\\n<th align=\\\"center\\\">Scala 类型定义</th>\\n<th align=\\\"center\\\">Kind 定义</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td align=\\\"center\\\">Container\\n[\\nX\\n]</td>\\n<td align=\\\"center\\\">*\\n → \\n*</td>\\n</tr>\\n<tr>\\n<td align=\\\"center\\\">Pair\\n[\\nT, U\\n]</td>\\n<td align=\\\"center\\\">*\\n → \\n*\\n → \\n*</td>\\n</tr>\\n<tr>\\n<td align=\\\"center\\\">Container\\n[\\nX\\n]\\n &#x3C;: Iterable\\n[\\nX\\n]</td>\\n<td align=\\\"center\\\">X @ \\n*\\n → \\n*\\n(Iterable\\n[\\nX\\n]\\n)</td>\\n</tr>\\n<tr>\\n<td align=\\\"center\\\">C[X &#x3C;: Ordered\\n[\\nX\\n]\\n] &#x3C;: Iterable\\n[\\nX\\n]</td>\\n<td align=\\\"center\\\">X @ \\n*\\n(Ordered\\n[\\nX\\n]\\n) → \\n*\\n(Iterable\\n[\\nX\\n]\\n)</td>\\n</tr>\\n</tbody>\\n</table>\\n<p>有了Kind定义，我们就可以通过其进行Kind推导，比如<code>T</code>的种类是<code>X @ K → K'</code>，如果<code>U</code>的Kind是<code>K</code>，那么很简单的通过替换，我们就可以知道<code>T[U]</code>的Kind是<code>K'</code>。</p>\\n<h3>子种类Subkinding</h3>\\n<p>scala中，我们通过<code>&#x3C;:</code>或者<code>>:</code>来表述两个类型（type）之间的关系。比如：<code>Int &#x3C;: Number</code>。</p>\\n<p>对于种类，我们可以重载<code>&#x3C;:</code> and <code>>:</code>，用来描述两个种类之间的关系。比如：<code>*(T, U) &#x3C;: *(T', U')</code>，当且仅当：<code>T' &#x3C;: T</code> AND <code>U &#x3C;: U'</code>时上述关系成立。这个相对容易理解，因为<code>T</code>/<code>T'</code>是类型参数，和方法参数一样，是逆变(contravariance)的。</p>\\n<p>scala编译器正是通过应用这些规则来进行type/kind检查的。比如，scala编译器将对下面代码报错：</p>\\n<!-- language:scala run -->\\n<pre><code>class Iterable[Container[X], T]\\ntrait NumericList[T &#x3C;: Number] extends Iterable[NumericList, T]\\n</code></pre>\\n<p>你可以点击<code>run</code>按钮试试，看看编译会出现什么结果。</p>\\n<p>之所以报错，是因为<code>Iterable[NumericList, T]</code>的问题。我们可以应用上面学到的subkinding来分析一下。</p>\\n<p><code>NumericList[T &#x3C;: Number]</code>的种类是：<code>*(Number) → *</code>，很显然，它必须是<code>Iterable</code>的第一个类型参数<code>NumericList</code>的子种类， 也就是：<code>*(Number) → * &#x3C;: * → *</code>。在<code>→</code>左边的是种类参数，是逆变的(contravariant)，所以这里我们需要：<code>* &#x3C;: *(Number)</code>，但是这显然是不成立的。所以scala编译器会报错：<code>type T's bounds &#x3C;: Number are stricter than type X's declared bounds >: Nothing &#x3C;: Any</code>。</p>\\n<p>OK then, how to make it work ? 我们需要引入一个新的类型参数：Bound</p>\\n<!-- language:scala run -->\\n<pre><code>class Iterable[Container[X &#x3C;: Bound], T &#x3C;: Bound, Bound]\\ntrait NumericList[T &#x3C;: Number] extends Iterable[NumericList, T, Number]\\n</code></pre>\\n<p><code>Iterable[Container[X &#x3C;: Bound], T &#x3C;: Bound, Bound]</code>的种类是：<code>*(Bound) → * → *(Bound) → * → *</code></p>\\n<p><code>NumericList[T &#x3C;: Number]</code>的种类是：<code>*(Number) → *</code>，该种类必须是<code>Iterable</code>第一个参数的子种类，也就是：<code>*(Number) → * &#x3C;: *(Bound) → *</code>，而<code>Bound</code>已经指定为<code>Number</code>，经过替换，就有了：<code>*(Number) → * &#x3C;: *(Number) → *</code>，左右两边相同，自然是满足要求了。</p>\\n<h3>高种类型</h3>\\n<p>如果你使用scala 2.11.x版本，在REPL中，就可以通过<code>:type</code>来查看一个类型的种类（Kind）了。比如：</p>\\n<!-- language:scala run -->\\n<pre><code>scala> :kind -v List\\nscala.collection.immutable.List's kind is F[+A]\\n* -(+)-> *\\nThis is a type constructor: a 1st-order-kinded type.\\n\\nscala> :kind -v Pair[_, _]\\nscala.Tuple2's kind is F[+A1,+A2]\\n* -(+)-> * -(+)-> *\\nThis is a type constructor: a 1st-order-kinded type.\\n</code></pre>\\n<p>可以看到，两者的类型一个是：<code>* → *</code> 另外一个是 <code>* → * → *</code>，而且，两个都是：<code>1st-order-kinded type</code>。那怎么才算是一个<code>higher order kinded type</code>呢？</p>\\n<p>在上面的图中:<code>Functor[List]</code>是<code>higher order kinded type</code>: <code>(* → *) → *</code>，这个和<code>Pair[_, _]</code>的<code>* → * → *</code>相比，不就多了个括号吗？玄机就再这个括号上：<code>(* → *) → *</code>表示你接受一个一阶类型* → *，然后产生一个最终的类型。类型的类型，所以是高阶类型。</p>\\n<h2>Implicit机制</h2>\\n<p><code>implicit</code>是scala中一个很强大的东西，其主要出发点是“偷懒”，没错，就是偷懒，让程序员可以偷懒，将本来应该码农干的活交给“编译器”完成。</p>\\n<p>implicit能帮我们码农的有两个地方：隐式参数和隐式转换。</p>\\n<h3>隐式参数</h3>\\n<p>具体来说，就是你可以将一个方法调用的参数（显式注为implicit）省略掉，编译器会在当前上下文中找能用于补充缺失掉参数的值，如果能找到，就自动填充，找不到就会在编译时报错。比如下面例子：</p>\\n<!-- language:scala run -->\\n<pre><code>def foo[T](t: T)(implicit integral: Integral[T]) = { println(integral) }\\nfoo(1)\\n</code></pre>\\n<p>注意<code>foo(1)</code>中只提供了第一个参数，一个<code>Int</code>值，但是第二个参数被省略了，scala编译器就会查找当前scope中有没有类型为<code>Integral[Int]</code>的<code>implicit</code>值。很幸运，scala.math.Numeric中定义了<code>implicit object IntIsIntegral extends IntIsIntegral with Ordering.IntOrdering</code>，所以编译器会找到<code>IntIsIntegral</code>对象然后自动补充第二个参数。</p>\\n<p>那我们再试一下<code>foo(1.0)</code>，这个时候，编译器会报错。为什么呢？查查scala.math.Numeric源码，我们就会发现：scala为Double提供了implicit Fractional对象，make sense，double不是整数嘛。同时scala还是提供了一个对象<code>DoubleAsIfIntegral</code>，但并没有标记为<code>implicit</code>，所以编译器找不到。了解了原因，简单做如下改动：</p>\\n<!-- language:scala run -->\\n<pre><code>def foo[T](t: T)(implicit integral: Integral[T]) = { println(integral) }\\nfoo(1)\\nimplicit val doubleAsIfIntegral = scala.math.Numeric.DoubleAsIfIntegral\\nfoo(1.0)\\n</code></pre>\\n<p>现在大家都happy了。</p>\\n<p>你可以通过<code>implicitly[Integral[Double]]</code>来自行查找是否有符合条件的隐式参数。</p>\\n<h3>隐式转换</h3>\\n<p>implicit的另外一个作用是隐式转换，同样也是帮助码农的。具体讲，就是当你在调用某个方法在某个对象上的时候，如果这个对象的类A并没有定义这个方法，scala的编译器先不会报错，会尝试着在当前scope中查找：</p>\\n<ol>\\n<li>具有该方法定义的类型 B</li>\\n<li>能够将A转换为B的转换器</li>\\n</ol>\\n<p>如果能找到，那么scala将自动进行上述转换，找不到，报错。例如：</p>\\n<!-- language:scala -->\\n<pre><code>\\\"123\\\".map(_.toInt)\\n</code></pre>\\n<p><code>\\\"123\\\"</code>是一个<code>java.lang.String</code>类型，String上并没有定义<code>map</code>方法，但是编译器也没有报错，而且顺利执行了。这就是隐式转换：scala编译器会在上下文中找到<code>implicit def augmentString(x: String): StringOps = new StringOps(x)</code>，可以将<code>String</code>转换为有<code>map</code>定义的<code>StringOps</code>。</p>\\n<p>你可以通过<code>implicitly[String => StringOps]</code>进行自行查找符合条件的转换器。</p>\\n<p>基于隐式参数和隐式转换，在Scala的类型系统中，有两个语法糖：view bound (CC &#x3C;% Seq[T]) 和 context bound (T : Integral)。</p>\\n<h3>View Bounds</h3>\\n<p>说实话不知道这个翻译为什么好，在微博上和几位国内scala大牛们探讨过，一些人认为应该直译为：“视界”，我自己倒是觉得应该叫“化界”？因为：</p>\\n<ol>\\n<li>“视界”，可见到的边界，太笼统，含义模糊，“化界”顾名思义，可“转化到的边界”</li>\\n<li>化界听上去比较炫，像是玄幻小说中很高深的境界，^_^</li>\\n</ol>\\n<p>You can think of <code>T &#x3C;% Ordered[T]</code> as saying, “I can use any T, so long as T can be treated as an Ordered[T].” This is different from saying that T is an Ordered[T], which is what an upper bound, <code>T &#x3C;: Ordered[T]</code>, would say.</p>\\n<p>有时候隐式参数和隐式转换可以同时存在、起作用，比如下面代码：</p>\\n<!-- language:scala run -->\\n<pre><code>def getIndex[T, CC](seq: CC, value: T)(implicit converter: CC => Seq[T]) = seq.indexOf(value)\\n\\ngetIndex(\\\"abcde\\\", 'c')\\ngetIndex(List(1,3,2,5), 3)\\n</code></pre>\\n<p>上面代码中<code>CC</code>可以是任何能转换为<code>Seq</code>的类型，所以<code>String</code>和<code>List</code>都可以应用。</p>\\n<p>首先，<code>converter</code>是一个隐式参数，其次，因为<code>seq</code>对象的类型是<code>CC</code>，其上面并没有定义<code>indexOf</code>方法，所以“隐式转换”介入。</p>\\n<p>事实上，这个用法非常普遍，所以scala专门为其提供了一个语法糖：view bound <code>CC &#x3C;% Seq[T]</code>，重写上面代码：</p>\\n<!-- language:scala run -->\\n<pre><code>def getIndex[T, CC &#x3C;% Seq[T]](seq: CC, value: T) = seq.indexOf(value)\\n</code></pre>\\n<p>运行上面代码，你可以从输出看到scala编译器会将方法重新定义为：<code>getIndex: [T, CC](list: CC, value: T)(implicit evidence$1: CC => Seq[T])Int</code>，和第一种方法一样。</p>\\n<h3>Context Bounds</h3>\\n<p>再看下面一个例子：</p>\\n<!-- language:scala run -->\\n<pre><code>def sum[T](list: List[T])(implicit integral: Integral[T]): T = {\\n    import integral._   // get the implicits in question into scope\\n    list.foldLeft(integral.zero)(_ + _)\\n}\\n</code></pre>\\n<p>这里有一个隐式参数<code>integral</code>类型为<code>Integral[T]</code>，如果方法传入<code>Int</code>，那么scala编译器就会找<code>implicitly[Integral[Int]]</code>，这个我们在隐式参数小节已经说过了。</p>\\n<p>这里主要关注另外一个问题：<code>list.foldLeft(integral.zero)(_ + _)</code>，其中<code>_</code>的类型应该是<code>T</code>，但是<code>T</code>上面有定义<code>+</code>方法吗？我们先把<code>import integral._</code>去掉，就会发现编译出错：</p>\\n<!-- language:scala -->\\n<pre><code>&#x3C;console>:8: error: type mismatch;\\n found   : T\\n required: String\\n           list.foldLeft(integral.zero)(_ + _)\\n                                        ^\\n</code></pre>\\n<p>原来scala编译器尝试着将<code>T</code>转换为<code>String</code>了，这里应该是<code>Predef.any2string</code>起了作用。</p>\\n<p>加上<code>import integral._</code>，一切工作了。</p>\\n<p>回头想一下，其实挺有意思的：我们给一个泛型<code>T</code>动态地添加了<code>+</code>方法，但是并不改变<code>T</code>的代码。而这就是context bound的意义。</p>\\n<p>这个在流行框架<code>Scalaz</code>中应用非常广泛。scala同样为其创建了专门的语法糖：<code>[T : Ordering]</code>。采用语法糖，这个例子可以重写为：</p>\\n<!-- language:scala run -->\\n<pre><code>def sum[T : Integral](list: List[T]): T = {\\n  val integral = implicitly[Integral[T]]\\n  import integral._\\n  list.foldLeft(integral.zero)(_ + _)\\n}\\n</code></pre>\\n<p>编译器编译之后，会生成一个<code>sum: [T](list: List[T])(implicit evidence$1: Integral[T])T</code>的方法。</p>\\n<p>这里有点让人confusing的地方是：<code>T: Integral</code>的写法感觉像是说：<code>T</code>是<code>Integral</code>的类型，就像：<code>m: T</code>，可实际上应该认为是：<code>T</code>在<code>Integral</code>的<code>Context</code>中。</p>\\n<h2>结束语</h2>\\n<p>scala的类型系统确实是一个难点，但同时也是要真正掌握scala语言所必须的知识点。很多概念都很晦涩，对于像我们这些凡人，要想掌握没有太好的办法，只能多看、多练、多想。</p>\\n<h2>参考</h2>\\n<ol>\\n<li><a href=\\\"http://stackoverflow.com/questions/6246719/what-is-a-higher-kinded-type-in-scala\\\">Adriaan Moors. What is a higher kinded type in scala. StackOverflow. http://stackoverflow.com/questions/6246719/what-is-a-higher-kinded-type-in-scala. 2011</a></li>\\n<li><a href=\\\"http://docs.scala-lang.org/overviews/core/architecture-of-scala-collections.html\\\">Martin Odersky and Lex Spoon. Architecture of Scala Collection. scala-lang website. http://docs.scala-lang.org/overviews/core/architecture-of-scala-collections.html. 2013</a></li>\\n<li><a href=\\\"http://stackoverflow.com/questions/5598085/where-does-scala-look-for-implicits\\\">Daniel C. Sobral. Types of Implicits. StackOverflow. http://stackoverflow.com/questions/5598085/where-does-scala-look-for-implicits. 2011</a></li>\\n<li><a href=\\\"http://blogs.atlassian.com/2013/09/scala-types-of-a-higher-kind/\\\">Jed Wesley-Smith. Scala Types Of a Higher Kind. http://blogs.atlassian.com/2013/09/scala-types-of-a-higher-kind/</a></li>\\n</ol>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2014/高种泛型.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2014-01-08T19:16:45.000Z\",\"path\":\"/2014/generics-of-a-higher-kind\",\"title\":\"高种泛型 (Generics of a Higher Kind)\",\"excerpt\":\"Generics of a Higher Kind翻译加自我理解。\",\"tags\":[\"scala\",\"functional programming\",\"Generics\"]}}},{\"node\":{\"html\":\"<p>前文说过了，高阶函数式函数式语言中的基石，而<code>map</code>, <code>flatMap</code>更是重要。</p>\\n<p>对于map，就是一个空间转换的概念，从这个空间映射到另外一个空间：</p>\\n<ul>\\n<li>必须是一一对应的，也就是这个空间的一个点也需要映射到另外一个空间的一个点。</li>\\n</ul>\\n<p>对于flatMap，一种理解是map + flatten，但是我觉得这种理解不好，应为在FP中，flatMap远比map重要。</p>\\n<p>而map、flatMap加上withFilter和foreach实现了scala中最强大的for表达式。</p>\\n<p>其实叫for表达式不准确，英文是有两种称谓：</p>\\n<ul>\\n<li>\\n<p>for comprehension</p>\\n<p>for {\\nx &#x3C;- e1\\ny &#x3C;- e2\\n} yield e</p>\\n<p>comprehension的含义是“理解力”，人如其名，这个表达式也有很强大的理解力。看文本文希望能够对这个方面有所帮助。</p>\\n</li>\\n<li>\\n<p>for loop</p>\\n</li>\\n</ul>\\n<pre><code>for {\\n    i &#x3C;- e1\\n} {\\n    // do something.\\n}\\n</code></pre>\\n<p>本文这里套用Martin在\\\"Reactive Programming\\\"中的例子，对如何应用map, flatMap, for表达式做个简单介绍。</p>\\n<h2>例子</h2>\\n<p>这个例子中，我们需要实现一个随机生成器，能够随机生成：Int, Boolean, Pair, List, Tree</p>\\n<h2>实现</h2>\\n<h3>规约定义</h3>\\n<p>先定义一个Generator类，里面主要的方法就是一个<code>generate</code>，返回一个T</p>\\n<!-- language:lang-scala -->\\n<pre><code>trait Generator[T] { self =>\\n  def generate : T\\n}\\n</code></pre>\\n<h3>随机整数生成器</h3>\\n<p>我们来实现一个随机整数生成器。</p>\\n<!-- language:lang-scala -->\\n<pre><code>val integers = new Generator[Int] {\\n  def generate = {\\n    val r = new java.util.Random\\n    r.nextInt\\n  }\\n}\\n</code></pre>\\n<h3>随机布尔值生成器</h3>\\n<p>再生成一个布尔值随机生成器。</p>\\n<!-- language:lang-scala -->\\n<pre><code>val booleans = new Generator[Boolean] {\\n  def generate = {\\n    val r = new java.util.Random\\n    r.nextInt >= 0\\n  }\\n}\\n</code></pre>\\n<p>现在问题来了，上面的代码有两个问题：</p>\\n<p>1.代码重复\\n<code>val r = new java.util.Random ; r.nextInt</code>出现了两次</p>\\n<p>2.有boilerplate代码，<code>new Generator[Boolean]</code>, <code>def generate</code>等等\\n理想的情况应该是这样的：</p>\\n<!-- language:lang-scala -->\\n<pre><code>val booleans = for (i &#x3C;- integers) yield i > 0\\n</code></pre>\\n<p>但是如果你在REPL中尝试的话，会发现报错：</p>\\n<!-- language:lang-scala -->\\n<pre><code>scala> val boolean = for (i &#x3C;- integers) yield i >= 0\\n&#x3C;console>:9: error: value map is not a member of Generator[Int]\\n       val boolean = for (i &#x3C;- integers) yield i >= 0\\n</code></pre>\\n<p>OK, 因为for表达式就是对<code>map</code>, <code>flatMap</code>的简化，上面的代码会被翻译为：</p>\\n<!-- language:lang-scala -->\\n<pre><code>integers map { i => i > 0 }\\n</code></pre>\\n<p>我们没有在Generator中定义map，所以报错是必然的。修改一下：</p>\\n<!-- language:lang-scala run -->\\n<pre><code>trait Generator[T] { self =>\\n  def generate : T\\n\\n  def map[S](f: T => S): Generator[S] = new Generator[S] {\\n    def generate = f(self.generate)\\n  }\\n}\\nval integers = new Generator[Int] {\\n  def generate = {\\n    val r = new java.util.Random\\n    r.nextInt\\n  }\\n}\\n\\nval booleans = for (i &#x3C;- integers) yield i >= 0\\nbooleans.generate\\n</code></pre>\\n<p>点击<code>run</code>按钮试试，一切顺利！不错。</p>\\n<h3>随机Pair生成器</h3>\\n<p>我们再继续，来点难点的，来个随机<code>(Int, Int)</code>生成器，想一下，很简单，调用两次<code>integers.generate</code>就可以了。</p>\\n<!-- language:lang-scala -->\\n<pre><code>val pairs = new Generator[(Int, Int)] {\\n  def generate = (integers.generate, integers.generate)\\n}\\n</code></pre>\\n<p>同样的，我们不希望有boilerplate代码，每次new一个匿名类，还要重新定义<code>generate</code>，这是java中的无奈之举，对于scala来说，我们希望这么写：</p>\\n<!-- language:lang-scala -->\\n<pre><code>val pairs = for {\\n  x &#x3C;- integers\\n  y &#x3C;- integers\\n} yield (x, y)\\n</code></pre>\\n<p>但是当你试运行一下的时候会出现：</p>\\n<pre><code>scala> val pairs = for (x &#x3C;- integers ; y &#x3C;- integers) yield (x, y)\\n&#x3C;console>:9: error: value flatMap is not a member of Generator[Int]\\n       val pairs = for (x &#x3C;- integers ; y &#x3C;- integers) yield (x, y)\\n</code></pre>\\n<p>编译器抱怨说没有flatMap定义在Generator上，怎么回事？</p>\\n<p>同理，我们需要了解for表达式的翻译机理，上面的代码会背翻译为：</p>\\n<!-- language:lang-scala -->\\n<pre><code>integers flatMap { x => integers map { (x, _) }}\\n</code></pre>\\n<p>我们没有实现flatMap当然会出现这样的错误。好吧，我们来增强一下：</p>\\n<!-- language:lang-scala run -->\\n<pre><code>trait Generator[T] { self =>\\n  def generate : T\\n\\n  def map[S](f: T => S): Generator[S] = new Generator[S] {\\n    def generate = f(self.generate)\\n  }\\n\\n  def flatMap[S](f: T => Generator[S]): Generator[S] = new Generator[S] {\\n    def generate = f(self.generate).generate\\n  }\\n}\\n\\nval integers = new Generator[Int] {\\n  def generate = {\\n    val r = new java.util.Random\\n    r.nextInt\\n  }\\n}\\n\\nval pairs = for {\\n  x &#x3C;- integers\\n  y &#x3C;- integers\\n} yield (x, y)\\n\\npairs.generate\\npairs.generate\\n</code></pre>\\n<p>不错吧，everything just works like a charm. </p>\\n<p>我们还可以定义一些小工具，比如：</p>\\n<!-- language:lang-scala -->\\n<pre><code>def single[T](s: T) = new Generator[T] {\\n  def generate = s\\n}\\n\\ndef choose(from: Int, to: Int) = for { i &#x3C;- integers } yield (from + Math.abs(i) % (to - from))\\n\\ndef oneOf[T](choices: T*) = for ( idx &#x3C;- choose(0, choices.length) ) yield choices(idx)\\n</code></pre>\\n<p>看到OO中策略模式的影子了吗？</p>\\n<h3>List[Int]生成器</h3>\\n<!-- language:lang-scala -->\\n<pre><code>def nonEmptyList = for {\\n  head &#x3C;- integers\\n  tail &#x3C;- lists\\n} yield (head :: tail)\\n\\nval lists: Generator[List[Int]] = for {\\n  isEmpty &#x3C;- oneOf(true, false, false, false, false)\\n  list &#x3C;- if (isEmpty) single(Nil) else nonEmptyList\\n} yield list\\n</code></pre>\\n<h3>Tree生成器</h3>\\n<!-- language:lang-scala -->\\n<pre><code>trait Tree\\ncase class Node(left: Tree, right: Tree) extends Tree\\ncase class Leaf(x: Int) extends Tree\\n\\ndef leafs: Generator[Leaf] = for ( i &#x3C;- integers ) yield Leaf(i)\\n\\n//不是尾递归，很容易StackOverflow\\ndef nodes: Generator[Node] = for {\\n  left &#x3C;- trees\\n  right &#x3C;- trees\\n} yield Node(left, right)\\n\\ndef trees: Generator[Tree] = for {\\n  isLeaf &#x3C;- booleans\\n  tree &#x3C;- if (isLeaf) leafs else nodes\\n} yield tree\\n</code></pre>\\n<p>上面的代码因为用了递归，而且不是尾递归，很容易stackoverflow，一种workaround是增大<code>isLeaf</code>的概率，比如用<code>oneOf(true, true, true, false, false)</code>来替换<code>booleans</code>，这样就有2/3的概率为leaf，退出递归，但是还是很容易出错。下面用指令式的方式来实现以下：</p>\\n<!-- language:lang-scala -->\\n<pre><code>// 先根据深度，生成所有的叶子\\nprivate def leafs(depth: Int): List[Option[Leaf]] = (Math.pow(2, depth - 1).toInt to 1 by -2).toList.foldLeft(List[Option[Leaf]]()) { (acc, ele) =>\\n  val isLuck = booleans.generate\\n  if (isLuck)\\n    Some(Leaf(integers.generate)) :: Some(Leaf(integers.generate)) :: acc\\n  else\\n    None :: None :: acc\\n}\\n//依次聚集\\nprivate def aggregate(children: List[Option[Tree]]): List[Option[Tree]] = {\\n  if (children.length == 1) \\n    children\\n  else {\\n    val length = children.length        \\n    val parents = (length to 1 by -2).toList map { i => (children(i - 1), children(i - 2)) match {\\n        case (Some(l), Some(r)) => Some(Node(l, r))\\n        case (Some(l), None) => Some(Node(l, Leaf(integers.generate)))\\n        case (None, Some(r)) => Some(Node(Leaf(integers.generate), r))\\n        case (None, None) => Some(Leaf(integers.generate))\\n      }\\n    }\\n    aggregate(parents)\\n  }\\n}\\n\\ndef generateTree(depth: Int) = aggregate(leafs(depth))(0).get\\n</code></pre>\\n<p>总的思路是：先根据深度生成可能的叶子，然后两两聚集为上一层的父节点，然后递归直到根节点。</p>\\n<p>这个实现里同样没有用<code>可变量</code>。</p>\\n<h4>Bonus: 打印tree</h4>\\n<p>TBD</p>\\n<h2>关于for表达式</h2>\\n<p>如果你平常用for的场合都是在用一些collection的话，会产生一种错觉，以为for表达式智能应用在collection中，其实for表达式可以应用在任何定义了map/flatMap/withFilter/foreach的类型中，正如你在本文中看到的，那么一个问题是：</p>\\n<!-- language:lang-scala -->\\n<pre><code>val booleans = for ( x &#x3C;- integers ) yield x >= 0\\n</code></pre>\\n<p><code>booleans</code>的类型应该是什么呢？</p>\\n<p>如果你经常用for于collection，你可能会觉得是一个List[Boolean]，其实不是，真正的返回值是：<code>Generator[Boolean]</code>，因为for表达式知道<code>integers</code>的类型是Generator所以其返回值也是Generator，这就是for comprehension的含义是“理解力”，人如其名，这个表达式也有很强大的理解力。看文本文希望能够对这个方面有所帮助。</p>\\n<p>那么是如何实现的呢？其实很简单，将for表达式翻译为map你就知道其中玄机了。</p>\\n<!-- language:lang-scala -->\\n<pre><code>val booleans = for ( x &#x3C;- integers ) yield x >= 0 = integers map { _ >= 0 }\\n</code></pre>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/map-flatMap-for.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-12-01T19:16:45.000Z\",\"path\":\"/2013/map-flatmap-for\",\"title\":\"map/flatMap/for in Action\",\"excerpt\":\"前文说过了，高阶函数式函数式语言中的基石，而`map`, `flatMap`更是重要。\",\"tags\":[\"scala\",\"functional programming\"]}}},{\"node\":{\"html\":\"<p>Eric Meijer说：递归是函数式编程的GOTO，应该尽可能避免。如何避免，OO中我们用while循环，FP中我们用<code>fold</code>。</p>\\n<h2>什么是fold</h2>\\n<p>fold就是折纸，给你一张纸条，你可以将其分为若干等份（一个集合），然后从左向右一点一点卷折起来，折成一个你想要的形状，当然也可以从右向左，还可以对半折。</p>\\n<pre><code>+---+---+---+---+---+---+---+---+---+---+---+---+\\n|   |   |   |   |   |   |   |   |   |   |   |   |\\n| --->  |   |   |   |   |   |   |   |   |   |   |\\n|   |   |   |   |   |   |   |   |   |   |   |   |\\n+---+---+---+---+---+---+---+---+---+---+---+---+\\n</code></pre>\\n<p>这里“你想要的形状”，就是最终<code>fold</code>的输出。</p>\\n<p>风向的例子，北风就是从北面吹来的风。同样的，foldRight就是从右向左折叠，操作对象是seed集合，参数是前面集合的最后一个元素。</p>\\n<h2>foldRight</h2>\\n<!-- language:lang-scala -->\\n<pre><code>List(1,2,3).foldRight(seed)(f) = f(1, f(2, f(3, seed)))\\n</code></pre>\\n<p>记住：等式两边各个因子出现的顺序是相同的，都是1 -> 2 -> 3 -> seed，之所以重要，是因为最后一个<code>f(3, seed)</code>接受的参数是一个tuple: (ele, seed)，而不是(seed, ele)。\\n形象化一点，假设<code>f</code>是<code>cons</code>操作，也就是<code>::</code>:</p>\\n<pre><code>    ::\\n  /   \\\\\\n1       ::\\n       /  \\\\\\n      2     ::\\n           /  \\\\\\n          3    seed \\n</code></pre>\\n<p>例子：求整数集合之和。</p>\\n<!-- language:lang-scala run -->\\n<pre><code>val sum = List(1,2,3).foldRight(0) { (ele, seed) => { println(ele); seed + ele } }\\nprintln(sum)\\n</code></pre>\\n<p>点击<code>run</code>，可以看到，输出的<code>ele</code>顺序是<code>3 -> 2 -> 1</code>.</p>\\n<h2>foldLeft</h2>\\n<!-- language:lang-scala -->\\n<pre><code>List(1,2,3).foldLeft(seed)(g) = g(g(g(seed, 1), 2), 3)\\n</code></pre>\\n<p>这里，前面List中元素的处理顺序还是从左向右的，只是seed跑到了最前面，所以tuple变成了：(seed, ele)。</p>\\n<p>树形结构：</p>\\n<pre><code>            g\\n          /   \\\\\\n        g      3\\n      /   \\\\\\n    g       2\\n  /   \\\\\\nseed   1\\n</code></pre>\\n<p>注意：这里我用的函数换成了<code>g</code>，而不是前面的<code>f</code>，就是想提醒大家，这是两个不同的函数，其参数都是tuple，但是seed的顺序不同。这在编程的时候经常搞混。</p>\\n<p>相同的例子：求一个整数集合的和。</p>\\n<!-- language:lang-scala run -->\\n<pre><code>val sum = List(1,2,3).foldLeft(0) { (seed, ele) => { println(ele); seed + ele } }\\nprintln(sum)\\n</code></pre>\\n<p>点击<code>run</code>，可以看到，输出的<code>ele</code>顺序是<code>1 -> 2 -> 3</code>.</p>\\n<h2>助记</h2>\\n<p>foldLeft/foldRight中block的参数tuple顺序经常搞混，为了方便记忆，我们可以这么来看，我们用seed做基准：</p>\\n<ul>\\n<li>foldRight，从右向左，tuple中seed在右<code>(elem, seed)</code></li>\\n<li>foldLeft, 从左向右，tuple中seed在左<code>(seed, elem)</code></li>\\n</ul>\\n<p>有了fold是卷折纸的概念，我们就比较容易理解unfold.</p>\\n<h2>unfold</h2>\\n<p>与<code>fold</code>对应，<code>unfold</code>就是反过来将一个卷折好的纸分解开，变成若干等份（集合），所以unfold是一个集合的构造过程。</p>\\n<h2>例子</h2>\\n<p>我们这里举一个实际的例子。</p>\\n<!-- language:lang-scala -->\\n<pre><code>def retry(n: Int)(block: => Future[T]): Future[T] = {\\n  if (n &#x3C;= 0) {\\n    Future.failed{ new RuntimeException(\\\"failed even if retried\\\") }\\n  } else {\\n    block fallbackTo {\\n      retry(n - 1)(block)\\n    }\\n  }\\n}\\n</code></pre>\\n<p>这里我们用了递归，但是如Erik Meijer所说，递归是FP的GOTO，不容易理解，容易出错，我们来用fold来替换一下。</p>\\n<p>可是一般来说fold都是需要一个集合的，而这里有什么集合？没有条件，创造条件也要上！我们可以将<code>n</code>也就是次数看成是一个集合，因为逻辑上我们要作几次，每次算一个集合元素，那么这不就是一个集合吗？</p>\\n<p>这个集合就是：<code>val attempts = (1 to n) map { _ => () => block }</code>，有了操作的集合，我们就可以开始玩折纸游戏了。</p>\\n<p>我们最终要“折的形状”是：成功的话返回<code>T</code>，否则返回一个Failure。我们可以将一个缺省的failure作为seed开始。</p>\\n<p>而且我们期望的执行顺序是：<code>block1 recoverWith (block2 recoverWith (block3 recoverWith failure))</code>，很明显，这是一个<code>foldRight</code>。</p>\\n<!-- language:lang-scala -->\\n<pre><code>def retry(n: Int)(block: => Future[T]) = {\\n  val ns = (1 to n).iterator\\n  // 注意：这里的map不关心ns中的系数，所以用'_'，后面需要一个by name参数，所以需要一个() => block，否则将会提前计算，达不到重试效果。\\n  val attempts = ns map { _ => () => block }\\n  val failure = Future.failed{ new RuntimeException(\\\"failed even if retried\\\") }\\n  // 这里seed是一个call by name\\n  attempts.foldRight(() => failure) { (attempt, seed) =>\\n    // seed是call by name，这里也需要是call by name\\n    () => attempt() fallbackTo{ seed() }\\n  }\\n}\\n</code></pre>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/fold编程.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-27T19:16:45.000Z\",\"path\":\"/2013/fold\",\"title\":\"折纸的艺术：fold编程\",\"excerpt\":\"Eric Meijer说：递归是函数式编程的GOTO，应该尽可能避免。如何避免，OO中我们用while循环，FP中我们用`fold`。\",\"tags\":[\"scala\",\"functional programming\",\"fold\"]}}},{\"node\":{\"html\":\"<p>函数式语言与OO（确切地讲是指令式编程）的思维方式是完全不同的，很多OO中的经验在函数式语言中不是很匹配，比如设计模式，那就是一个OO中的特定术语，而在FP中，大家常谈的是对于习惯OO思维的程序员来说玄而又玄的Monad。</p>\\n<p>虽然术语不同，其实要解决的问题是相同的，设计模式也好、Monad也好，都是为了如何更好地处理异常、让代码更加简洁易懂、容易扩展等等。【所以透彻地了解问题本身，比学习一个新的技术更加重要。】</p>\\n<p>本系列文章试图能够将Monad这个及其抽象的东东具体化，将其落地，变为能够理解的例子，看看在具体问题下如何使用Monad来抽象问题，简化代码。</p>\\n<h2>什么是Monad</h2>\\n<h3>定义</h3>\\n<p>一个Monad就是一个实现了flatMap, unit等函数，包含某种数据类型的容器，更加术语化一点是参数化类型<code>M[T]</code>.</p>\\n<!-- language:lang-scala -->\\n<pre><code>trait M[T] {\\n  def flatMap[U](f: T => M[U]) : M[U]\\n  def unit[T](x: T) : M[T]\\n}\\n</code></pre>\\n<p>Monad需要满足三个定理（没错，就是定理，感觉回到了小学、初中的数学课堂）。</p>\\n<ul>\\n<li>\\n<p>组合律</p>\\n<p><code>(x flatMap f) flatMap g == x flatMap (y => f(y) flatMap g)</code></p>\\n<p>有些人可能会问，右边为什么不是 <code>x flatMap (f flatMap g)</code>呢？ 你试一下就知道了，编译器报类型匹配错误，这里<code>x</code>是一个monad，<code>f</code>, <code>g</code>都是函数，所以<code>f flatMap g</code>会类型不匹配。</p>\\n</li>\\n<li>\\n<p>左单一</p>\\n<p><code>unit(x) flatMap f == f(x)</code></p>\\n</li>\\n<li>\\n<p>右单一</p>\\n<p><code>x flatMap unit == x</code></p>\\n</li>\\n</ul>\\n<h3>Monad举例</h3>\\n<p>在Scala中Monad不是新鲜玩意，其实只要你学scala，那你就会天天用，常用的Monad有：</p>\\n<ul>\\n<li>Collection类，比如：List, Set, Map</li>\\n<li>描述可能性的Option  (Some, None)</li>\\n<li>异常处理类 Try, scalaz中的Validation等</li>\\n<li>描述未来的 Future</li>\\n<li>封装状态变化的State</li>\\n<li>封装IO的IO</li>\\n</ul>\\n<h2>Monad解决什么问题</h2>\\n<p>正如上面列举的几个Monad，每种Monad都是为了解决某种具体问题而存在的，正如OO中设计模式一样，只不过Monad的侧重点是：</p>\\n<ul>\\n<li>\\n<p>让你只关注代码主流程，而将异常等分支交给flatMap来处理。</p>\\n</li>\\n<li>\\n<p>每个Monad是一个容器或者一个平行空间，让你可以在该容器（空间）中安全地、方便地操作容器中的数据类型，而不用关心相关问题。比如：在Option空间中，你不用考虑是否有返回值的问题，不需要像指令式编程那样<code>if (rtn == null) ... else ...</code>，再比如Future，让你能够在“未来的时空”中对数据进行操作，不用担心同步的问题，因为你的运算都发生在“未来”空间中。</p>\\n</li>\\n<li>\\n<p>结合for表达式，让你的代码更加简洁、易读。</p>\\n<p><code>for { x &#x3C;- monad; y &#x3C;- f(x); ...}</code></p>\\n<p>而前面讲的定律（主要是结合律和右单一），可以确保monad在for表达式中使用的正确性，比如结合律：</p>\\n</li>\\n</ul>\\n<!-- language:lang-scala -->\\n<pre><code>for {\\n  y &#x3C;- for (x &#x3C;- m; y &#x3C;- f(x)) yield y\\n  z &#x3C;- g(y)\\n} yield z\\n</code></pre>\\n<p>因为满足结合律，就可以简化为：</p>\\n<!-- language:lang-scala -->\\n<pre><code>for {\\n  x &#x3C;- m\\n  y &#x3C;- f(x)\\n  z &#x3C;- g(y)\\n} yield z\\n</code></pre>\\n<p>如果翻译为map/flatMap，前者翻译为：<code>m flatMap f flatMap g</code>，后者翻译为：<code>m flatMap (x => f(x) flatMap g)</code>.</p>\\n<p>而右单一定律可以保证：<code>for {x &#x3C;- m} yield x == m</code>，如果你看过scalaz，你就了解为什么scalaz中需要有专门的test case来测试这些定律了。</p>\\n<p>一般来说我们不太需要关注这些定律的问题，但是如果你需要自己开发一个自己的Monad，那么你就得保证你的Monad符合这些定律，因为这样才能让你的Monad安全地应用在for表达式中。</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Monad.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-26T07:16:45.000Z\",\"path\":\"/2013/monad\",\"title\":\"Monad\",\"excerpt\":\"函数式语言与OO（确切地讲是指令式编程）的思维方式是完全不同的，很多OO中的经验在函数式语言中不是很匹配，比如设计模式，那就是一个OO中的特定术语，而在FP中，大家常谈的是对于习惯OO思维的程序员来说玄而又玄的Monad。\",\"tags\":[\"scala\",\"functional programming\",\"monad\"]}}},{\"node\":{\"html\":\"<p>所谓高阶函数（high order function），其实就是可以接受其他函数作为参数的函数。</p>\\n<p>这里其实还有另外一个概念：<em>头等函数</em>（First Class Function），First Class应该是指头等公民的含义。在Java中的一个方法（函数），只能被调用，相比值Value就像个二等公民，不能像值Value一样，既可以在表达式中被引用，又可以作为参数传入其他方法。</p>\\n<p>头等函数也就是可以将其作为一个值进行传递的函数。看上去很简单，可带来的变化是巨大的。</p>\\n<p>头等函数加上高阶函数，可以极大地简化代码，实现DSL。</p>\\n<h2>简化代码</h2>\\n<h3>Java中的匿名类</h3>\\n<!-- language:lang-java -->\\n<pre><code>import java.util.*\\n\\nTimer timer = new Timer();\\nTimerTask helloTimer = new TimerTask(){\\n    public void run(){\\n        System.out.println(\\\"Hello Timer\\\");\\n    }\\n};\\ntimer.schedule(helloTimer, 1);\\n\\nTimerTask helloWorld = new TimerTask(){\\n    public void run(){\\n        System.out.println(\\\"Hello World\\\");\\n    }\\n};\\ntimer.schedule(helloWorld, 1);\\n</code></pre>\\n<p>然后每次都需要new一个TimerTask匿名类，用起来真心不方便，尤其是当你有多个匿名类要一起使用的时候，那代码看起来简直就像一坨翔，丑陋无比！本来正常的、相同抽象层次的代码应该具有相同的缩进层次，这样阅读起来很易懂、顺畅。但是因为引入匿名类，就得放在不同的缩进层次中，加上不必要的类签名定义，方法定义等boilerplate code, 阅读起来那叫一个费劲！</p>\\n<p>看看scala的方式：</p>\\n<h1>Scala</h1>\\n<!-- language:lang-scala run -->\\n<pre><code>import scala.concurrent._\\nimport scala.concurrent.duration._\\nimport scala.concurrent.ExecutionContext.Implicits.global\\n\\nval timer = new java.util.Timer()\\ndef timeout[A](a: => A, duration: Duration)(implicit ec: ExecutionContext): Future[A] = {\\n    val p = Promise[A]()\\n    timer.schedule(new java.util.TimerTask() {\\n        def run() = {\\n            p.success(a)\\n        }\\n    }, duration.toMillis)\\n    p.future\\n}\\n\\ntimeout(println(\\\"Hello World\\\"), 1 millisecond)\\ntimeout(println(\\\"Hello Timer\\\"), 1 millisecond)\\n</code></pre>\\n<p>定义一个timeout高阶函数，接受一个<code>=> A</code>函数作为参数，然后就可以方便地重复调用了。\\n</p>\\n<h2>自定义控制结构+鸭子类型</h2>\\n<h3>try with resources</h3>\\n<p>在Java中，在处理一些资源相关的数据时，经常需要用一个<code>try .... catch ... finally { res.close(); }</code>的结构，同样地，这种结构使得代码的缩进层次和逻辑抽象层次不同而影响阅读。另外更严重的问题是常常忘记关闭资源。</p>\\n<p>Java中的一种解决方案是用<code>template method</code>模式，比如Spring JdbcTemplate，传入一个匿名类，比如：</p>\\n<!-- language: lang-java -->\\n<pre><code>jdbcTemplate.execute(new StatementCallback(){\\n    public Object doInStatement(Statement stmt) throws SQLException, DataAccessException {\\n        // your real logic here\\n    }\\n}\\n</code></pre>\\n<p>可以看到，真正的逻辑被缩进了两层，有很多boilerplate代码。</p>\\n<p>Java 1.7中引入了try with resources的语法，一定程度上解决了这个问题：</p>\\n<!-- language: lang-java -->\\n<pre><code>try (BufferedReader br = new BufferedReader(new FileReader(path))) {\\n    return br.readLine();\\n}\\n</code></pre>\\n<p>但是要求在try里面的资源必须实现<code>AutoCloseable</code>接口。当然了，Java中很多东西都是围绕接口转。接口就意味着规约，要使用try-with-resources语法，就必须符合这个规约。</p>\\n<p>再看看Scala中如何实现：</p>\\n<!-- language: lang-scala run -->\\n<pre><code>def using[T &#x3C;: { def close() }](resource: T)(block: T => Unit) {\\n  try {\\n    block(resource)\\n  }finally {\\n    if (resource != null) resource.close()\\n  }\\n}\\ncase class Resource {\\n    def close() = println(\\\"I'm closing\\\")\\n    def doSomething() = println(\\\"boring\\\")\\n}\\n\\nval res = Resource()\\n\\nusing[Resource](res){ res =>\\n    res.doSomething()\\n}\\n</code></pre>\\n<p>和<code>try-with-resources</code>的语法比较像吧，不过不同的是，<code>using</code>不要求传入的resource必须实现某种接口，只需要该类型定义了一个<code>def close(): Unit</code>方法。这就是所谓的鸭子类型，只要你走起来像鸭子，那你就是鸭子，不是一个很好的比喻，不过将就吧。</p>\\n<h3>break</h3>\\n<p>当你学习scala的时候，你会发现很多java中的关键字在scala中是不支持的，其中一个就是：<code>break</code>。</p>\\n<p>在一个循环的时候，当满足某个条件就退出当前循环，是一个很普遍的用法，为什么scala中会不是一个关键字呢？我自己感觉是scala强调FP，而break有很浓的指令式编程的味道。</p>\\n<p>那我就是想用break怎么办？不要紧，我们可以自己定义一个自己的break。</p>\\n<!-- language: lang-scala run -->\\n<pre><code>class Breaks {\\n  private class BreakControl extends RuntimeException\\n  private val breakException = new BreakControl\\n\\n  // breakable接受一个() => Unit的函数作为参数，是一个高阶函数。\\n  def breakable(op: => Unit) {\\n    try {\\n      op\\n    } catch {\\n      case ex: BreakControl =>\\n        if (ex ne breakException) throw ex\\n    }\\n  }\\n\\n  def break(): Nothing = { throw breakException }\\n}\\nobject Breaks extends Breaks\\n\\n\\nimport Breaks.{break, breakable}\\n// 通过高阶函数来实现break\\nbreakable {\\n  for (i &#x3C;- (1 to 1000)) {\\n    if (i > 10){\\n      break\\n    } else {\\n      println(i)\\n    }\\n  }\\n}\\n</code></pre>\\n<p>是不是很棒？！scala没有我们可以自己造。这就是高阶函数的用处之一。</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/高阶函数.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-21T19:16:45.000Z\",\"path\":\"/2013/high-order-function\",\"title\":\"高阶函数\",\"excerpt\":\"所谓高阶函数（high order function），其实就是可以接受其他函数作为参数的函数。\",\"tags\":[\"scala\",\"functional programming\",\"high order function\"]}}},{\"node\":{\"html\":\"<h2>上下文</h2>\\n<p>很多时候为了提高性能，减少IO操作，都会将数据load出来之后缓存在内存中。本站的实现过程中也遇到类似的问题，不希望每次有人访问的时候就读取一次md文件，或者从MongoDB中查一次，而是直接在内存中读取。</p>\\n<p>带来因减少IO而提升性能的好处的同时，也出现一个人和“缓存”解决方案都会遇到的问题：数据一致性。</p>\\n<p>简单来说，就是你有同样的一份数据，冗余存放在两个地方，如何确保这两个地方的数据是一致的？再具体一点，可能的问题有：</p>\\n<ul>\\n<li>\\n<p>数据更新的原子性</p>\\n<p>更新数据的时候，同时将两个地方的数据都同步更新，任何一个地方更新失败，则整体更新失败。</p>\\n</li>\\n<li>\\n<p>缓存线程安全的问题</p>\\n<p>如果缓存既可以被读取，又可能被更新，那么就又线程安全问题：多个线程同时操作同一个值的时候怎么协调？</p>\\n</li>\\n</ul>\\n<h2>具体问题</h2>\\n<p>开始的时候，我将所有的文章列表放在一个<code>scala.collection.mutable.ListBuffer</code>中：</p>\\n<!-- language:lang-scala -->\\n<pre><code>object Application extends Controller {\\n  lazy val allPosts: ListBuffer[Post] = ...\\n\\n}\\n</code></pre>\\n<p>因为新发布博客会增加集合内数据，所以这里用ListBuffer比较自然。当然用<code>var</code> + immutable collection也可以。</p>\\n<p>对<code>allPost</code>的操作主要有三个：</p>\\n<ol>\\n<li>\\n<p>在线编写一个博客的时候需要添加到集合中</p>\\n</li>\\n<li>\\n<p>该集合本身是无序的，因为排序的规则可能有多种，展现的时候再排序</p>\\n</li>\\n<li>\\n<p>更新一篇博文的时候同时更新集合中内容。</p>\\n</li>\\n</ol>\\n<p>因为本身Application Object是单例的，多个线程共同运行的场景下就会出现线程安全的问题，类似Servlet中instance级别变量的问题。</p>\\n<h2>解决方案</h2>\\n<p>直观地想，理想的解决方案就是将所有对<code>allPost</code>的写操作都串行起来，这样即使有多个线程同时操作，也没问题了。但是如何将实现串行呢？</p>\\n<p>在指令式编程的世界里，这个问题比较难于解答，一般需要通过加锁来解决。而一般的程序员看到<code>lock</code>, <code>synchronized</code>这些关键字就头疼了，即使经过无数次盲试之后侥幸实现了，也会在产品上线的时候出现这样那样、莫名其妙、让你大呼“这不科学”，“WTF”的惊呼！</p>\\n<p>但是在scala中，我们却不用担心，因为我们有<code>Akka Actor</code>。</p>\\n<p>Actor是另外一种并行计算方式，不同于线程共享内存的并发模型，Actor是基于消息的，强调不同Actor之间不共享数据。有了Actor，问题就迎刃而解了。</p>\\n<p>具体思路是：重建一个单例Actor，由该Actor来维护ListBuffer变量，所有的写操作，全部通过该消息提交任务交给其处理，这样就将并发的多个写请求串行起来了。</p>\\n<p>代码片段：</p>\\n<!-- language:lang-scala -->\\n<pre><code>object PostManager {\\n  // 单例manager actor\\n  lazy val manager = Akka.system.actorOf(Props[PostManager])\\n  case class NewPost(post: Post)\\n  \\n  def saveOrUpdate(unsavedPost: Post) = {\\n    manager ! NewPost(unsavedPost)\\n  }\\n}\\n\\nclass PostManager extends Actor {\\n  import PostManager._\\n  // actor是单例的，所以文章集合也是单例的。\\n  // all posts, but not ordered.\\n  lazy val allPosts: ListBuffer[Post] = Post.allPosts\\n  \\n  def receive = {\\n    case NewPost(newPost) =>\\n      // 先更新数据库，这样如果更新失败，就不会运行之后代码。一定程度上实现原子性。\\n      Post.upsert(newPost)\\n      \\n      val idx = allPosts.indexWhere( _.fileName == newPost.fileName )\\n      \\n      if (idx == -1){\\n        allPosts += newPost\\n      } else {\\n        allPosts.update(idx, newPost)\\n      }\\n  }\\n}\\n</code></pre>\\n<p>全站一个文章集合变量感觉有点\\\"玩具\\\"的感觉，不过这个模型其实是可以扩展的，比如将来如果支持多用户、多博客系统，我们可以每个用户创建一个Actor、维护该用户自己的文章列表。这个Actor模型还是可以重用的。</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Actor协调并发场景下的集合操作.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-17T14:16:45.000Z\",\"path\":\"/2013/actor-collection-collabration\",\"title\":\"边建边学-3：Actor协调并发场景下的集合操作\",\"excerpt\":\"很多时候为了提高性能，减少IO操作，都会将数据load出来之后缓存在内存中。本站的实现过程中也遇到类似的问题，不希望每次有人访问的时候就读取一次md文件，或者从MongoDB中查一次，而是直接在内存中读取。\",\"tags\":[\"scala\",\"functional programming\"]}}}],\"pathPrefix\":\"\",\"first\":false,\"last\":false,\"index\":2,\"pageCount\":3}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---2-724d75723428e1a93bc3.js","module.exports = {\"data\":{\"allMarkdownRemark\":{\"totalCount\":25,\"edges\":[{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2019/Tokio Future.poll返回NotReady.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Tokio Future.poll返回NotReady\",\"date\":\"March 01, 2019\",\"path\":\"/2019/rust-tokio-futures-poll-not-ready\",\"tags\":[\"rust\",\"tokio\",\"Future\",\"async programming\"],\"excerpt\":\"如何在Future.poll中返回Async::NotReady\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/How To Read Rust API Doc.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"How To Read Rust API Doc\",\"date\":\"June 01, 2018\",\"path\":\"/2018/how-to-read-rust-api-doc\",\"tags\":[\"rust\"],\"excerpt\":\"\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/简单比较下http2和http1.1的性能.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"简单比较下http/2和http/1.1的性能\",\"date\":\"March 19, 2018\",\"path\":\"/2018/simple-performance-comparison-between-http2-and-http1\",\"tags\":[\"http/2\",\"测试\"],\"excerpt\":\"简单对比http/1.1和http/2的性能\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/微服务架构下的开发环境问题.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"微服务架构下的开发环境问题\",\"date\":\"March 16, 2018\",\"path\":\"/2018/development-environment-for-microservices\",\"tags\":[\"微服务\",\"架构\",\"开发环境\",\"microservices\"],\"excerpt\":\"本文介绍如何在微服务架构下解决开发环境的搭建、共享的问题。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/为Gatsby博客添加分页功能.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"为Gatsby博客添加分页功能\",\"date\":\"March 12, 2018\",\"path\":\"/2018/support-pagination-for-gatsby-blog\",\"tags\":[\"blog\",\"gatsby\"],\"excerpt\":\"根据Egghead上的教程，做出的博客站点有个缺陷，那就是没有分页功能，对于勤奋的博主来说，在一个页面上显示所有文章列表有点不完美，这里我们改造一下，加入分页功能。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/为你的Gatsby博客添加评论功能.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"为你的Gatsby博客添加评论功能\",\"date\":\"March 12, 2018\",\"path\":\"/2018/enable-comments-for-gatsby-blog\",\"tags\":[\"blog\"],\"excerpt\":\"Gatsby打造的博客已经很不错了，但是缺少一个评论功能。本文简单介绍如何集成Disqus评论服务到你的博客站点。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/转用Gatsby搭建博客.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"转用Gatsby打造基于github的博客站点\",\"date\":\"March 08, 2018\",\"path\":\"/2018/blog-with-gatsby\",\"tags\":[\"blog\",\"github\",\"gatsby\"],\"excerpt\":\"如何用Gatsby打造一个博客\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/一则奇怪的Toubleshooting.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"记一次奇怪的troubleshooting\",\"date\":\"March 08, 2018\",\"path\":\"/2018/skipper-sni-domain-fronting\",\"tags\":[\"skipper\",\"SNI\",\"domain fronting\"],\"excerpt\":\"在Skipper转发请求到一个https站点的时候，返回莫名404.\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2016/JSON解析利器JQ.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"JSON解析利器---JQ\",\"date\":\"March 25, 2016\",\"path\":\"/2016/jq\",\"tags\":[\"bash\",\"jq\",\"json\"],\"excerpt\":\"在API first的时代，json作为最常用的格式，充斥着程序猿的屏幕各个角落，掌握一门解析、过滤、转换json输出的工具，已经成为程序猿们安身立命的必要技能。 这里隆重向大家介绍[jq](https://stedolan.github.io/jq/).\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2016/Function的协变.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Function的协、逆变\",\"date\":\"February 04, 2016\",\"path\":\"/2016/function-covariant-contravariant\",\"tags\":[\"scala\",\"functional programming\"],\"excerpt\":\"泛型编程的时候，协变(covariant)还是逆变(contravariant)很重要，在设计上层API接口的时候，正确的使用协变、逆变可以更好地约束程序员的行为，让实现变得安全、一致。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/如何在Scala中实现AOP.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"用Mixin组合实现Scala中的AOP\",\"date\":\"August 13, 2015\",\"path\":\"/2015/aop-by-mixin-in-scala\",\"tags\":[\"scala\",\"functional programming\",\"AOP\",\"mixin\"],\"excerpt\":\"在Java世界，AOP（Aspect Oriented Programming， 面向方面编程)是很多框架的基础。这种将关注点按照“方面”来切分的编程模型极大地简化了编程的复杂度，尤其是在多维度因子交织在一起的时候的各种场景。对于代码的可读性、可维护性、可重用性都是极大的帮助。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Scala雾里看花.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Scala雾里看花\",\"date\":\"April 23, 2015\",\"path\":\"/2015/scala-trouble-shooting\",\"tags\":[\"scala\",\"trouble shooting\"],\"excerpt\":\"Scala的学习过程中，经常会碰到一些莫名其妙的现象，很多时候，这些语言层面的“怪象”都与scala编译器或者scala的类型系统有关。本文不是对编译器和类型系统的介绍，而是重点介绍遇到这些现象的时候，用什么样的方式，拨开云雾见蓝天，通过这些工具获取一些细节帮你了解编译器和类型系统如何工作。工欲善其事，必先利其器。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Docker创建MySQL主从复制以及CDC测试.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"MySQL Master/Slave Replication on Docker\",\"date\":\"April 21, 2015\",\"path\":\"/2015/mysql-replication-on-docker\",\"tags\":[\"docker\",\"mysql\"],\"excerpt\":\"How to setup Mysql master/slave replication.\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2014/Scala函数式异常处理.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Scala函数式异常处理\",\"date\":\"May 04, 2014\",\"path\":\"/2014/scala-error-handling-in-fp-style\",\"tags\":[\"scala\",\"functional programming\",\"exception handling\"],\"excerpt\":\"经常看到很多示例代码，简洁的让人爱不释手，可是真正自己实现的时候，不得不添加各种各样的异常处理逻辑，最后发现代码总量的80%都是再做异常处理，而真正的代码逻辑只有很少的一部分。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2014/高种泛型.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"高种泛型 (Generics of a Higher Kind)\",\"date\":\"January 08, 2014\",\"path\":\"/2014/generics-of-a-higher-kind\",\"tags\":[\"scala\",\"functional programming\",\"Generics\"],\"excerpt\":\"Generics of a Higher Kind翻译加自我理解。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/map-flatMap-for.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"map/flatMap/for in Action\",\"date\":\"December 01, 2013\",\"path\":\"/2013/map-flatmap-for\",\"tags\":[\"scala\",\"functional programming\"],\"excerpt\":\"前文说过了，高阶函数式函数式语言中的基石，而`map`, `flatMap`更是重要。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/fold编程.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"折纸的艺术：fold编程\",\"date\":\"November 27, 2013\",\"path\":\"/2013/fold\",\"tags\":[\"scala\",\"functional programming\",\"fold\"],\"excerpt\":\"Eric Meijer说：递归是函数式编程的GOTO，应该尽可能避免。如何避免，OO中我们用while循环，FP中我们用`fold`。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Monad.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Monad\",\"date\":\"November 26, 2013\",\"path\":\"/2013/monad\",\"tags\":[\"scala\",\"functional programming\",\"monad\"],\"excerpt\":\"函数式语言与OO（确切地讲是指令式编程）的思维方式是完全不同的，很多OO中的经验在函数式语言中不是很匹配，比如设计模式，那就是一个OO中的特定术语，而在FP中，大家常谈的是对于习惯OO思维的程序员来说玄而又玄的Monad。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/高阶函数.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"高阶函数\",\"date\":\"November 21, 2013\",\"path\":\"/2013/high-order-function\",\"tags\":[\"scala\",\"functional programming\",\"high order function\"],\"excerpt\":\"所谓高阶函数（high order function），其实就是可以接受其他函数作为参数的函数。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Actor协调并发场景下的集合操作.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"边建边学-3：Actor协调并发场景下的集合操作\",\"date\":\"November 17, 2013\",\"path\":\"/2013/actor-collection-collabration\",\"tags\":[\"scala\",\"functional programming\"],\"excerpt\":\"很多时候为了提高性能，减少IO操作，都会将数据load出来之后缓存在内存中。本站的实现过程中也遇到类似的问题，不希望每次有人访问的时候就读取一次md文件，或者从MongoDB中查一次，而是直接在内存中读取。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Enumerator-Iteratee-Enumeratee.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Enumerator / Iteratee / Enumeratee\",\"date\":\"November 11, 2013\",\"path\":\"/2013/enumerator-iteratee-enumeratee\",\"tags\":[\"scala\",\"playframework\",\"blog\"],\"excerpt\":\"Stream对于指令式编程已经比较成熟了，有大量的类库，丰富的API。但是对于强调不可变量，尽可能无副作用的FP来说，要考虑语言适配的问题，而目前，流行的解决方案就是：Enumerator/Iteratee。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/集成PlantUML和Markdown.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"边建边学-2：集成PlantUML和Markdown\",\"date\":\"November 07, 2013\",\"path\":\"/2013/markdown-plantuml-integration\",\"tags\":[\"markdown\",\"plantuml\",\"blog\"],\"excerpt\":\"如何用Markdown+PlantUML结合来写图文并茂的博客。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/EssentialAction-in-Playframework.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"EssentialAction in Playframework\",\"date\":\"November 05, 2013\",\"path\":\"/2013/essential-action-in-play\",\"tags\":[\"scala\",\"playframework\"],\"excerpt\":\"Playframework中EssentialAction理解\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/用markdown写博客.markdown absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"边建边学-1: 用Markdown写博文\",\"date\":\"November 01, 2013\",\"path\":\"/2013/blogging-with-markdown\",\"tags\":[\"markdown\",\"blog\"],\"excerpt\":\"本文将是一个系列文章，循序渐进地介绍本站的构建过程，不只是简单的技术介绍，重点是建站过程遇到的问题分析，以及解决的过程，所以起名**“边建边学”**系列。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/开篇.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"开篇\",\"date\":\"October 25, 2013\",\"path\":\"/2013/start\",\"tags\":[],\"excerpt\":\"网络博客\"}}}]}},\"pathContext\":{\"group\":[{\"node\":{\"html\":\"<h2>Java中的AOP</h2>\\n<p>在Java世界，AOP（Aspect Oriented Programming， 面向方面编程)是很多框架的基础。这种将关注点按照“方面”来切分的编程模型极大地简化了编程的复杂度，尤其是在多维度因子交织在一起的时候的各种场景。对于代码的可读性、可维护性、可重用性都是极大的帮助。</p>\\n<p>不过AOP一个令人诟病的地方是其透明性，也就是说对于开发人员来说，我不知道我的某个方法会不会被某个Aspect切面一刀，有些时候，会造成一些意想不到的后果，比如Spring的transaction管理，如果通过aop的方式来定义，比如：</p>\\n<!-- language: xml -->\\n<pre><code>&#x3C;tx:advice id=\\\"txCommonAdvice\\\" transaction-manager=\\\"transactionManager\\\">\\n    &#x3C;tx:attributes>\\n        &#x3C;tx:method name=\\\"save*\\\" propagation=\\\"REQUIRED\\\"/>\\n        &#x3C;tx:method name=\\\"remove*\\\" propagation=\\\"REQUIRED\\\"/>\\n        &#x3C;tx:method name=\\\"update*\\\" propagation=\\\"REQUIRED\\\"/>\\n        &#x3C;tx:method name=\\\"delete*\\\" propagation=\\\"REQUIRED\\\"/>\\n        &#x3C;tx:method name=\\\"*\\\" propagation=\\\"REQUIRED\\\" read-only=\\\"true\\\"/>\\n    &#x3C;/tx:attributes>\\n&#x3C;/tx:advice>\\n</code></pre>\\n<p>那么被这个切面拦截的任何方法都会导致Spring Transaction Manager启动一个事务，甚至是像<code>toString()</code>, <code>equal(other)</code>等这样的方法，而且因为其透明性，开发人员往往意识不到这个问题。</p>\\n<h2>Scala中的AOP</h2>\\n<p>在Scala的世界里，AOP的思想其实也是适用的，当然，因为Scala就运行在jvm上面，很多code weaver工具也照样是可以用的，比如aspectj, asm等等，个人不是很喜欢这些东西，更喜欢用显式的方式来告诉我的代码读者，我的代码会做哪些事情。No Magic，是我的一个信条。</p>\\n<p>Scala的Mixin机制trait，可以很好地实现显式的AOP，举个例子：</p>\\n<!-- language: scala run -->\\n<pre><code>trait Task { def execute }\\ntrait TaskLogging extends Task {\\n    abstract override def execute = {\\n        println(\\\"before execute\\\")\\n        super.execute\\n        println(\\\"after execute\\\")\\n    }\\n}\\nclass MyTask extends Task {\\n    override def execute = {\\n        println(\\\"do something\\\")\\n    }\\n}\\n\\nval task = new MyTask\\ntask.execute    // 输出 'do something'，没什么稀奇的\\n\\nval task2 = new MyTask with TaskLogging\\ntask2.execute   // 点击'run'看看会输出什么？\\n</code></pre>\\n<p>在上面代码中，<code>MyTask</code>和<code>TaskLogging</code>都是只关注于自己的逻辑（Aspect），在运行时，可以构建一个<code>MyTask with TaskLogging</code>的<code>task2</code>instance，就可以将两个方面组合在一起了。当然你还可以增加新的方面，比如：</p>\\n<!-- language: scala -->\\n<pre><code>trait Transactional extends Task {\\n    abstract override def execute = {\\n        println(\\\"begin transaction\\\")\\n        try {\\n            super.execute\\n            println(\\\"commit transaction\\\")\\n        } catch {\\n            case _: Exception =>\\n                println(\\\"rollback transaction\\\")\\n        }\\n    }\\n}\\n\\nval task3 = new MyTask with TaskLogging with Transactional\\ntask3.execute\\n</code></pre>\\n<p>这样，就可以构建一个有事务，有logging的task。</p>\\n<p>总结一下，定义一个Aspect的步骤：</p>\\n<ol>\\n<li>重载trait中的方法</li>\\n<li>方法前逻辑，比如logging、begin transaction等等</li>\\n<li>调用<code>super</code>对象的方法</li>\\n<li>方法后逻辑，比如logging、commit transaction等</li>\\n</ol>\\n<p>这里，主要的知识点是调用<code>super.execute</code>的执行顺序，在用<code>with Trait</code>定义一个新类型的时候，多个Trait会形成一个Stack，执行的时候会按照出栈顺序执行，比如：</p>\\n<!-- language: scala -->\\n<pre><code>val task = new MyTask with TaskLogging with Transactional\\ntask.execute\\n</code></pre>\\n<p>TaskLogging先入栈，Transactional后入，那么执行的时候，先执行Transactional，后执行TaskLogging，就会输出：</p>\\n<!-- language -->\\n<pre><code>begin transaction\\nbefore execute\\ndo something\\nafter execute\\ncommit transaction\\n</code></pre>\\n<p>换一个顺序：</p>\\n<!-- language: scala -->\\n<pre><code>val task = new MyTask with TaskLogging with Transactional\\ntask.execute\\n</code></pre>\\n<p>那么输出将会是另外一个顺序。    </p>\\n<h3>抽象方法中的super call</h3>\\n<p>注意一个细节，在<code>TaskLogging.execute</code>中，我们调用了<code>super.execute</code>，仔细想想，感觉很奇怪，几个疑点：</p>\\n<ol>\\n<li>TaskLogging的super是谁？</li>\\n<li>为什么<code>MyTask.execute</code>是最后执行的？</li>\\n</ol>\\n<p>查询《Programming in Scala》“traits as stackable modifications“章节后，我们可以了解到：</p>\\n<ol>\\n<li>trait中的super call是动态绑定，是在另外一个trait或者class实现一个具体的方法之后。</li>\\n<li>所以trait中的方法必须标注: <code>abstract override</code>，以此来告诉编译器，你是故意这么来用的。</li>\\n</ol>\\n<p>用scalac编译上述源文件，生成.class文件之后，用<code>jad</code>等工具查看反编译类，会发现其实<code>MyTask with TaskLogging</code>会产生一个匿名类，继承MyTask，实现TaskLogging接口，回头再看TaskLogging中定义的<code>super.execute</code>，就能理解了，原来在调用TaskLogging.execute方法的时候的<code>this</code>，已经是匿名类的实例了，当然其super是合法的。然后其执行顺序也就能理解了。</p>\\n<p>但是这里明显有一个矛盾：从代码执行角度看，生成的匿名类是MyTask和TaskLogging的子类，这点可以通过<code>task.isInstanceOf[MyTask] &#x26;&#x26; task.isInstanceOf[TaskLogging]</code>中判断得出，但是从字面上看，在trait TaskLogging中调用<code>super.execute</code>，又给人感觉莫名其妙。可能这也是scala需要在jvm上运行所做的妥协吧。</p>\\n<h2>Stackable Actor模式</h2>\\n<p>在Akka中，这种Mixin的用法非常的有帮助，比如在对actor进行监控的时候，我们希望能记录每个actor发送消息的路径，每个actor接收消息之后处理所花费的时间、调用次数等等，如果不用这种trait mixin的话，代码将非常凌乱。</p>\\n<p>之所以单独将这个模式提出来，其实还因为这个模式中利用了PartialFunction的特性，让代码更加的优雅。看例子：</p>\\n<!-- language: scala run -->\\n<pre><code>type Receive = PartialFunction[Any, Unit]\\n\\ntrait Actor {\\n    def receive: Receive\\n    def unhandled(msg: Any): Unit = println(s\\\"unhandled message: $msg\\\")\\n}\\n\\ntrait StackableActor extends Actor {\\n    def wrapped: Receive\\n    def receive: Receive = {\\n        case x => if (wrapped.isDefinedAt(x)) wrapped(x) else unhandled(x)\\n    }\\n}\\n\\n trait LoggingActor extends StackableActor { \\n    override def wrapped: Receive = { \\n        case x => \\n            println(s\\\"start processing message: $x\\\")\\n            super.receive(x)\\n            println(\\\"end of processing message:\\\" + x) \\n    }\\n}\\n\\nclass MyActor extends StackableActor with LoggingActor {\\n    override def wrapped: Receive = {\\n        case \\\"something\\\" =>\\n            println(\\\"I can only do 'something'\\\")\\n    }\\n}\\n\\nnew MyActor() receive (\\\"something\\\")\\nnew MyActor() receive (\\\"else\\\")\\n</code></pre>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/如何在Scala中实现AOP.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2015-08-13T10:16:45.000Z\",\"path\":\"/2015/aop-by-mixin-in-scala\",\"title\":\"用Mixin组合实现Scala中的AOP\",\"excerpt\":\"在Java世界，AOP（Aspect Oriented Programming， 面向方面编程)是很多框架的基础。这种将关注点按照“方面”来切分的编程模型极大地简化了编程的复杂度，尤其是在多维度因子交织在一起的时候的各种场景。对于代码的可读性、可维护性、可重用性都是极大的帮助。\",\"tags\":[\"scala\",\"functional programming\",\"AOP\",\"mixin\"]}}},{\"node\":{\"html\":\"<p>Scala的学习过程中，经常会碰到一些莫名其妙的现象，很多时候，这些语言层面的“怪象”都与scala编译器或者scala的类型系统有关。</p>\\n<p>本文不是对编译器和类型系统的介绍，而是重点介绍遇到这些现象的时候，用什么样的方式，拨开云雾见蓝天，通过这些工具获取一些细节帮你了解编译器和类型系统如何工作。工欲善其事，必先利其器。</p>\\n<h2>REPL</h2>\\n<p>Read-Evaluate-Print-Loop, 是一个所有学习scala的同学都要掌握的工具，可以帮你快速测试一些代码，了解一些library怎么使用。</p>\\n<p>在安装scala之后，命令行下执行<code>scala</code>，就会进入REPL.</p>\\n<!-- language: bash -->\\n<pre><code>$ scala\\nWelcome to Scala version 2.11.1 (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_65).\\nType in expressions to have them evaluated.\\nType :help for more information.\\n\\nscala>\\n</code></pre>\\n<p>如果是SBT项目，可以用<code>sbt console</code>进入，之后操作类型，不再重复。</p>\\n<h3>模式</h3>\\n<p>scala REPL有<a href=\\\"http://hongjiang.info/scala-repl-modes/\\\">几种模式</a>，其中比较常用的就是<code>:paste</code>，可以比较方便的输入多行，不过要注意，拷贝粘贴的代码中，不要有Tab，否则会触发auto code completion，出现一堆错误提示。</p>\\n<h3>反射</h3>\\n<h2>命令行参数</h2>\\n<p>通过<code>man scala</code>, <code>man scalac</code>，可以了解scala都有哪些参数可用。注意的是：scala的命令行参数中import了scalac的参数，所以可以在scala命令后面使用任何scalac的参数。其中比较有用的参数有：</p>\\n<ul>\\n<li><code>-X</code>系列，用于输出高级选项概要。也就是正式支持的选项，向后兼容。</li>\\n<li><code>-Y</code>系列。用于输出私有选项信息，可能随版本变化。参见<a href=\\\"http://www.scala-lang.org/old/node/9313\\\">[6]</a><a href=\\\"http://paulbutcher.com/2010/04/26/scala-compiler-advanced-options/\\\">[7]</a></li>\\n</ul>\\n<p><code>scala -X</code>，<code>scala -Y</code>可以分别列出当前版本所支持的所有选项。</p>\\n<h2>参考</h2>\\n<ol>\\n<li><a href=\\\"http://stackoverflow.com/questions/11055210/whats-the-easiest-way-to-use-reify-get-an-ast-of-an-expression-in-scala\\\">What's the easiest way to use reify (get an AST of) an expression in Scala? stackoverflow</a></li>\\n<li><a href=\\\"http://stackoverflow.com/questions/11392622/how-to-investigate-objects-types-etc-from-scala-repl\\\">How to investigate objects/types/etc. from Scala REPL? stackoverflow</a></li>\\n<li><a href=\\\"https://www.parleys.com/tutorial/51c38751e4b0d38b54f4625e/chapter0/about\\\">Practical Type Mining in Scala ,  scaladay 2013</a></li>\\n<li><a href=\\\"http://hongjiang.info/scala-repl-modes/\\\">REPL的几种模式, hongjiang</a></li>\\n<li><a href=\\\"http://docs.scala-lang.org/overviews/reflection/symbols-trees-types.html\\\">Symbols, Trees, and Types, scalaDoc</a></li>\\n<li><a href=\\\"http://www.scala-lang.org/old/node/9313\\\">Difference between -Y and -X compiler options, scala user forum</a></li>\\n<li><a href=\\\"http://paulbutcher.com/2010/04/26/scala-compiler-advanced-options/\\\">Scala Compiler Advanced Options</a></li>\\n</ol>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Scala雾里看花.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2015-04-23T19:16:45.000Z\",\"path\":\"/2015/scala-trouble-shooting\",\"title\":\"Scala雾里看花\",\"excerpt\":\"Scala的学习过程中，经常会碰到一些莫名其妙的现象，很多时候，这些语言层面的“怪象”都与scala编译器或者scala的类型系统有关。本文不是对编译器和类型系统的介绍，而是重点介绍遇到这些现象的时候，用什么样的方式，拨开云雾见蓝天，通过这些工具获取一些细节帮你了解编译器和类型系统如何工作。工欲善其事，必先利其器。\",\"tags\":[\"scala\",\"trouble shooting\"]}}},{\"node\":{\"html\":\"<h2>Pull Mysql Docker Image</h2>\\n<!-- language: bash -->\\n<pre><code>docker pull mysql:5.6\\n</code></pre>\\n<h2>Create MySQL Config Files</h2>\\n<p>For Master, create a <code>mysql.cnf</code> file and add the following content:</p>\\n<!-- language: bash -->\\n<pre><code>[mysqld]\\n\\nserver-id = 1\\nlog_bin\\nbinlog_format = ROW\\nbind-address = 0.0.0.0\\n\\nsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES\\n</code></pre>\\n<p>For Slave, create another <code>mysql.cnf</code> and add the following content:</p>\\n<!-- language: bash -->\\n<pre><code>[mysqld]\\n\\nserver-id = 2\\nlog_bin\\nbinlog_format = ROW\\nbind-address = 0.0.0.0\\n\\nsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES\\n</code></pre>\\n<h2>Start Master/Slave MySQL Containers</h2>\\n<p>Start Master:</p>\\n<!-- language: bash -->\\n<pre><code>docker run --name master -v /my/master:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:5.6\\n</code></pre>\\n<p>Start Slave:</p>\\n<!-- language: bash -->\\n<pre><code>docker run --name slave -v /my/slave:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw --link master:master -d mysql:5.6\\n</code></pre>\\n<p>The slave node needs to link to master node.</p>\\n<h2>Setup Replication</h2>\\n<p>Check the master status:</p>\\n<!-- language: bash -->\\n<pre><code>mysql> show master status \\\\G\\n*************************** 1. row ***************************\\n             File: mysql-bin.000003\\n         Position: 120\\n     Binlog_Do_DB: \\n Binlog_Ignore_DB: \\nExecuted_Gtid_Set: \\n1 row in set (0.00 sec)\\n</code></pre>\\n<p>the above information is necessary for the slave configuration, especially the <code>File</code> and <code>Position</code>.</p>\\n<p>Connect to Slave node, in Mysql Shell:</p>\\n<!-- language: bash -->\\n<pre><code>mysql> change master to master_host='master',master_user='root',master_password='my-secret-pw',master_log_file='mysql-bin.000003',master_log_pos=120;  \\nQuery OK, 0 rows affected (0.00 sec)  \\n\\nmysql> start slave;\\nQuery OK, 0 rows affected (0.01 sec)\\n\\nmysql> show slave status\\\\G\\n\\n// until you see the following two options are 'Yes'\\nSlave_IO_Running: Yes  \\nSlave_SQL_Running: Yes  \\n</code></pre>\\n<p>You need to change the parameters like <code>master_log_file</code> and <code>master_log_pos</code> based on previous <code>show master status</code> output.</p>\\n<h2>Test</h2>\\n<p>Create some tables and insert some data on master, and check if those data are synced to slave. </p>\\n<h2>Change Data Capture (CDC)</h2>\\n<p>Here I used an open source library <a href=\\\"https://github.com/whitesock/open-replicator\\\">open-replicator</a></p>\\n<!-- language: scala -->\\n<pre><code>import com.google.code.or._\\nimport com.google.code.or.binlog._\\nimport com.google.code.or.binlog.impl.event.FormatDescriptionEvent\\n\\nval or = new OpenReplicator()\\nor.setUser(\\\"root\\\")\\nor.setPassword(\\\"my-secret-pw\\\")\\nor.setServerId(2);\\nor.setHost(\\\"slave\\\")\\nor.setPort(3306)\\nor.setBinlogPosition(120)\\nor.setBinlogFileName(\\\"mysql-bin.000004\\\")\\n\\nor.setBinlogEventListener(new BinlogEventListener() {\\n  def onEvents(event: BinlogEventV4) = {\\n\\n  }\\n})\\n\\nor.start()\\n</code></pre>\\n<p>TBD.\\nSee <code>com.linkedin.databus2.producers.ORListener</code></p>\\n<h2>References</h2>\\n<ol>\\n<li><a href=\\\"https://registry.hub.docker.com/_/mysql/\\\">Mysql Docker Official Repo</a></li>\\n<li><a href=\\\"https://github.com/linkedin/databus/wiki/Databus-for-MySQL\\\">Databus for MySQL</a></li>\\n</ol>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Docker创建MySQL主从复制以及CDC测试.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2015-04-21T07:16:45.000Z\",\"path\":\"/2015/mysql-replication-on-docker\",\"title\":\"MySQL Master/Slave Replication on Docker\",\"excerpt\":\"How to setup Mysql master/slave replication.\",\"tags\":[\"docker\",\"mysql\"]}}},{\"node\":{\"html\":\"<p>经常看到很多示例代码，简洁的让人爱不释手，可是真正自己实现的时候，不得不添加各种各样的异常处理逻辑，最后发现代码总量的80%都是再做异常处理，而真正的代码逻辑只有很少的一部分。</p>\\n<p>异常处理对于指令式和函数式编程都是同样需要的，只是因为实现方式的不同，让函数式编程看上去更加简洁，优雅，不需要像指令式那么繁琐。</p>\\n<p>本文的目的，就是介绍函数式编程中常用的一些异常处理策略。记得把这些瑞士军刀放到你的百宝箱中，以后一定用得上。</p>\\n<h2>空判断Option</h2>\\n<p>如果采访100个程序员，让所有人投票他们在编程时最讨厌做的事情，但又经常犯错误的地方，我估计十有八九会是“空判断”了。</p>\\n<p><code>Null</code>代表着一个对象还没有被初始化，具体点是对象的指针还没有一个确切的地址。在面向对象编程时，因为操作的都是对象，为了避免在一个<code>null</code>上面调用方法，或者 get一个<code>null</code>上的属性，而导致“空值异常”，程序员不得不做下面的事情：</p>\\n<p>假设有下面一个场景：</p>\\n<!-- language:uml -->\\n<pre><code>Selling --> Store\\nSelling --> Product\\n</code></pre>\\n<p>简单说，一个商场内有很多商店(Store)，每个商店卖(Selling)很多种商品(Product)，如果希望找出所有销售玩具的商店：</p>\\n<!-- language:java -->\\n<pre><code>public List&#x3C;Store> findByProductCategory(Category category) {\\n  if (category == null)               &#x3C;1>\\n    return null;\\n  List&#x3C;Product> allProducts = getAllProducts(); // DB lookup\\n  for (Product prod : allProducts) {\\n    if (prod.category == null)        &#x3C;2>\\n      continue; \\n    if (category.equals(prod.category)){\\n    \\n</code></pre>\\n<h2>参考</h2>\\n<ol>\\n<li><a href=\\\"https://tersesystems.com/2012/12/27/error-handling-in-scala/\\\">Error Handling in Scala. https://tersesystems.com/2012/12/27/error-handling-in-scala. 2012</a></li>\\n</ol>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2014/Scala函数式异常处理.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2014-05-04T07:16:45.000Z\",\"path\":\"/2014/scala-error-handling-in-fp-style\",\"title\":\"Scala函数式异常处理\",\"excerpt\":\"经常看到很多示例代码，简洁的让人爱不释手，可是真正自己实现的时候，不得不添加各种各样的异常处理逻辑，最后发现代码总量的80%都是再做异常处理，而真正的代码逻辑只有很少的一部分。\",\"tags\":[\"scala\",\"functional programming\",\"exception handling\"]}}},{\"node\":{\"html\":\"<p>译者按语：很多翻译中将Kind和Type都翻译为“类型”，但实际上两者还是有不同的，本文中，将<code>Kind</code>翻译为“种类”，取王侯将相宁有种乎之意，是骨子里的东西。而将<code>type</code>译为“类型”。</p>\\n<p>学习函数式语言如果想真正入门，一个不可避免的话题就是monad/monoid，而这些范畴论中的词汇都异常抽象，难于理解，尤其是对于从java领域转过来的同学，在很多FP的基础东西不了解情况下来研究monad就更加的困难，比如高种泛型。</p>\\n<p><code>泛型</code> 我们都知道，就是某种类型的泛化（一般化），就是将某些特殊类型进行抽象，抽出一种一般化的类型<code>T</code>。而<code>高种泛型</code>就是在泛型的基础上再进行一次抽象。</p>\\n<ul>\\n<li>\\n<p>First Order Abstraction</p>\\n<p>first-order可以理解为”单次抽象“，将特定类型抽象一次，比如类型：<code>T</code>, <code>T</code>是什么？可以是任何具体类型，String，Integer，Date等等，不难发现，这就是Java中的泛型。</p>\\n</li>\\n<li>\\n<p>Higher Order Abstraction</p>\\n<p>对应first-order的单次抽象，高阶抽象就是再次抽象，也就是说：在某个东东的抽象上再进行抽象，抽象的抽象。晕了吧！</p>\\n</li>\\n</ul>\\n<p>在继续之前，我们还得熟悉几个概念：</p>\\n<ul>\\n<li>\\n<p>值构造器</p>\\n<p>值构造器是一个function / method，接受特定值参数来构造一个特定的值(value)</p>\\n<p>值构造器可以有多态：接受不同类型的参数，也可以是抽象abstract的。</p>\\n</li>\\n<li>\\n<p>类型构造器</p>\\n<p>类型构造器是一个类型，接受一个特定类型参数来构造一个特定的类型。</p>\\n<p>和值构造器一样，类型构造器也可以有多态，这是高阶类型的关键。</p>\\n</li>\\n</ul>\\n<p>先说这么多概念有什么用呢？我们还是先看一个具体的例子。</p>\\n<h2>例子：Iterable</h2>\\n<p>观察下面代码，我们来玩个找不同的游戏：</p>\\n<!-- language:scala -->\\n<pre><code>trait Iterable[T] {\\n  def filter(p: T => Boolean): Iterable[T]\\n  def remove(p: T => Boolean): Iterable[T] = filter(x => !p(x))\\n}\\n\\ntrait List[T] extends Iterable[T] {\\n  def filter(p: T => Boolean): List[T]\\n  override def remove(p: T => Boolean): List[T] = filter(x => !p(x))\\n}\\n</code></pre>\\n<p>看到两段代码有什么不同了吗？什么代码重复了？</p>\\n<p>很容易发现：在<code>List[T]</code>中的两个方法主体结构和<code>Iterable[T]</code>中的几乎完全相同，只是返回类型不同，都期望返回自身类型。如果我们能够将返回类型也复用，那是否就可以完全去除这些重复代码呢？</p>\\n<h3>通过类型构造器多态来去除重复代码</h3>\\n<p>看下面代码：</p>\\n<!-- language:scala -->\\n<pre><code>trait Iterable[T, Container[X]] {\\n  def filter(p: T => Boolean): Container[T]\\n  def remove(p: T => Boolean): Container[T] = filter(x => !p(x))\\n}\\n\\ntrait List[T] extends Iterable[T, List]\\n</code></pre>\\n<p>这是怎么做到的？很简单，引入了<strong>类型构造器多态</strong>的概念。上面例子中：<code>Iterable[T, Container[X]]</code>的<code>Iterable</code>是类型构造器，接受两个类型参数，引入多态概念，同样的类型构造器，让其可以接受不同类型的类型参数<code>List</code>。是不是和普通方法多态没什么区别？</p>\\n<!-- language:java -->\\n<pre><code>public Iterable iterable(T t, Container&#x3C;X> container) { ... }\\npublic Iterable iterable(T t, List list) { ... }\\n</code></pre>\\n<p>因为Java的泛型没有类型构造器多态的概念，所以Java泛型无法解决上述重复代码的问题。最多只能将返回类型设为超类Iterable，然后在调用子类实现时将其强制类型转换为具体子类。</p>\\n<p>有了上面的例子为上下文，我们再来看两个概念：</p>\\n<h3>类型参数、类型成员</h3>\\n<ul>\\n<li>\\n<p>Type Parameter</p>\\n<p>类型参数，比如: <code>List[T]</code>，List具有一个类型参数<code>T</code>。这里的List就是一个类型构造器。List[Int]就是这个类型构造器接受类型参数Int之后构造的具体类型。</p>\\n</li>\\n<li>\\n<p>Type Member</p>\\n<p>类型成员，比如：<code>trait List { type T }</code></p>\\n<p>这里<code>T</code>变成了一个trait的成员（抽象的）。在List子类实现中，指定其具体类型，比如：<code>List { type T = Int }</code>。而这里的类型成员也可能参数化，比如：<code>type Container[T]</code></p>\\n<p>注意：这里的List只用来示意，并不是scala中的List实现。</p>\\n</li>\\n<li>\\n<p>Type Parameter Vs. Type Member</p>\\n<p>两者很像，只是作用范围和可见性不同:</p>\\n<ul>\\n<li>参数类型只是被参数化的类型的一部分（local，private）。</li>\\n<li>类型变量就和不同变量一样，被封装在整个body中，可以被继承，显式地引用。</li>\\n<li>两者可以相互补充。比如类型成员也可以被参数化。</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>改进Iteratable</h2>\\n<p>对于集合（collection）来说，很多方法，比如：map, flatMap, filter，各有作用，但是其实这些方法都有以下两个共同点：</p>\\n<ol>\\n<li>遍历一个集合</li>\\n<li>产生一个新的集合</li>\\n</ol>\\n<p>仔细想想，是不是所有的这些操作都满足呢？</p>\\n<ul>\\n<li>map遍历一个collection，将其中的元素变形为另外类型并产生一个新的集合。</li>\\n<li>flatMap遍历一个集合，将集合中元素转换为一个集合，并最后将“集合的集合”拉平，形成一个新的集合。</li>\\n<li>filter遍历一个集合，判断是否符合过滤条件，并返回所有符合过滤条件的新的集合。</li>\\n</ul>\\n<p>找到共同点，我们就可以将其抽象出来，进而达到复用、减少重复代码的目的。对上面两个共同点，我们可以用Iterator和Builder来进行抽象实现。</p>\\n<!-- language:scala -->\\n<pre><code>// 产生新集合\\ntrait Builder[Container[X], T] {\\n  def +=(ele: T): Unit\\n  def finalise(): Container[X]\\n}\\n// 遍历（迭代）器\\ntrait Iterator[T] {\\n  def next(): T\\n  def hasNext(): Boolean\\n  def foreach(op: T => Unit): Unit = {\\n    while(hasNext()) { op(next()) }\\n  }\\n}\\n</code></pre>\\n<p>有了这两点抽象，那我们就可以对Iteratable进行改进：</p>\\n<!-- language:scala -->\\n<pre><code>// 类型参数Container\\ntrait Buildable[Container[X]] {\\n  // build方法只是返回一个Builder\\n  def build[T]: Builder[Container[X], T]\\n}\\n\\n// Iteratable没有类型参数Container\\ntrait Iteratable[T] {\\n  // 类型成员Container\\n  type Container[X] &#x3C;: Iteratable[X]\\n  def elements: Iterator[T]\\n  \\n  def mapTo[U, C[X]](f: T => U)(b: Buildable[C]): C[U] = {\\n    val buff = b.build[U]\\n    val elems = elements\\n    while(elems.hasNext) {\\n      buff += f(elems.next)\\n    }\\n    buff.finalise\\n  }\\n  \\n  def filterTo[C[X]](f: T => Boolean)(b: Buildable[C]): C[T] = {\\n    val buff = build[T]\\n    val elems = elements\\n    while(elems.hasNext) {\\n      val elem = elems.next\\n      if (f(elem)) buff += elem\\n    }\\n    buff.finalise\\n  }\\n  \\n  def flatMapTo[U, C[X]](f: T => Iterable[U])(b: Buildable[C]): C[U] = {\\n    val buff = build[U]\\n    val elems = elements\\n    while(elems.hasNext) {\\n      f(elems.next).elements.foreach(buff += _)\\n    }\\n    buff.finalise\\n  }\\n  \\n  def map[U](f: T => U)(b: Buildable[Container]): Container[U] = mapTo[U, Container](f)(b)\\n  \\n  def filterTo(f: T => Boolean)(b: Buildable[Container]) : Container[T] =\\n    filterTo[Container](f)(b)\\n  \\n  def flatMap[U](f: T => Iteratable[U])(b: Buildable[Container]): Container[U] = \\n    flatMapTo[U, Container](f, b)\\n    \\n}\\n</code></pre>\\n<p>上面的代码中，我们用<code>Buildable</code>和<code>Iterator</code>将前文提到的两个共同点进行抽象，并在<code>Iteratable</code>的实现中，利用这两个抽象：Curried的参数<code>b: Buildable[C]</code>以及<code>def elements: Iterator[T]</code>抽象方法，分别实现了：<code>map</code>, <code>filter</code>, <code>flatMap</code>。</p>\\n<p>而Iteratable的具体实现，只需要具化上面两个抽象就可以了。比如List的实现：</p>\\n<!-- language:scala -->\\n<pre><code>object ListBuildable extends Buildable[List] {\\n  def build[T]: Builder[List, T] = new ListBuffer[T] with Builder[List, T]() {\\n    // `+=` 是scala标准库中ListBuffer的方法\\n    def finalise(): List[T] = toList\\n  }\\n}\\n\\nclass List[T] extends Iteratable[T] {\\n  type Container[X] = List[X]\\n  def elements: Iterator[T] = new Iterator {\\n    ......\\n  }\\n}\\n</code></pre>\\n<p>有了上面的实现，我们就可以利用scala的另外一个机制：implicit来实现根据类型来自动选择匹配的<code>Buildable</code>了。</p>\\n<h3>Scala标准库实现</h3>\\n<p>掌握上面的思想，我们回头再看scala标准库中collection的实现机制，就很容易理解了。scala的collection架构正是基于<code>builders</code>和<code>traversals</code>思想实现的。</p>\\n<!-- language:scala -->\\n<pre><code>package scala.collection.mutable\\nclass Builder[-Elem, +To] {\\n  def +=(elem: Elem): this.type\\n  def result(): To\\n  def clear(): Unit\\n  def mapResult[NewTo](f: To => NewTo): Builder[Elem, NewTo] = ...\\n}\\n</code></pre>\\n<p>可以看出上面的<code>result</code>方法就是：我们例子中的<code>finalise</code>，此外多了<code>clear</code>, <code>mapResult</code>两个方法。</p>\\n<p>再看看<code>Buildable</code>的实现：</p>\\n<!-- language:scala -->\\n<pre><code>package scala.collection.generic\\ntrait CanBuildFrom[-From, -Elem, +To] {\\n  // Creates a new builder \\n  def apply(from: From): Builder[Elem, To] \\n}\\n</code></pre>\\n<p>在scala中，换了个名字：<code>CanBuildFrom</code>，感觉会更贴切一些（不过从dual的角度就感觉不那么好了）。</p>\\n<p>上面的<code>apply</code>就是<code>build</code>只是多了一个参数。</p>\\n<p>再来看<code>Iteratable</code>:</p>\\n<!-- language:scala -->\\n<pre><code>package scala.collection\\nclass TraversableLike[+Elem, +Repr] {\\n  def newBuilder: Builder[Elem, Repr] // deferred\\n  def foreach[U](f: Elem => U)        // deferred\\n          ...\\n  def filter(p: Elem => Boolean): Repr = {\\n    val b = newBuilder\\n    foreach { elem => if (p(elem)) b += elem }\\n    b.result\\n  } \\n}\\n</code></pre>\\n<h3>类型参数 vs. 类型成员</h3>\\n<p>在上面的例子中，我们同时使用了类型参数和类型成员。</p>\\n<ul>\\n<li>Buildable的主要目的是构建某种类型的Container，因此使用类型参数将其显式地暴露给客户端。</li>\\n<li>对于Iterable，用户更关心的是其中包含的元素类型，而不是容器(Iterable本身就类似个容器了)，所以我们采用类型成员。</li>\\n</ul>\\n<h2>关于类型(Type)和种类(Kind)</h2>\\n<p>其实中文“类型”在这里很混淆，将英文中的两个词type、kind都翻译为“类型”了，其实是有差别的，我们这里将type翻译为\\\"类型\\\"，kind翻译为\\\"种类\\\"。</p>\\n<p>值、特定类型和种类的关系可以从下图中得到解答。</p>\\n<p><img src=\\\"http://i.stack.imgur.com/K0dwL.jpg\\\" alt=\\\"values, types and kinds的关系图\\\"></p>\\n<ul>\\n<li>特定类型是对某种特定类型的值进行分类，比如Int是对1，2，3，4等值的分类，1，2，3是值，Int是Type(类型)。</li>\\n<li>种类是对特定类型的归类，比如对Int, String, List[Int]等类型，我们进行高阶抽象，可以认为这些特定类型都是相同种类的，可以用<code>*</code>来描述。这里<code>*</code>不是用来描述任意值的，而是<em>任意一个特定类型</em>。</li>\\n<li>种类<code>K</code>可以是<code>*</code> (看下面定义)，也可以是<code>K → K</code>，其中<code>→</code>是<em>种类构造器</em>，用来构造一个<strong>用于归纳类型构造器的种类</strong>，绕口吧，简单地说就是<code>K → K</code>接受一个种类参数，返回一个新的种类.</li>\\n</ul>\\n<h3>Kind的定义</h3>\\n<pre><code>Kind ::= '*(' Type ',' Type ')' | [id '@' ] Kind '→' Kind\\n</code></pre>\\n<p><code>*(T, U)</code>种类中<code>T</code>用来描述类型下边界(lower bound)，<code>U</code>为类型上边界(upper bound)。在Scala中，最低边界是<code>Nothing</code>因为它使一切类型的子类，最高边界是<code>Any</code>，它使所有类型的超类。因为我们经常使用upper bound, 所以，我们用<code>*(Nothing, U)</code>，简化为<code>*(U)</code>来描述一个种类，特别地，<code>*(Nothing, Any)</code>可以简化为<code>*</code>。</p>\\n<p>上文的几个例子：</p>\\n<table>\\n<thead>\\n<tr>\\n<th align=\\\"center\\\">Scala 类型定义</th>\\n<th align=\\\"center\\\">Kind 定义</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td align=\\\"center\\\">Container\\n[\\nX\\n]</td>\\n<td align=\\\"center\\\">*\\n → \\n*</td>\\n</tr>\\n<tr>\\n<td align=\\\"center\\\">Pair\\n[\\nT, U\\n]</td>\\n<td align=\\\"center\\\">*\\n → \\n*\\n → \\n*</td>\\n</tr>\\n<tr>\\n<td align=\\\"center\\\">Container\\n[\\nX\\n]\\n &#x3C;: Iterable\\n[\\nX\\n]</td>\\n<td align=\\\"center\\\">X @ \\n*\\n → \\n*\\n(Iterable\\n[\\nX\\n]\\n)</td>\\n</tr>\\n<tr>\\n<td align=\\\"center\\\">C[X &#x3C;: Ordered\\n[\\nX\\n]\\n] &#x3C;: Iterable\\n[\\nX\\n]</td>\\n<td align=\\\"center\\\">X @ \\n*\\n(Ordered\\n[\\nX\\n]\\n) → \\n*\\n(Iterable\\n[\\nX\\n]\\n)</td>\\n</tr>\\n</tbody>\\n</table>\\n<p>有了Kind定义，我们就可以通过其进行Kind推导，比如<code>T</code>的种类是<code>X @ K → K'</code>，如果<code>U</code>的Kind是<code>K</code>，那么很简单的通过替换，我们就可以知道<code>T[U]</code>的Kind是<code>K'</code>。</p>\\n<h3>子种类Subkinding</h3>\\n<p>scala中，我们通过<code>&#x3C;:</code>或者<code>>:</code>来表述两个类型（type）之间的关系。比如：<code>Int &#x3C;: Number</code>。</p>\\n<p>对于种类，我们可以重载<code>&#x3C;:</code> and <code>>:</code>，用来描述两个种类之间的关系。比如：<code>*(T, U) &#x3C;: *(T', U')</code>，当且仅当：<code>T' &#x3C;: T</code> AND <code>U &#x3C;: U'</code>时上述关系成立。这个相对容易理解，因为<code>T</code>/<code>T'</code>是类型参数，和方法参数一样，是逆变(contravariance)的。</p>\\n<p>scala编译器正是通过应用这些规则来进行type/kind检查的。比如，scala编译器将对下面代码报错：</p>\\n<!-- language:scala run -->\\n<pre><code>class Iterable[Container[X], T]\\ntrait NumericList[T &#x3C;: Number] extends Iterable[NumericList, T]\\n</code></pre>\\n<p>你可以点击<code>run</code>按钮试试，看看编译会出现什么结果。</p>\\n<p>之所以报错，是因为<code>Iterable[NumericList, T]</code>的问题。我们可以应用上面学到的subkinding来分析一下。</p>\\n<p><code>NumericList[T &#x3C;: Number]</code>的种类是：<code>*(Number) → *</code>，很显然，它必须是<code>Iterable</code>的第一个类型参数<code>NumericList</code>的子种类， 也就是：<code>*(Number) → * &#x3C;: * → *</code>。在<code>→</code>左边的是种类参数，是逆变的(contravariant)，所以这里我们需要：<code>* &#x3C;: *(Number)</code>，但是这显然是不成立的。所以scala编译器会报错：<code>type T's bounds &#x3C;: Number are stricter than type X's declared bounds >: Nothing &#x3C;: Any</code>。</p>\\n<p>OK then, how to make it work ? 我们需要引入一个新的类型参数：Bound</p>\\n<!-- language:scala run -->\\n<pre><code>class Iterable[Container[X &#x3C;: Bound], T &#x3C;: Bound, Bound]\\ntrait NumericList[T &#x3C;: Number] extends Iterable[NumericList, T, Number]\\n</code></pre>\\n<p><code>Iterable[Container[X &#x3C;: Bound], T &#x3C;: Bound, Bound]</code>的种类是：<code>*(Bound) → * → *(Bound) → * → *</code></p>\\n<p><code>NumericList[T &#x3C;: Number]</code>的种类是：<code>*(Number) → *</code>，该种类必须是<code>Iterable</code>第一个参数的子种类，也就是：<code>*(Number) → * &#x3C;: *(Bound) → *</code>，而<code>Bound</code>已经指定为<code>Number</code>，经过替换，就有了：<code>*(Number) → * &#x3C;: *(Number) → *</code>，左右两边相同，自然是满足要求了。</p>\\n<h3>高种类型</h3>\\n<p>如果你使用scala 2.11.x版本，在REPL中，就可以通过<code>:type</code>来查看一个类型的种类（Kind）了。比如：</p>\\n<!-- language:scala run -->\\n<pre><code>scala> :kind -v List\\nscala.collection.immutable.List's kind is F[+A]\\n* -(+)-> *\\nThis is a type constructor: a 1st-order-kinded type.\\n\\nscala> :kind -v Pair[_, _]\\nscala.Tuple2's kind is F[+A1,+A2]\\n* -(+)-> * -(+)-> *\\nThis is a type constructor: a 1st-order-kinded type.\\n</code></pre>\\n<p>可以看到，两者的类型一个是：<code>* → *</code> 另外一个是 <code>* → * → *</code>，而且，两个都是：<code>1st-order-kinded type</code>。那怎么才算是一个<code>higher order kinded type</code>呢？</p>\\n<p>在上面的图中:<code>Functor[List]</code>是<code>higher order kinded type</code>: <code>(* → *) → *</code>，这个和<code>Pair[_, _]</code>的<code>* → * → *</code>相比，不就多了个括号吗？玄机就再这个括号上：<code>(* → *) → *</code>表示你接受一个一阶类型* → *，然后产生一个最终的类型。类型的类型，所以是高阶类型。</p>\\n<h2>Implicit机制</h2>\\n<p><code>implicit</code>是scala中一个很强大的东西，其主要出发点是“偷懒”，没错，就是偷懒，让程序员可以偷懒，将本来应该码农干的活交给“编译器”完成。</p>\\n<p>implicit能帮我们码农的有两个地方：隐式参数和隐式转换。</p>\\n<h3>隐式参数</h3>\\n<p>具体来说，就是你可以将一个方法调用的参数（显式注为implicit）省略掉，编译器会在当前上下文中找能用于补充缺失掉参数的值，如果能找到，就自动填充，找不到就会在编译时报错。比如下面例子：</p>\\n<!-- language:scala run -->\\n<pre><code>def foo[T](t: T)(implicit integral: Integral[T]) = { println(integral) }\\nfoo(1)\\n</code></pre>\\n<p>注意<code>foo(1)</code>中只提供了第一个参数，一个<code>Int</code>值，但是第二个参数被省略了，scala编译器就会查找当前scope中有没有类型为<code>Integral[Int]</code>的<code>implicit</code>值。很幸运，scala.math.Numeric中定义了<code>implicit object IntIsIntegral extends IntIsIntegral with Ordering.IntOrdering</code>，所以编译器会找到<code>IntIsIntegral</code>对象然后自动补充第二个参数。</p>\\n<p>那我们再试一下<code>foo(1.0)</code>，这个时候，编译器会报错。为什么呢？查查scala.math.Numeric源码，我们就会发现：scala为Double提供了implicit Fractional对象，make sense，double不是整数嘛。同时scala还是提供了一个对象<code>DoubleAsIfIntegral</code>，但并没有标记为<code>implicit</code>，所以编译器找不到。了解了原因，简单做如下改动：</p>\\n<!-- language:scala run -->\\n<pre><code>def foo[T](t: T)(implicit integral: Integral[T]) = { println(integral) }\\nfoo(1)\\nimplicit val doubleAsIfIntegral = scala.math.Numeric.DoubleAsIfIntegral\\nfoo(1.0)\\n</code></pre>\\n<p>现在大家都happy了。</p>\\n<p>你可以通过<code>implicitly[Integral[Double]]</code>来自行查找是否有符合条件的隐式参数。</p>\\n<h3>隐式转换</h3>\\n<p>implicit的另外一个作用是隐式转换，同样也是帮助码农的。具体讲，就是当你在调用某个方法在某个对象上的时候，如果这个对象的类A并没有定义这个方法，scala的编译器先不会报错，会尝试着在当前scope中查找：</p>\\n<ol>\\n<li>具有该方法定义的类型 B</li>\\n<li>能够将A转换为B的转换器</li>\\n</ol>\\n<p>如果能找到，那么scala将自动进行上述转换，找不到，报错。例如：</p>\\n<!-- language:scala -->\\n<pre><code>\\\"123\\\".map(_.toInt)\\n</code></pre>\\n<p><code>\\\"123\\\"</code>是一个<code>java.lang.String</code>类型，String上并没有定义<code>map</code>方法，但是编译器也没有报错，而且顺利执行了。这就是隐式转换：scala编译器会在上下文中找到<code>implicit def augmentString(x: String): StringOps = new StringOps(x)</code>，可以将<code>String</code>转换为有<code>map</code>定义的<code>StringOps</code>。</p>\\n<p>你可以通过<code>implicitly[String => StringOps]</code>进行自行查找符合条件的转换器。</p>\\n<p>基于隐式参数和隐式转换，在Scala的类型系统中，有两个语法糖：view bound (CC &#x3C;% Seq[T]) 和 context bound (T : Integral)。</p>\\n<h3>View Bounds</h3>\\n<p>说实话不知道这个翻译为什么好，在微博上和几位国内scala大牛们探讨过，一些人认为应该直译为：“视界”，我自己倒是觉得应该叫“化界”？因为：</p>\\n<ol>\\n<li>“视界”，可见到的边界，太笼统，含义模糊，“化界”顾名思义，可“转化到的边界”</li>\\n<li>化界听上去比较炫，像是玄幻小说中很高深的境界，^_^</li>\\n</ol>\\n<p>You can think of <code>T &#x3C;% Ordered[T]</code> as saying, “I can use any T, so long as T can be treated as an Ordered[T].” This is different from saying that T is an Ordered[T], which is what an upper bound, <code>T &#x3C;: Ordered[T]</code>, would say.</p>\\n<p>有时候隐式参数和隐式转换可以同时存在、起作用，比如下面代码：</p>\\n<!-- language:scala run -->\\n<pre><code>def getIndex[T, CC](seq: CC, value: T)(implicit converter: CC => Seq[T]) = seq.indexOf(value)\\n\\ngetIndex(\\\"abcde\\\", 'c')\\ngetIndex(List(1,3,2,5), 3)\\n</code></pre>\\n<p>上面代码中<code>CC</code>可以是任何能转换为<code>Seq</code>的类型，所以<code>String</code>和<code>List</code>都可以应用。</p>\\n<p>首先，<code>converter</code>是一个隐式参数，其次，因为<code>seq</code>对象的类型是<code>CC</code>，其上面并没有定义<code>indexOf</code>方法，所以“隐式转换”介入。</p>\\n<p>事实上，这个用法非常普遍，所以scala专门为其提供了一个语法糖：view bound <code>CC &#x3C;% Seq[T]</code>，重写上面代码：</p>\\n<!-- language:scala run -->\\n<pre><code>def getIndex[T, CC &#x3C;% Seq[T]](seq: CC, value: T) = seq.indexOf(value)\\n</code></pre>\\n<p>运行上面代码，你可以从输出看到scala编译器会将方法重新定义为：<code>getIndex: [T, CC](list: CC, value: T)(implicit evidence$1: CC => Seq[T])Int</code>，和第一种方法一样。</p>\\n<h3>Context Bounds</h3>\\n<p>再看下面一个例子：</p>\\n<!-- language:scala run -->\\n<pre><code>def sum[T](list: List[T])(implicit integral: Integral[T]): T = {\\n    import integral._   // get the implicits in question into scope\\n    list.foldLeft(integral.zero)(_ + _)\\n}\\n</code></pre>\\n<p>这里有一个隐式参数<code>integral</code>类型为<code>Integral[T]</code>，如果方法传入<code>Int</code>，那么scala编译器就会找<code>implicitly[Integral[Int]]</code>，这个我们在隐式参数小节已经说过了。</p>\\n<p>这里主要关注另外一个问题：<code>list.foldLeft(integral.zero)(_ + _)</code>，其中<code>_</code>的类型应该是<code>T</code>，但是<code>T</code>上面有定义<code>+</code>方法吗？我们先把<code>import integral._</code>去掉，就会发现编译出错：</p>\\n<!-- language:scala -->\\n<pre><code>&#x3C;console>:8: error: type mismatch;\\n found   : T\\n required: String\\n           list.foldLeft(integral.zero)(_ + _)\\n                                        ^\\n</code></pre>\\n<p>原来scala编译器尝试着将<code>T</code>转换为<code>String</code>了，这里应该是<code>Predef.any2string</code>起了作用。</p>\\n<p>加上<code>import integral._</code>，一切工作了。</p>\\n<p>回头想一下，其实挺有意思的：我们给一个泛型<code>T</code>动态地添加了<code>+</code>方法，但是并不改变<code>T</code>的代码。而这就是context bound的意义。</p>\\n<p>这个在流行框架<code>Scalaz</code>中应用非常广泛。scala同样为其创建了专门的语法糖：<code>[T : Ordering]</code>。采用语法糖，这个例子可以重写为：</p>\\n<!-- language:scala run -->\\n<pre><code>def sum[T : Integral](list: List[T]): T = {\\n  val integral = implicitly[Integral[T]]\\n  import integral._\\n  list.foldLeft(integral.zero)(_ + _)\\n}\\n</code></pre>\\n<p>编译器编译之后，会生成一个<code>sum: [T](list: List[T])(implicit evidence$1: Integral[T])T</code>的方法。</p>\\n<p>这里有点让人confusing的地方是：<code>T: Integral</code>的写法感觉像是说：<code>T</code>是<code>Integral</code>的类型，就像：<code>m: T</code>，可实际上应该认为是：<code>T</code>在<code>Integral</code>的<code>Context</code>中。</p>\\n<h2>结束语</h2>\\n<p>scala的类型系统确实是一个难点，但同时也是要真正掌握scala语言所必须的知识点。很多概念都很晦涩，对于像我们这些凡人，要想掌握没有太好的办法，只能多看、多练、多想。</p>\\n<h2>参考</h2>\\n<ol>\\n<li><a href=\\\"http://stackoverflow.com/questions/6246719/what-is-a-higher-kinded-type-in-scala\\\">Adriaan Moors. What is a higher kinded type in scala. StackOverflow. http://stackoverflow.com/questions/6246719/what-is-a-higher-kinded-type-in-scala. 2011</a></li>\\n<li><a href=\\\"http://docs.scala-lang.org/overviews/core/architecture-of-scala-collections.html\\\">Martin Odersky and Lex Spoon. Architecture of Scala Collection. scala-lang website. http://docs.scala-lang.org/overviews/core/architecture-of-scala-collections.html. 2013</a></li>\\n<li><a href=\\\"http://stackoverflow.com/questions/5598085/where-does-scala-look-for-implicits\\\">Daniel C. Sobral. Types of Implicits. StackOverflow. http://stackoverflow.com/questions/5598085/where-does-scala-look-for-implicits. 2011</a></li>\\n<li><a href=\\\"http://blogs.atlassian.com/2013/09/scala-types-of-a-higher-kind/\\\">Jed Wesley-Smith. Scala Types Of a Higher Kind. http://blogs.atlassian.com/2013/09/scala-types-of-a-higher-kind/</a></li>\\n</ol>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2014/高种泛型.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2014-01-08T19:16:45.000Z\",\"path\":\"/2014/generics-of-a-higher-kind\",\"title\":\"高种泛型 (Generics of a Higher Kind)\",\"excerpt\":\"Generics of a Higher Kind翻译加自我理解。\",\"tags\":[\"scala\",\"functional programming\",\"Generics\"]}}},{\"node\":{\"html\":\"<p>前文说过了，高阶函数式函数式语言中的基石，而<code>map</code>, <code>flatMap</code>更是重要。</p>\\n<p>对于map，就是一个空间转换的概念，从这个空间映射到另外一个空间：</p>\\n<ul>\\n<li>必须是一一对应的，也就是这个空间的一个点也需要映射到另外一个空间的一个点。</li>\\n</ul>\\n<p>对于flatMap，一种理解是map + flatten，但是我觉得这种理解不好，应为在FP中，flatMap远比map重要。</p>\\n<p>而map、flatMap加上withFilter和foreach实现了scala中最强大的for表达式。</p>\\n<p>其实叫for表达式不准确，英文是有两种称谓：</p>\\n<ul>\\n<li>\\n<p>for comprehension</p>\\n<p>for {\\nx &#x3C;- e1\\ny &#x3C;- e2\\n} yield e</p>\\n<p>comprehension的含义是“理解力”，人如其名，这个表达式也有很强大的理解力。看文本文希望能够对这个方面有所帮助。</p>\\n</li>\\n<li>\\n<p>for loop</p>\\n</li>\\n</ul>\\n<pre><code>for {\\n    i &#x3C;- e1\\n} {\\n    // do something.\\n}\\n</code></pre>\\n<p>本文这里套用Martin在\\\"Reactive Programming\\\"中的例子，对如何应用map, flatMap, for表达式做个简单介绍。</p>\\n<h2>例子</h2>\\n<p>这个例子中，我们需要实现一个随机生成器，能够随机生成：Int, Boolean, Pair, List, Tree</p>\\n<h2>实现</h2>\\n<h3>规约定义</h3>\\n<p>先定义一个Generator类，里面主要的方法就是一个<code>generate</code>，返回一个T</p>\\n<!-- language:lang-scala -->\\n<pre><code>trait Generator[T] { self =>\\n  def generate : T\\n}\\n</code></pre>\\n<h3>随机整数生成器</h3>\\n<p>我们来实现一个随机整数生成器。</p>\\n<!-- language:lang-scala -->\\n<pre><code>val integers = new Generator[Int] {\\n  def generate = {\\n    val r = new java.util.Random\\n    r.nextInt\\n  }\\n}\\n</code></pre>\\n<h3>随机布尔值生成器</h3>\\n<p>再生成一个布尔值随机生成器。</p>\\n<!-- language:lang-scala -->\\n<pre><code>val booleans = new Generator[Boolean] {\\n  def generate = {\\n    val r = new java.util.Random\\n    r.nextInt >= 0\\n  }\\n}\\n</code></pre>\\n<p>现在问题来了，上面的代码有两个问题：</p>\\n<p>1.代码重复\\n<code>val r = new java.util.Random ; r.nextInt</code>出现了两次</p>\\n<p>2.有boilerplate代码，<code>new Generator[Boolean]</code>, <code>def generate</code>等等\\n理想的情况应该是这样的：</p>\\n<!-- language:lang-scala -->\\n<pre><code>val booleans = for (i &#x3C;- integers) yield i > 0\\n</code></pre>\\n<p>但是如果你在REPL中尝试的话，会发现报错：</p>\\n<!-- language:lang-scala -->\\n<pre><code>scala> val boolean = for (i &#x3C;- integers) yield i >= 0\\n&#x3C;console>:9: error: value map is not a member of Generator[Int]\\n       val boolean = for (i &#x3C;- integers) yield i >= 0\\n</code></pre>\\n<p>OK, 因为for表达式就是对<code>map</code>, <code>flatMap</code>的简化，上面的代码会被翻译为：</p>\\n<!-- language:lang-scala -->\\n<pre><code>integers map { i => i > 0 }\\n</code></pre>\\n<p>我们没有在Generator中定义map，所以报错是必然的。修改一下：</p>\\n<!-- language:lang-scala run -->\\n<pre><code>trait Generator[T] { self =>\\n  def generate : T\\n\\n  def map[S](f: T => S): Generator[S] = new Generator[S] {\\n    def generate = f(self.generate)\\n  }\\n}\\nval integers = new Generator[Int] {\\n  def generate = {\\n    val r = new java.util.Random\\n    r.nextInt\\n  }\\n}\\n\\nval booleans = for (i &#x3C;- integers) yield i >= 0\\nbooleans.generate\\n</code></pre>\\n<p>点击<code>run</code>按钮试试，一切顺利！不错。</p>\\n<h3>随机Pair生成器</h3>\\n<p>我们再继续，来点难点的，来个随机<code>(Int, Int)</code>生成器，想一下，很简单，调用两次<code>integers.generate</code>就可以了。</p>\\n<!-- language:lang-scala -->\\n<pre><code>val pairs = new Generator[(Int, Int)] {\\n  def generate = (integers.generate, integers.generate)\\n}\\n</code></pre>\\n<p>同样的，我们不希望有boilerplate代码，每次new一个匿名类，还要重新定义<code>generate</code>，这是java中的无奈之举，对于scala来说，我们希望这么写：</p>\\n<!-- language:lang-scala -->\\n<pre><code>val pairs = for {\\n  x &#x3C;- integers\\n  y &#x3C;- integers\\n} yield (x, y)\\n</code></pre>\\n<p>但是当你试运行一下的时候会出现：</p>\\n<pre><code>scala> val pairs = for (x &#x3C;- integers ; y &#x3C;- integers) yield (x, y)\\n&#x3C;console>:9: error: value flatMap is not a member of Generator[Int]\\n       val pairs = for (x &#x3C;- integers ; y &#x3C;- integers) yield (x, y)\\n</code></pre>\\n<p>编译器抱怨说没有flatMap定义在Generator上，怎么回事？</p>\\n<p>同理，我们需要了解for表达式的翻译机理，上面的代码会背翻译为：</p>\\n<!-- language:lang-scala -->\\n<pre><code>integers flatMap { x => integers map { (x, _) }}\\n</code></pre>\\n<p>我们没有实现flatMap当然会出现这样的错误。好吧，我们来增强一下：</p>\\n<!-- language:lang-scala run -->\\n<pre><code>trait Generator[T] { self =>\\n  def generate : T\\n\\n  def map[S](f: T => S): Generator[S] = new Generator[S] {\\n    def generate = f(self.generate)\\n  }\\n\\n  def flatMap[S](f: T => Generator[S]): Generator[S] = new Generator[S] {\\n    def generate = f(self.generate).generate\\n  }\\n}\\n\\nval integers = new Generator[Int] {\\n  def generate = {\\n    val r = new java.util.Random\\n    r.nextInt\\n  }\\n}\\n\\nval pairs = for {\\n  x &#x3C;- integers\\n  y &#x3C;- integers\\n} yield (x, y)\\n\\npairs.generate\\npairs.generate\\n</code></pre>\\n<p>不错吧，everything just works like a charm. </p>\\n<p>我们还可以定义一些小工具，比如：</p>\\n<!-- language:lang-scala -->\\n<pre><code>def single[T](s: T) = new Generator[T] {\\n  def generate = s\\n}\\n\\ndef choose(from: Int, to: Int) = for { i &#x3C;- integers } yield (from + Math.abs(i) % (to - from))\\n\\ndef oneOf[T](choices: T*) = for ( idx &#x3C;- choose(0, choices.length) ) yield choices(idx)\\n</code></pre>\\n<p>看到OO中策略模式的影子了吗？</p>\\n<h3>List[Int]生成器</h3>\\n<!-- language:lang-scala -->\\n<pre><code>def nonEmptyList = for {\\n  head &#x3C;- integers\\n  tail &#x3C;- lists\\n} yield (head :: tail)\\n\\nval lists: Generator[List[Int]] = for {\\n  isEmpty &#x3C;- oneOf(true, false, false, false, false)\\n  list &#x3C;- if (isEmpty) single(Nil) else nonEmptyList\\n} yield list\\n</code></pre>\\n<h3>Tree生成器</h3>\\n<!-- language:lang-scala -->\\n<pre><code>trait Tree\\ncase class Node(left: Tree, right: Tree) extends Tree\\ncase class Leaf(x: Int) extends Tree\\n\\ndef leafs: Generator[Leaf] = for ( i &#x3C;- integers ) yield Leaf(i)\\n\\n//不是尾递归，很容易StackOverflow\\ndef nodes: Generator[Node] = for {\\n  left &#x3C;- trees\\n  right &#x3C;- trees\\n} yield Node(left, right)\\n\\ndef trees: Generator[Tree] = for {\\n  isLeaf &#x3C;- booleans\\n  tree &#x3C;- if (isLeaf) leafs else nodes\\n} yield tree\\n</code></pre>\\n<p>上面的代码因为用了递归，而且不是尾递归，很容易stackoverflow，一种workaround是增大<code>isLeaf</code>的概率，比如用<code>oneOf(true, true, true, false, false)</code>来替换<code>booleans</code>，这样就有2/3的概率为leaf，退出递归，但是还是很容易出错。下面用指令式的方式来实现以下：</p>\\n<!-- language:lang-scala -->\\n<pre><code>// 先根据深度，生成所有的叶子\\nprivate def leafs(depth: Int): List[Option[Leaf]] = (Math.pow(2, depth - 1).toInt to 1 by -2).toList.foldLeft(List[Option[Leaf]]()) { (acc, ele) =>\\n  val isLuck = booleans.generate\\n  if (isLuck)\\n    Some(Leaf(integers.generate)) :: Some(Leaf(integers.generate)) :: acc\\n  else\\n    None :: None :: acc\\n}\\n//依次聚集\\nprivate def aggregate(children: List[Option[Tree]]): List[Option[Tree]] = {\\n  if (children.length == 1) \\n    children\\n  else {\\n    val length = children.length        \\n    val parents = (length to 1 by -2).toList map { i => (children(i - 1), children(i - 2)) match {\\n        case (Some(l), Some(r)) => Some(Node(l, r))\\n        case (Some(l), None) => Some(Node(l, Leaf(integers.generate)))\\n        case (None, Some(r)) => Some(Node(Leaf(integers.generate), r))\\n        case (None, None) => Some(Leaf(integers.generate))\\n      }\\n    }\\n    aggregate(parents)\\n  }\\n}\\n\\ndef generateTree(depth: Int) = aggregate(leafs(depth))(0).get\\n</code></pre>\\n<p>总的思路是：先根据深度生成可能的叶子，然后两两聚集为上一层的父节点，然后递归直到根节点。</p>\\n<p>这个实现里同样没有用<code>可变量</code>。</p>\\n<h4>Bonus: 打印tree</h4>\\n<p>TBD</p>\\n<h2>关于for表达式</h2>\\n<p>如果你平常用for的场合都是在用一些collection的话，会产生一种错觉，以为for表达式智能应用在collection中，其实for表达式可以应用在任何定义了map/flatMap/withFilter/foreach的类型中，正如你在本文中看到的，那么一个问题是：</p>\\n<!-- language:lang-scala -->\\n<pre><code>val booleans = for ( x &#x3C;- integers ) yield x >= 0\\n</code></pre>\\n<p><code>booleans</code>的类型应该是什么呢？</p>\\n<p>如果你经常用for于collection，你可能会觉得是一个List[Boolean]，其实不是，真正的返回值是：<code>Generator[Boolean]</code>，因为for表达式知道<code>integers</code>的类型是Generator所以其返回值也是Generator，这就是for comprehension的含义是“理解力”，人如其名，这个表达式也有很强大的理解力。看文本文希望能够对这个方面有所帮助。</p>\\n<p>那么是如何实现的呢？其实很简单，将for表达式翻译为map你就知道其中玄机了。</p>\\n<!-- language:lang-scala -->\\n<pre><code>val booleans = for ( x &#x3C;- integers ) yield x >= 0 = integers map { _ >= 0 }\\n</code></pre>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/map-flatMap-for.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-12-01T19:16:45.000Z\",\"path\":\"/2013/map-flatmap-for\",\"title\":\"map/flatMap/for in Action\",\"excerpt\":\"前文说过了，高阶函数式函数式语言中的基石，而`map`, `flatMap`更是重要。\",\"tags\":[\"scala\",\"functional programming\"]}}},{\"node\":{\"html\":\"<p>Eric Meijer说：递归是函数式编程的GOTO，应该尽可能避免。如何避免，OO中我们用while循环，FP中我们用<code>fold</code>。</p>\\n<h2>什么是fold</h2>\\n<p>fold就是折纸，给你一张纸条，你可以将其分为若干等份（一个集合），然后从左向右一点一点卷折起来，折成一个你想要的形状，当然也可以从右向左，还可以对半折。</p>\\n<pre><code>+---+---+---+---+---+---+---+---+---+---+---+---+\\n|   |   |   |   |   |   |   |   |   |   |   |   |\\n| --->  |   |   |   |   |   |   |   |   |   |   |\\n|   |   |   |   |   |   |   |   |   |   |   |   |\\n+---+---+---+---+---+---+---+---+---+---+---+---+\\n</code></pre>\\n<p>这里“你想要的形状”，就是最终<code>fold</code>的输出。</p>\\n<p>风向的例子，北风就是从北面吹来的风。同样的，foldRight就是从右向左折叠，操作对象是seed集合，参数是前面集合的最后一个元素。</p>\\n<h2>foldRight</h2>\\n<!-- language:lang-scala -->\\n<pre><code>List(1,2,3).foldRight(seed)(f) = f(1, f(2, f(3, seed)))\\n</code></pre>\\n<p>记住：等式两边各个因子出现的顺序是相同的，都是1 -> 2 -> 3 -> seed，之所以重要，是因为最后一个<code>f(3, seed)</code>接受的参数是一个tuple: (ele, seed)，而不是(seed, ele)。\\n形象化一点，假设<code>f</code>是<code>cons</code>操作，也就是<code>::</code>:</p>\\n<pre><code>    ::\\n  /   \\\\\\n1       ::\\n       /  \\\\\\n      2     ::\\n           /  \\\\\\n          3    seed \\n</code></pre>\\n<p>例子：求整数集合之和。</p>\\n<!-- language:lang-scala run -->\\n<pre><code>val sum = List(1,2,3).foldRight(0) { (ele, seed) => { println(ele); seed + ele } }\\nprintln(sum)\\n</code></pre>\\n<p>点击<code>run</code>，可以看到，输出的<code>ele</code>顺序是<code>3 -> 2 -> 1</code>.</p>\\n<h2>foldLeft</h2>\\n<!-- language:lang-scala -->\\n<pre><code>List(1,2,3).foldLeft(seed)(g) = g(g(g(seed, 1), 2), 3)\\n</code></pre>\\n<p>这里，前面List中元素的处理顺序还是从左向右的，只是seed跑到了最前面，所以tuple变成了：(seed, ele)。</p>\\n<p>树形结构：</p>\\n<pre><code>            g\\n          /   \\\\\\n        g      3\\n      /   \\\\\\n    g       2\\n  /   \\\\\\nseed   1\\n</code></pre>\\n<p>注意：这里我用的函数换成了<code>g</code>，而不是前面的<code>f</code>，就是想提醒大家，这是两个不同的函数，其参数都是tuple，但是seed的顺序不同。这在编程的时候经常搞混。</p>\\n<p>相同的例子：求一个整数集合的和。</p>\\n<!-- language:lang-scala run -->\\n<pre><code>val sum = List(1,2,3).foldLeft(0) { (seed, ele) => { println(ele); seed + ele } }\\nprintln(sum)\\n</code></pre>\\n<p>点击<code>run</code>，可以看到，输出的<code>ele</code>顺序是<code>1 -> 2 -> 3</code>.</p>\\n<h2>助记</h2>\\n<p>foldLeft/foldRight中block的参数tuple顺序经常搞混，为了方便记忆，我们可以这么来看，我们用seed做基准：</p>\\n<ul>\\n<li>foldRight，从右向左，tuple中seed在右<code>(elem, seed)</code></li>\\n<li>foldLeft, 从左向右，tuple中seed在左<code>(seed, elem)</code></li>\\n</ul>\\n<p>有了fold是卷折纸的概念，我们就比较容易理解unfold.</p>\\n<h2>unfold</h2>\\n<p>与<code>fold</code>对应，<code>unfold</code>就是反过来将一个卷折好的纸分解开，变成若干等份（集合），所以unfold是一个集合的构造过程。</p>\\n<h2>例子</h2>\\n<p>我们这里举一个实际的例子。</p>\\n<!-- language:lang-scala -->\\n<pre><code>def retry(n: Int)(block: => Future[T]): Future[T] = {\\n  if (n &#x3C;= 0) {\\n    Future.failed{ new RuntimeException(\\\"failed even if retried\\\") }\\n  } else {\\n    block fallbackTo {\\n      retry(n - 1)(block)\\n    }\\n  }\\n}\\n</code></pre>\\n<p>这里我们用了递归，但是如Erik Meijer所说，递归是FP的GOTO，不容易理解，容易出错，我们来用fold来替换一下。</p>\\n<p>可是一般来说fold都是需要一个集合的，而这里有什么集合？没有条件，创造条件也要上！我们可以将<code>n</code>也就是次数看成是一个集合，因为逻辑上我们要作几次，每次算一个集合元素，那么这不就是一个集合吗？</p>\\n<p>这个集合就是：<code>val attempts = (1 to n) map { _ => () => block }</code>，有了操作的集合，我们就可以开始玩折纸游戏了。</p>\\n<p>我们最终要“折的形状”是：成功的话返回<code>T</code>，否则返回一个Failure。我们可以将一个缺省的failure作为seed开始。</p>\\n<p>而且我们期望的执行顺序是：<code>block1 recoverWith (block2 recoverWith (block3 recoverWith failure))</code>，很明显，这是一个<code>foldRight</code>。</p>\\n<!-- language:lang-scala -->\\n<pre><code>def retry(n: Int)(block: => Future[T]) = {\\n  val ns = (1 to n).iterator\\n  // 注意：这里的map不关心ns中的系数，所以用'_'，后面需要一个by name参数，所以需要一个() => block，否则将会提前计算，达不到重试效果。\\n  val attempts = ns map { _ => () => block }\\n  val failure = Future.failed{ new RuntimeException(\\\"failed even if retried\\\") }\\n  // 这里seed是一个call by name\\n  attempts.foldRight(() => failure) { (attempt, seed) =>\\n    // seed是call by name，这里也需要是call by name\\n    () => attempt() fallbackTo{ seed() }\\n  }\\n}\\n</code></pre>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/fold编程.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-27T19:16:45.000Z\",\"path\":\"/2013/fold\",\"title\":\"折纸的艺术：fold编程\",\"excerpt\":\"Eric Meijer说：递归是函数式编程的GOTO，应该尽可能避免。如何避免，OO中我们用while循环，FP中我们用`fold`。\",\"tags\":[\"scala\",\"functional programming\",\"fold\"]}}},{\"node\":{\"html\":\"<p>函数式语言与OO（确切地讲是指令式编程）的思维方式是完全不同的，很多OO中的经验在函数式语言中不是很匹配，比如设计模式，那就是一个OO中的特定术语，而在FP中，大家常谈的是对于习惯OO思维的程序员来说玄而又玄的Monad。</p>\\n<p>虽然术语不同，其实要解决的问题是相同的，设计模式也好、Monad也好，都是为了如何更好地处理异常、让代码更加简洁易懂、容易扩展等等。【所以透彻地了解问题本身，比学习一个新的技术更加重要。】</p>\\n<p>本系列文章试图能够将Monad这个及其抽象的东东具体化，将其落地，变为能够理解的例子，看看在具体问题下如何使用Monad来抽象问题，简化代码。</p>\\n<h2>什么是Monad</h2>\\n<h3>定义</h3>\\n<p>一个Monad就是一个实现了flatMap, unit等函数，包含某种数据类型的容器，更加术语化一点是参数化类型<code>M[T]</code>.</p>\\n<!-- language:lang-scala -->\\n<pre><code>trait M[T] {\\n  def flatMap[U](f: T => M[U]) : M[U]\\n  def unit[T](x: T) : M[T]\\n}\\n</code></pre>\\n<p>Monad需要满足三个定理（没错，就是定理，感觉回到了小学、初中的数学课堂）。</p>\\n<ul>\\n<li>\\n<p>组合律</p>\\n<p><code>(x flatMap f) flatMap g == x flatMap (y => f(y) flatMap g)</code></p>\\n<p>有些人可能会问，右边为什么不是 <code>x flatMap (f flatMap g)</code>呢？ 你试一下就知道了，编译器报类型匹配错误，这里<code>x</code>是一个monad，<code>f</code>, <code>g</code>都是函数，所以<code>f flatMap g</code>会类型不匹配。</p>\\n</li>\\n<li>\\n<p>左单一</p>\\n<p><code>unit(x) flatMap f == f(x)</code></p>\\n</li>\\n<li>\\n<p>右单一</p>\\n<p><code>x flatMap unit == x</code></p>\\n</li>\\n</ul>\\n<h3>Monad举例</h3>\\n<p>在Scala中Monad不是新鲜玩意，其实只要你学scala，那你就会天天用，常用的Monad有：</p>\\n<ul>\\n<li>Collection类，比如：List, Set, Map</li>\\n<li>描述可能性的Option  (Some, None)</li>\\n<li>异常处理类 Try, scalaz中的Validation等</li>\\n<li>描述未来的 Future</li>\\n<li>封装状态变化的State</li>\\n<li>封装IO的IO</li>\\n</ul>\\n<h2>Monad解决什么问题</h2>\\n<p>正如上面列举的几个Monad，每种Monad都是为了解决某种具体问题而存在的，正如OO中设计模式一样，只不过Monad的侧重点是：</p>\\n<ul>\\n<li>\\n<p>让你只关注代码主流程，而将异常等分支交给flatMap来处理。</p>\\n</li>\\n<li>\\n<p>每个Monad是一个容器或者一个平行空间，让你可以在该容器（空间）中安全地、方便地操作容器中的数据类型，而不用关心相关问题。比如：在Option空间中，你不用考虑是否有返回值的问题，不需要像指令式编程那样<code>if (rtn == null) ... else ...</code>，再比如Future，让你能够在“未来的时空”中对数据进行操作，不用担心同步的问题，因为你的运算都发生在“未来”空间中。</p>\\n</li>\\n<li>\\n<p>结合for表达式，让你的代码更加简洁、易读。</p>\\n<p><code>for { x &#x3C;- monad; y &#x3C;- f(x); ...}</code></p>\\n<p>而前面讲的定律（主要是结合律和右单一），可以确保monad在for表达式中使用的正确性，比如结合律：</p>\\n</li>\\n</ul>\\n<!-- language:lang-scala -->\\n<pre><code>for {\\n  y &#x3C;- for (x &#x3C;- m; y &#x3C;- f(x)) yield y\\n  z &#x3C;- g(y)\\n} yield z\\n</code></pre>\\n<p>因为满足结合律，就可以简化为：</p>\\n<!-- language:lang-scala -->\\n<pre><code>for {\\n  x &#x3C;- m\\n  y &#x3C;- f(x)\\n  z &#x3C;- g(y)\\n} yield z\\n</code></pre>\\n<p>如果翻译为map/flatMap，前者翻译为：<code>m flatMap f flatMap g</code>，后者翻译为：<code>m flatMap (x => f(x) flatMap g)</code>.</p>\\n<p>而右单一定律可以保证：<code>for {x &#x3C;- m} yield x == m</code>，如果你看过scalaz，你就了解为什么scalaz中需要有专门的test case来测试这些定律了。</p>\\n<p>一般来说我们不太需要关注这些定律的问题，但是如果你需要自己开发一个自己的Monad，那么你就得保证你的Monad符合这些定律，因为这样才能让你的Monad安全地应用在for表达式中。</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Monad.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-26T07:16:45.000Z\",\"path\":\"/2013/monad\",\"title\":\"Monad\",\"excerpt\":\"函数式语言与OO（确切地讲是指令式编程）的思维方式是完全不同的，很多OO中的经验在函数式语言中不是很匹配，比如设计模式，那就是一个OO中的特定术语，而在FP中，大家常谈的是对于习惯OO思维的程序员来说玄而又玄的Monad。\",\"tags\":[\"scala\",\"functional programming\",\"monad\"]}}},{\"node\":{\"html\":\"<p>所谓高阶函数（high order function），其实就是可以接受其他函数作为参数的函数。</p>\\n<p>这里其实还有另外一个概念：<em>头等函数</em>（First Class Function），First Class应该是指头等公民的含义。在Java中的一个方法（函数），只能被调用，相比值Value就像个二等公民，不能像值Value一样，既可以在表达式中被引用，又可以作为参数传入其他方法。</p>\\n<p>头等函数也就是可以将其作为一个值进行传递的函数。看上去很简单，可带来的变化是巨大的。</p>\\n<p>头等函数加上高阶函数，可以极大地简化代码，实现DSL。</p>\\n<h2>简化代码</h2>\\n<h3>Java中的匿名类</h3>\\n<!-- language:lang-java -->\\n<pre><code>import java.util.*\\n\\nTimer timer = new Timer();\\nTimerTask helloTimer = new TimerTask(){\\n    public void run(){\\n        System.out.println(\\\"Hello Timer\\\");\\n    }\\n};\\ntimer.schedule(helloTimer, 1);\\n\\nTimerTask helloWorld = new TimerTask(){\\n    public void run(){\\n        System.out.println(\\\"Hello World\\\");\\n    }\\n};\\ntimer.schedule(helloWorld, 1);\\n</code></pre>\\n<p>然后每次都需要new一个TimerTask匿名类，用起来真心不方便，尤其是当你有多个匿名类要一起使用的时候，那代码看起来简直就像一坨翔，丑陋无比！本来正常的、相同抽象层次的代码应该具有相同的缩进层次，这样阅读起来很易懂、顺畅。但是因为引入匿名类，就得放在不同的缩进层次中，加上不必要的类签名定义，方法定义等boilerplate code, 阅读起来那叫一个费劲！</p>\\n<p>看看scala的方式：</p>\\n<h1>Scala</h1>\\n<!-- language:lang-scala run -->\\n<pre><code>import scala.concurrent._\\nimport scala.concurrent.duration._\\nimport scala.concurrent.ExecutionContext.Implicits.global\\n\\nval timer = new java.util.Timer()\\ndef timeout[A](a: => A, duration: Duration)(implicit ec: ExecutionContext): Future[A] = {\\n    val p = Promise[A]()\\n    timer.schedule(new java.util.TimerTask() {\\n        def run() = {\\n            p.success(a)\\n        }\\n    }, duration.toMillis)\\n    p.future\\n}\\n\\ntimeout(println(\\\"Hello World\\\"), 1 millisecond)\\ntimeout(println(\\\"Hello Timer\\\"), 1 millisecond)\\n</code></pre>\\n<p>定义一个timeout高阶函数，接受一个<code>=> A</code>函数作为参数，然后就可以方便地重复调用了。\\n</p>\\n<h2>自定义控制结构+鸭子类型</h2>\\n<h3>try with resources</h3>\\n<p>在Java中，在处理一些资源相关的数据时，经常需要用一个<code>try .... catch ... finally { res.close(); }</code>的结构，同样地，这种结构使得代码的缩进层次和逻辑抽象层次不同而影响阅读。另外更严重的问题是常常忘记关闭资源。</p>\\n<p>Java中的一种解决方案是用<code>template method</code>模式，比如Spring JdbcTemplate，传入一个匿名类，比如：</p>\\n<!-- language: lang-java -->\\n<pre><code>jdbcTemplate.execute(new StatementCallback(){\\n    public Object doInStatement(Statement stmt) throws SQLException, DataAccessException {\\n        // your real logic here\\n    }\\n}\\n</code></pre>\\n<p>可以看到，真正的逻辑被缩进了两层，有很多boilerplate代码。</p>\\n<p>Java 1.7中引入了try with resources的语法，一定程度上解决了这个问题：</p>\\n<!-- language: lang-java -->\\n<pre><code>try (BufferedReader br = new BufferedReader(new FileReader(path))) {\\n    return br.readLine();\\n}\\n</code></pre>\\n<p>但是要求在try里面的资源必须实现<code>AutoCloseable</code>接口。当然了，Java中很多东西都是围绕接口转。接口就意味着规约，要使用try-with-resources语法，就必须符合这个规约。</p>\\n<p>再看看Scala中如何实现：</p>\\n<!-- language: lang-scala run -->\\n<pre><code>def using[T &#x3C;: { def close() }](resource: T)(block: T => Unit) {\\n  try {\\n    block(resource)\\n  }finally {\\n    if (resource != null) resource.close()\\n  }\\n}\\ncase class Resource {\\n    def close() = println(\\\"I'm closing\\\")\\n    def doSomething() = println(\\\"boring\\\")\\n}\\n\\nval res = Resource()\\n\\nusing[Resource](res){ res =>\\n    res.doSomething()\\n}\\n</code></pre>\\n<p>和<code>try-with-resources</code>的语法比较像吧，不过不同的是，<code>using</code>不要求传入的resource必须实现某种接口，只需要该类型定义了一个<code>def close(): Unit</code>方法。这就是所谓的鸭子类型，只要你走起来像鸭子，那你就是鸭子，不是一个很好的比喻，不过将就吧。</p>\\n<h3>break</h3>\\n<p>当你学习scala的时候，你会发现很多java中的关键字在scala中是不支持的，其中一个就是：<code>break</code>。</p>\\n<p>在一个循环的时候，当满足某个条件就退出当前循环，是一个很普遍的用法，为什么scala中会不是一个关键字呢？我自己感觉是scala强调FP，而break有很浓的指令式编程的味道。</p>\\n<p>那我就是想用break怎么办？不要紧，我们可以自己定义一个自己的break。</p>\\n<!-- language: lang-scala run -->\\n<pre><code>class Breaks {\\n  private class BreakControl extends RuntimeException\\n  private val breakException = new BreakControl\\n\\n  // breakable接受一个() => Unit的函数作为参数，是一个高阶函数。\\n  def breakable(op: => Unit) {\\n    try {\\n      op\\n    } catch {\\n      case ex: BreakControl =>\\n        if (ex ne breakException) throw ex\\n    }\\n  }\\n\\n  def break(): Nothing = { throw breakException }\\n}\\nobject Breaks extends Breaks\\n\\n\\nimport Breaks.{break, breakable}\\n// 通过高阶函数来实现break\\nbreakable {\\n  for (i &#x3C;- (1 to 1000)) {\\n    if (i > 10){\\n      break\\n    } else {\\n      println(i)\\n    }\\n  }\\n}\\n</code></pre>\\n<p>是不是很棒？！scala没有我们可以自己造。这就是高阶函数的用处之一。</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/高阶函数.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-21T19:16:45.000Z\",\"path\":\"/2013/high-order-function\",\"title\":\"高阶函数\",\"excerpt\":\"所谓高阶函数（high order function），其实就是可以接受其他函数作为参数的函数。\",\"tags\":[\"scala\",\"functional programming\",\"high order function\"]}}},{\"node\":{\"html\":\"<h2>上下文</h2>\\n<p>很多时候为了提高性能，减少IO操作，都会将数据load出来之后缓存在内存中。本站的实现过程中也遇到类似的问题，不希望每次有人访问的时候就读取一次md文件，或者从MongoDB中查一次，而是直接在内存中读取。</p>\\n<p>带来因减少IO而提升性能的好处的同时，也出现一个人和“缓存”解决方案都会遇到的问题：数据一致性。</p>\\n<p>简单来说，就是你有同样的一份数据，冗余存放在两个地方，如何确保这两个地方的数据是一致的？再具体一点，可能的问题有：</p>\\n<ul>\\n<li>\\n<p>数据更新的原子性</p>\\n<p>更新数据的时候，同时将两个地方的数据都同步更新，任何一个地方更新失败，则整体更新失败。</p>\\n</li>\\n<li>\\n<p>缓存线程安全的问题</p>\\n<p>如果缓存既可以被读取，又可能被更新，那么就又线程安全问题：多个线程同时操作同一个值的时候怎么协调？</p>\\n</li>\\n</ul>\\n<h2>具体问题</h2>\\n<p>开始的时候，我将所有的文章列表放在一个<code>scala.collection.mutable.ListBuffer</code>中：</p>\\n<!-- language:lang-scala -->\\n<pre><code>object Application extends Controller {\\n  lazy val allPosts: ListBuffer[Post] = ...\\n\\n}\\n</code></pre>\\n<p>因为新发布博客会增加集合内数据，所以这里用ListBuffer比较自然。当然用<code>var</code> + immutable collection也可以。</p>\\n<p>对<code>allPost</code>的操作主要有三个：</p>\\n<ol>\\n<li>\\n<p>在线编写一个博客的时候需要添加到集合中</p>\\n</li>\\n<li>\\n<p>该集合本身是无序的，因为排序的规则可能有多种，展现的时候再排序</p>\\n</li>\\n<li>\\n<p>更新一篇博文的时候同时更新集合中内容。</p>\\n</li>\\n</ol>\\n<p>因为本身Application Object是单例的，多个线程共同运行的场景下就会出现线程安全的问题，类似Servlet中instance级别变量的问题。</p>\\n<h2>解决方案</h2>\\n<p>直观地想，理想的解决方案就是将所有对<code>allPost</code>的写操作都串行起来，这样即使有多个线程同时操作，也没问题了。但是如何将实现串行呢？</p>\\n<p>在指令式编程的世界里，这个问题比较难于解答，一般需要通过加锁来解决。而一般的程序员看到<code>lock</code>, <code>synchronized</code>这些关键字就头疼了，即使经过无数次盲试之后侥幸实现了，也会在产品上线的时候出现这样那样、莫名其妙、让你大呼“这不科学”，“WTF”的惊呼！</p>\\n<p>但是在scala中，我们却不用担心，因为我们有<code>Akka Actor</code>。</p>\\n<p>Actor是另外一种并行计算方式，不同于线程共享内存的并发模型，Actor是基于消息的，强调不同Actor之间不共享数据。有了Actor，问题就迎刃而解了。</p>\\n<p>具体思路是：重建一个单例Actor，由该Actor来维护ListBuffer变量，所有的写操作，全部通过该消息提交任务交给其处理，这样就将并发的多个写请求串行起来了。</p>\\n<p>代码片段：</p>\\n<!-- language:lang-scala -->\\n<pre><code>object PostManager {\\n  // 单例manager actor\\n  lazy val manager = Akka.system.actorOf(Props[PostManager])\\n  case class NewPost(post: Post)\\n  \\n  def saveOrUpdate(unsavedPost: Post) = {\\n    manager ! NewPost(unsavedPost)\\n  }\\n}\\n\\nclass PostManager extends Actor {\\n  import PostManager._\\n  // actor是单例的，所以文章集合也是单例的。\\n  // all posts, but not ordered.\\n  lazy val allPosts: ListBuffer[Post] = Post.allPosts\\n  \\n  def receive = {\\n    case NewPost(newPost) =>\\n      // 先更新数据库，这样如果更新失败，就不会运行之后代码。一定程度上实现原子性。\\n      Post.upsert(newPost)\\n      \\n      val idx = allPosts.indexWhere( _.fileName == newPost.fileName )\\n      \\n      if (idx == -1){\\n        allPosts += newPost\\n      } else {\\n        allPosts.update(idx, newPost)\\n      }\\n  }\\n}\\n</code></pre>\\n<p>全站一个文章集合变量感觉有点\\\"玩具\\\"的感觉，不过这个模型其实是可以扩展的，比如将来如果支持多用户、多博客系统，我们可以每个用户创建一个Actor、维护该用户自己的文章列表。这个Actor模型还是可以重用的。</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Actor协调并发场景下的集合操作.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-17T14:16:45.000Z\",\"path\":\"/2013/actor-collection-collabration\",\"title\":\"边建边学-3：Actor协调并发场景下的集合操作\",\"excerpt\":\"很多时候为了提高性能，减少IO操作，都会将数据load出来之后缓存在内存中。本站的实现过程中也遇到类似的问题，不希望每次有人访问的时候就读取一次md文件，或者从MongoDB中查一次，而是直接在内存中读取。\",\"tags\":[\"scala\",\"functional programming\"]}}}],\"pathPrefix\":\"\",\"first\":false,\"last\":false,\"index\":2,\"pageCount\":3}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/2.json\n// module id = 388\n// module chunks = 157285553617042"],"sourceRoot":""}