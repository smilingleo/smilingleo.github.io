{"version":3,"sources":["webpack:///path---2-4621d14a453ac5d1803c.js","webpack:///./.cache/json/2.json"],"names":["webpackJsonp","341","module","exports","data","allMarkdownRemark","totalCount","edges","node","id","frontmatter","title","date","path","tags","excerpt","pathContext","group","html","pathPrefix","first","last","index","pageCount"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,mBAAqBC,WAAA,GAAAC,QAA0BC,MAAQC,GAAA,iHAAAC,aAAqIC,MAAA,oBAAAC,KAAA,iBAAAC,KAAA,wCAAAC,MAAA,QAAAC,QAAA,gEAA6LP,MAAQC,GAAA,4GAAAC,aAAgIC,MAAA,0BAAAC,KAAA,iBAAAC,KAAA,yBAAAC,MAAA,0BAAAC,QAAA,sBAA4JP,MAAQC,GAAA,mHAAAC,aAAuIC,MAAA,wBAAAC,KAAA,iBAAAC,KAAA,oCAAAC,MAAA,mCAAAC,QAAA,yCAAiMP,MAAQC,GAAA,0GAAAC,aAA8HC,MAAA,gBAAAC,KAAA,iBAAAC,KAAA,WAAAC,MAAA,oBAAAC,QAAA,uIAA+OP,MAAQC,GAAA,2GAAAC,aAA+HC,MAAA,gBAAAC,KAAA,oBAAAC,KAAA,yCAAAC,MAAA,kCAAAC,QAAA,oGAA2PP,MAAQC,GAAA,8GAAAC,aAAkIC,MAAA,uBAAAC,KAAA,kBAAAC,KAAA,8BAAAC,MAAA,gDAAAC,QAAA,kJAAiTP,MAAQC,GAAA,yGAAAC,aAA6HC,MAAA,YAAAC,KAAA,iBAAAC,KAAA,+BAAAC,MAAA,4BAAAC,QAAA,qKAAqSP,MAAQC,GAAA,wHAAAC,aAA4IC,MAAA,2CAAAC,KAAA,iBAAAC,KAAA,oCAAAC,MAAA,kBAAAC,QAAA,mDAA6MP,MAAQC,GAAA,4GAAAC,aAAgIC,MAAA,eAAAC,KAAA,eAAAC,KAAA,yCAAAC,MAAA,uDAAAC,QAAA,+FAAqQP,MAAQC,GAAA,oGAAAC,aAAwHC,MAAA,mCAAAC,KAAA,mBAAAC,KAAA,kCAAAC,MAAA,6CAAAC,QAAA,wCAAqNP,MAAQC,GAAA,+GAAAC,aAAmIC,MAAA,4BAAAC,KAAA,oBAAAC,KAAA,wBAAAC,MAAA,kCAAAC,QAAA,kDAAoMP,MAAQC,GAAA,sGAAAC,aAA0HC,MAAA,eAAAC,KAAA,oBAAAC,KAAA,aAAAC,MAAA,yCAAAC,QAAA,0EAA2MP,MAAQC,GAAA,qGAAAC,aAAyHC,MAAA,QAAAC,KAAA,oBAAAC,KAAA,cAAAC,MAAA,0CAAAC,QAAA,sHAAkPP,MAAQC,GAAA,oGAAAC,aAAwHC,MAAA,OAAAC,KAAA,oBAAAC,KAAA,4BAAAC,MAAA,wDAAAC,QAAA,uDAA8MP,MAAQC,GAAA,iHAAAC,aAAqIC,MAAA,2BAAAC,KAAA,oBAAAC,KAAA,sCAAAC,MAAA,kCAAAC,QAAA,8GAA6QP,MAAQC,GAAA,8HAAAC,aAAkJC,MAAA,qCAAAC,KAAA,oBAAAC,KAAA,uCAAAC,MAAA,gCAAAC,QAAA,+GAAuRP,MAAQC,GAAA,mHAAAC,aAAuIC,MAAA,6BAAAC,KAAA,oBAAAC,KAAA,sCAAAC,MAAA,8BAAAC,QAAA,uCAAoMP,MAAQC,GAAA,gIAAAC,aAAoJC,MAAA,mCAAAC,KAAA,oBAAAC,KAAA,iCAAAC,MAAA,yBAAAC,QAAA,sCAA+LP,MAAQC,GAAA,kHAAAC,aAAsIC,MAAA,uBAAAC,KAAA,oBAAAC,KAAA,+BAAAC,MAAA,mBAAAC,QAAA,oFAAyNP,MAAQC,GAAA,kGAAAC,aAAsHC,MAAA,KAAAC,KAAA,mBAAAC,KAAA,cAAAC,QAAAC,QAAA,aAA4FC,aAAgBC,QAAUT,MAAQU,KAAA,m+OAA29OT,GAAA,+GAAAC,aAAoJE,KAAA,2BAAAC,KAAA,wBAAAF,MAAA,4BAAAI,QAAA,8CAAAD,MAAA,sCAA2MN,MAAQU,KAAA,+pHAAupHT,GAAA,sGAAAC,aAA2IE,KAAA,2BAAAC,KAAA,aAAAF,MAAA,eAAAI,QAAA,sEAAAD,MAAA,6CAAkNN,MAAQU,KAAA,+7EAAqxET,GAAA,qGAAAC,aAA0SE,KAAA,2BAAAC,KAAA,cAAAF,MAAA,QAAAI,QAAA,kHAAAD,MAAA,8CAAyPN,MAAQU,KAAA,0/HAA+8HT,GAAA,oGAAAC,aAAqLE,KAAA,2BAAAC,KAAA,4BAAAF,MAAA,OAAAI,QAAA,mDAAAD,MAAA,4DAAqNN,MAAQU,KAAA,y6EAA+yET,GAAA,iHAAAC,aAAwQE,KAAA,2BAAAC,KAAA,sCAAAF,MAAA,2BAAAI,QAAA,0GAAAD,MAAA,sCAAoRN,MAAQU,KAAA;AAAmwRT,GAAA,8HAAAC,aAAqnBE,KAAA,2BAAAC,KAAA,uCAAAF,MAAA,qCAAAI,QAAA,2GAAAD,MAAA,oCAA8RN,MAAQU,KAAA,wzGAA2mGT,GAAA,mHAAAC,aAAqWE,KAAA,2BAAAC,KAAA,sCAAAF,MAAA,6BAAAI,QAAA,mCAAAD,MAAA,kCAA2MN,MAAQU,KAAA,2tGAAg7FT,GAAA,gIAAAC,aAAwcE,KAAA,2BAAAC,KAAA,iCAAAF,MAAA,mCAAAI,QAAA,kCAAAD,MAAA,6BAAsMN,MAAQU,KAAA,43HAA0qHT,GAAA,kHAAAC,aAAuXE,KAAA,2BAAAC,KAAA,+BAAAF,MAAA,uBAAAI,QAAA,gFAAAD,MAAA,uBAAgON,MAAQU,KAAA,0kCAAAT,GAAA,kGAAAC,aAAusCE,KAAA,2BAAAC,KAAA,cAAAF,MAAA,KAAAI,QAAA,OAAAD,YAAiGK,WAAA,IAAAC,OAAA,EAAAC,MAAA,EAAAC,MAAA,EAAAC,UAAA","file":"path---2-4621d14a453ac5d1803c.js","sourcesContent":["webpackJsonp([157285553617042],{\n\n/***/ 341:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"allMarkdownRemark\":{\"totalCount\":20,\"edges\":[{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/为你的Gatsby博客添加评论功能.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"为你的Gatsby博客添加评论功能\",\"date\":\"March 12, 2018\",\"path\":\"/2018/enable-comments-for-gatsby-blog\",\"tags\":[\"blog\"],\"excerpt\":\"Gatsby打造的博客已经很不错了，但是缺少一个评论功能。本文简单介绍如何集成Disqus评论服务到你的博客站点。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/转用Gatsby搭建博客.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"转用Gatsby打造基于github的博客站点\",\"date\":\"March 08, 2018\",\"path\":\"/2018/blog-with-gatsby\",\"tags\":[\"blog\",\"github\",\"gatsby\"],\"excerpt\":\"如何用Gatsby打造一个博客\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/一则奇怪的Toubleshooting.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"记一次奇怪的troubleshooting\",\"date\":\"March 08, 2018\",\"path\":\"/2018/skipper-sni-domain-fronting\",\"tags\":[\"skipper\",\"SNI\",\"domain fronting\"],\"excerpt\":\"在Skipper转发请求到一个https站点的时候，返回莫名404.\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2016/JSON解析利器JQ.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"JSON解析利器---JQ\",\"date\":\"March 25, 2016\",\"path\":\"/2013/jq\",\"tags\":[\"bash\",\"jq\",\"json\"],\"excerpt\":\"在API first的时代，json作为最常用的格式，充斥着程序猿的屏幕各个角落，掌握一门解析、过滤、转换json输出的工具，已经成为程序猿们安身立命的必要技能。 这里隆重向大家介绍[jq](https://stedolan.github.io/jq/).\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2016/Function的协变.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Function的协、逆变\",\"date\":\"February 04, 2016\",\"path\":\"/2016/function-covariant-contravariant\",\"tags\":[\"scala\",\"functional programming\"],\"excerpt\":\"泛型编程的时候，协变(covariant)还是逆变(contravariant)很重要，在设计上层API接口的时候，正确的使用协变、逆变可以更好地约束程序员的行为，让实现变得安全、一致。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/如何在Scala中实现AOP.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"用Mixin组合实现Scala中的AOP\",\"date\":\"August 13, 2015\",\"path\":\"/2015/aop-by-mixin-in-scala\",\"tags\":[\"scala\",\"functional programming\",\"AOP\",\"mixin\"],\"excerpt\":\"在Java世界，AOP（Aspect Oriented Programming， 面向方面编程)是很多框架的基础。这种将关注点按照“方面”来切分的编程模型极大地简化了编程的复杂度，尤其是在多维度因子交织在一起的时候的各种场景。对于代码的可读性、可维护性、可重用性都是极大的帮助。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Scala雾里看花.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Scala雾里看花\",\"date\":\"April 23, 2015\",\"path\":\"/2015/scala-trouble-shooting\",\"tags\":[\"scala\",\"trouble shooting\"],\"excerpt\":\"Scala的学习过程中，经常会碰到一些莫名其妙的现象，很多时候，这些语言层面的“怪象”都与scala编译器或者scala的类型系统有关。本文不是对编译器和类型系统的介绍，而是重点介绍遇到这些现象的时候，用什么样的方式，拨开云雾见蓝天，通过这些工具获取一些细节帮你了解编译器和类型系统如何工作。工欲善其事，必先利其器。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Docker创建MySQL主从复制以及CDC测试.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"MySQL Master/Slave Replication on Docker\",\"date\":\"April 21, 2015\",\"path\":\"/2015/mysql-replication-on-docker\",\"tags\":[\"docker\",\"mysql\"],\"excerpt\":\"How to setup Mysql master/slave replication.\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2014/Scala函数式异常处理.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Scala函数式异常处理\",\"date\":\"May 04, 2014\",\"path\":\"/2014/scala-error-handling-in-fp-style\",\"tags\":[\"scala\",\"functional programming\",\"exception handling\"],\"excerpt\":\"经常看到很多示例代码，简洁的让人爱不释手，可是真正自己实现的时候，不得不添加各种各样的异常处理逻辑，最后发现代码总量的80%都是再做异常处理，而真正的代码逻辑只有很少的一部分。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2014/高种泛型.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"高种泛型 (Generics of a Higher Kind)\",\"date\":\"January 08, 2014\",\"path\":\"/2014/generics-of-a-higher-kind\",\"tags\":[\"scala\",\"functional programming\",\"Generics\"],\"excerpt\":\"Generics of a Higher Kind翻译加自我理解。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/map-flatMap-for.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"map/flatMap/for in Action\",\"date\":\"December 01, 2013\",\"path\":\"/2013/map-flatmap-for\",\"tags\":[\"scala\",\"functional programming\"],\"excerpt\":\"前文说过了，高阶函数式函数式语言中的基石，而`map`, `flatMap`更是重要。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/fold编程.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"折纸的艺术：fold编程\",\"date\":\"November 27, 2013\",\"path\":\"/2013/fold\",\"tags\":[\"scala\",\"functional programming\",\"fold\"],\"excerpt\":\"Eric Meijer说：递归是函数式编程的GOTO，应该尽可能避免。如何避免，OO中我们用while循环，FP中我们用`fold`。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Monad.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Monad\",\"date\":\"November 26, 2013\",\"path\":\"/2013/monad\",\"tags\":[\"scala\",\"functional programming\",\"monad\"],\"excerpt\":\"函数式语言与OO（确切地讲是指令式编程）的思维方式是完全不同的，很多OO中的经验在函数式语言中不是很匹配，比如设计模式，那就是一个OO中的特定术语，而在FP中，大家常谈的是对于习惯OO思维的程序员来说玄而又玄的Monad。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/高阶函数.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"高阶函数\",\"date\":\"November 21, 2013\",\"path\":\"/2013/high-order-function\",\"tags\":[\"scala\",\"functional programming\",\"high order function\"],\"excerpt\":\"所谓高阶函数（high order function），其实就是可以接受其他函数作为参数的函数。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Actor协调并发场景下的集合操作.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"边建边学-3：Actor协调并发场景下的集合操作\",\"date\":\"November 17, 2013\",\"path\":\"/2013/actor-collection-collabration\",\"tags\":[\"scala\",\"functional programming\"],\"excerpt\":\"很多时候为了提高性能，减少IO操作，都会将数据load出来之后缓存在内存中。本站的实现过程中也遇到类似的问题，不希望每次有人访问的时候就读取一次md文件，或者从MongoDB中查一次，而是直接在内存中读取。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Enumerator-Iteratee-Enumeratee.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Enumerator / Iteratee / Enumeratee\",\"date\":\"November 11, 2013\",\"path\":\"/2013/enumerator-iteratee-enumeratee\",\"tags\":[\"scala\",\"playframework\",\"blog\"],\"excerpt\":\"Stream对于指令式编程已经比较成熟了，有大量的类库，丰富的API。但是对于强调不可变量，尽可能无副作用的FP来说，要考虑语言适配的问题，而目前，流行的解决方案就是：Enumerator/Iteratee。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/集成PlantUML和Markdown.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"边建边学-2：集成PlantUML和Markdown\",\"date\":\"November 07, 2013\",\"path\":\"/2013/markdown-plantuml-integration\",\"tags\":[\"markdown\",\"plantuml\",\"blog\"],\"excerpt\":\"如何用Markdown+PlantUML结合来写图文并茂的博客。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/EssentialAction-in-Playframework.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"EssentialAction in Playframework\",\"date\":\"November 05, 2013\",\"path\":\"/2013/essential-action-in-play\",\"tags\":[\"scala\",\"playframework\"],\"excerpt\":\"Playframework中EssentialAction理解\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/用markdown写博客.markdown absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"边建边学-1: 用Markdown写博文\",\"date\":\"November 01, 2013\",\"path\":\"/2013/blogging-with-markdown\",\"tags\":[\"markdown\",\"blog\"],\"excerpt\":\"本文将是一个系列文章，循序渐进地介绍本站的构建过程，不只是简单的技术介绍，重点是建站过程遇到的问题分析，以及解决的过程，所以起名**“边建边学”**系列。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/开篇.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"开篇\",\"date\":\"October 25, 2013\",\"path\":\"/2013/start\",\"tags\":[],\"excerpt\":\"网络博客\"}}}]}},\"pathContext\":{\"group\":[{\"node\":{\"html\":\"<p>前文说过了，高阶函数式函数式语言中的基石，而<code>map</code>, <code>flatMap</code>更是重要。</p>\\n<p>对于map，就是一个空间转换的概念，从这个空间映射到另外一个空间：</p>\\n<ul>\\n<li>必须是一一对应的，也就是这个空间的一个点也需要映射到另外一个空间的一个点。</li>\\n</ul>\\n<p>对于flatMap，一种理解是map + flatten，但是我觉得这种理解不好，应为在FP中，flatMap远比map重要。</p>\\n<p>而map、flatMap加上withFilter和foreach实现了scala中最强大的for表达式。</p>\\n<p>其实叫for表达式不准确，英文是有两种称谓：</p>\\n<ul>\\n<li>\\n<p>for comprehension</p>\\n<p>for {\\nx &#x3C;- e1\\ny &#x3C;- e2\\n} yield e</p>\\n<p>comprehension的含义是“理解力”，人如其名，这个表达式也有很强大的理解力。看文本文希望能够对这个方面有所帮助。</p>\\n</li>\\n<li>\\n<p>for loop</p>\\n</li>\\n</ul>\\n<pre><code>for {\\n    i &#x3C;- e1\\n} {\\n    // do something.\\n}\\n</code></pre>\\n<p>本文这里套用Martin在\\\"Reactive Programming\\\"中的例子，对如何应用map, flatMap, for表达式做个简单介绍。</p>\\n<h2>例子</h2>\\n<p>这个例子中，我们需要实现一个随机生成器，能够随机生成：Int, Boolean, Pair, List, Tree</p>\\n<h2>实现</h2>\\n<h3>规约定义</h3>\\n<p>先定义一个Generator类，里面主要的方法就是一个<code>generate</code>，返回一个T</p>\\n<!-- language:lang-scala -->\\n<pre><code>trait Generator[T] { self =>\\n  def generate : T\\n}\\n</code></pre>\\n<h3>随机整数生成器</h3>\\n<p>我们来实现一个随机整数生成器。</p>\\n<!-- language:lang-scala -->\\n<pre><code>val integers = new Generator[Int] {\\n  def generate = {\\n    val r = new java.util.Random\\n    r.nextInt\\n  }\\n}\\n</code></pre>\\n<h3>随机布尔值生成器</h3>\\n<p>再生成一个布尔值随机生成器。</p>\\n<!-- language:lang-scala -->\\n<pre><code>val booleans = new Generator[Boolean] {\\n  def generate = {\\n    val r = new java.util.Random\\n    r.nextInt >= 0\\n  }\\n}\\n</code></pre>\\n<p>现在问题来了，上面的代码有两个问题：</p>\\n<p>1.代码重复\\n<code>val r = new java.util.Random ; r.nextInt</code>出现了两次</p>\\n<p>2.有boilerplate代码，<code>new Generator[Boolean]</code>, <code>def generate</code>等等\\n理想的情况应该是这样的：</p>\\n<!-- language:lang-scala -->\\n<pre><code>val booleans = for (i &#x3C;- integers) yield i > 0\\n</code></pre>\\n<p>但是如果你在REPL中尝试的话，会发现报错：</p>\\n<!-- language:lang-scala -->\\n<pre><code>scala> val boolean = for (i &#x3C;- integers) yield i >= 0\\n&#x3C;console>:9: error: value map is not a member of Generator[Int]\\n       val boolean = for (i &#x3C;- integers) yield i >= 0\\n</code></pre>\\n<p>OK, 因为for表达式就是对<code>map</code>, <code>flatMap</code>的简化，上面的代码会被翻译为：</p>\\n<!-- language:lang-scala -->\\n<pre><code>integers map { i => i > 0 }\\n</code></pre>\\n<p>我们没有在Generator中定义map，所以报错是必然的。修改一下：</p>\\n<!-- language:lang-scala run -->\\n<pre><code>trait Generator[T] { self =>\\n  def generate : T\\n\\n  def map[S](f: T => S): Generator[S] = new Generator[S] {\\n    def generate = f(self.generate)\\n  }\\n}\\nval integers = new Generator[Int] {\\n  def generate = {\\n    val r = new java.util.Random\\n    r.nextInt\\n  }\\n}\\n\\nval booleans = for (i &#x3C;- integers) yield i >= 0\\nbooleans.generate\\n</code></pre>\\n<p>点击<code>run</code>按钮试试，一切顺利！不错。</p>\\n<h3>随机Pair生成器</h3>\\n<p>我们再继续，来点难点的，来个随机<code>(Int, Int)</code>生成器，想一下，很简单，调用两次<code>integers.generate</code>就可以了。</p>\\n<!-- language:lang-scala -->\\n<pre><code>val pairs = new Generator[(Int, Int)] {\\n  def generate = (integers.generate, integers.generate)\\n}\\n</code></pre>\\n<p>同样的，我们不希望有boilerplate代码，每次new一个匿名类，还要重新定义<code>generate</code>，这是java中的无奈之举，对于scala来说，我们希望这么写：</p>\\n<!-- language:lang-scala -->\\n<pre><code>val pairs = for {\\n  x &#x3C;- integers\\n  y &#x3C;- integers\\n} yield (x, y)\\n</code></pre>\\n<p>但是当你试运行一下的时候会出现：</p>\\n<pre><code>scala> val pairs = for (x &#x3C;- integers ; y &#x3C;- integers) yield (x, y)\\n&#x3C;console>:9: error: value flatMap is not a member of Generator[Int]\\n       val pairs = for (x &#x3C;- integers ; y &#x3C;- integers) yield (x, y)\\n</code></pre>\\n<p>编译器抱怨说没有flatMap定义在Generator上，怎么回事？</p>\\n<p>同理，我们需要了解for表达式的翻译机理，上面的代码会背翻译为：</p>\\n<!-- language:lang-scala -->\\n<pre><code>integers flatMap { x => integers map { (x, _) }}\\n</code></pre>\\n<p>我们没有实现flatMap当然会出现这样的错误。好吧，我们来增强一下：</p>\\n<!-- language:lang-scala run -->\\n<pre><code>trait Generator[T] { self =>\\n  def generate : T\\n\\n  def map[S](f: T => S): Generator[S] = new Generator[S] {\\n    def generate = f(self.generate)\\n  }\\n\\n  def flatMap[S](f: T => Generator[S]): Generator[S] = new Generator[S] {\\n    def generate = f(self.generate).generate\\n  }\\n}\\n\\nval integers = new Generator[Int] {\\n  def generate = {\\n    val r = new java.util.Random\\n    r.nextInt\\n  }\\n}\\n\\nval pairs = for {\\n  x &#x3C;- integers\\n  y &#x3C;- integers\\n} yield (x, y)\\n\\npairs.generate\\npairs.generate\\n</code></pre>\\n<p>不错吧，everything just works like a charm. </p>\\n<p>我们还可以定义一些小工具，比如：</p>\\n<!-- language:lang-scala -->\\n<pre><code>def single[T](s: T) = new Generator[T] {\\n  def generate = s\\n}\\n\\ndef choose(from: Int, to: Int) = for { i &#x3C;- integers } yield (from + Math.abs(i) % (to - from))\\n\\ndef oneOf[T](choices: T*) = for ( idx &#x3C;- choose(0, choices.length) ) yield choices(idx)\\n</code></pre>\\n<p>看到OO中策略模式的影子了吗？</p>\\n<h3>List[Int]生成器</h3>\\n<!-- language:lang-scala -->\\n<pre><code>def nonEmptyList = for {\\n  head &#x3C;- integers\\n  tail &#x3C;- lists\\n} yield (head :: tail)\\n\\nval lists: Generator[List[Int]] = for {\\n  isEmpty &#x3C;- oneOf(true, false, false, false, false)\\n  list &#x3C;- if (isEmpty) single(Nil) else nonEmptyList\\n} yield list\\n</code></pre>\\n<h3>Tree生成器</h3>\\n<!-- language:lang-scala -->\\n<pre><code>trait Tree\\ncase class Node(left: Tree, right: Tree) extends Tree\\ncase class Leaf(x: Int) extends Tree\\n\\ndef leafs: Generator[Leaf] = for ( i &#x3C;- integers ) yield Leaf(i)\\n\\n//不是尾递归，很容易StackOverflow\\ndef nodes: Generator[Node] = for {\\n  left &#x3C;- trees\\n  right &#x3C;- trees\\n} yield Node(left, right)\\n\\ndef trees: Generator[Tree] = for {\\n  isLeaf &#x3C;- booleans\\n  tree &#x3C;- if (isLeaf) leafs else nodes\\n} yield tree\\n</code></pre>\\n<p>上面的代码因为用了递归，而且不是尾递归，很容易stackoverflow，一种workaround是增大<code>isLeaf</code>的概率，比如用<code>oneOf(true, true, true, false, false)</code>来替换<code>booleans</code>，这样就有2/3的概率为leaf，退出递归，但是还是很容易出错。下面用指令式的方式来实现以下：</p>\\n<!-- language:lang-scala -->\\n<pre><code>// 先根据深度，生成所有的叶子\\nprivate def leafs(depth: Int): List[Option[Leaf]] = (Math.pow(2, depth - 1).toInt to 1 by -2).toList.foldLeft(List[Option[Leaf]]()) { (acc, ele) =>\\n  val isLuck = booleans.generate\\n  if (isLuck)\\n    Some(Leaf(integers.generate)) :: Some(Leaf(integers.generate)) :: acc\\n  else\\n    None :: None :: acc\\n}\\n//依次聚集\\nprivate def aggregate(children: List[Option[Tree]]): List[Option[Tree]] = {\\n  if (children.length == 1) \\n    children\\n  else {\\n    val length = children.length        \\n    val parents = (length to 1 by -2).toList map { i => (children(i - 1), children(i - 2)) match {\\n        case (Some(l), Some(r)) => Some(Node(l, r))\\n        case (Some(l), None) => Some(Node(l, Leaf(integers.generate)))\\n        case (None, Some(r)) => Some(Node(Leaf(integers.generate), r))\\n        case (None, None) => Some(Leaf(integers.generate))\\n      }\\n    }\\n    aggregate(parents)\\n  }\\n}\\n\\ndef generateTree(depth: Int) = aggregate(leafs(depth))(0).get\\n</code></pre>\\n<p>总的思路是：先根据深度生成可能的叶子，然后两两聚集为上一层的父节点，然后递归直到根节点。</p>\\n<p>这个实现里同样没有用<code>可变量</code>。</p>\\n<h4>Bonus: 打印tree</h4>\\n<p>TBD</p>\\n<h2>关于for表达式</h2>\\n<p>如果你平常用for的场合都是在用一些collection的话，会产生一种错觉，以为for表达式智能应用在collection中，其实for表达式可以应用在任何定义了map/flatMap/withFilter/foreach的类型中，正如你在本文中看到的，那么一个问题是：</p>\\n<!-- language:lang-scala -->\\n<pre><code>val booleans = for ( x &#x3C;- integers ) yield x >= 0\\n</code></pre>\\n<p><code>booleans</code>的类型应该是什么呢？</p>\\n<p>如果你经常用for于collection，你可能会觉得是一个List[Boolean]，其实不是，真正的返回值是：<code>Generator[Boolean]</code>，因为for表达式知道<code>integers</code>的类型是Generator所以其返回值也是Generator，这就是for comprehension的含义是“理解力”，人如其名，这个表达式也有很强大的理解力。看文本文希望能够对这个方面有所帮助。</p>\\n<p>那么是如何实现的呢？其实很简单，将for表达式翻译为map你就知道其中玄机了。</p>\\n<!-- language:lang-scala -->\\n<pre><code>val booleans = for ( x &#x3C;- integers ) yield x >= 0 = integers map { _ >= 0 }\\n</code></pre>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/map-flatMap-for.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-12-01T19:16:45.000Z\",\"path\":\"/2013/map-flatmap-for\",\"title\":\"map/flatMap/for in Action\",\"excerpt\":\"前文说过了，高阶函数式函数式语言中的基石，而`map`, `flatMap`更是重要。\",\"tags\":[\"scala\",\"functional programming\"]}}},{\"node\":{\"html\":\"<p>Eric Meijer说：递归是函数式编程的GOTO，应该尽可能避免。如何避免，OO中我们用while循环，FP中我们用<code>fold</code>。</p>\\n<h2>什么是fold</h2>\\n<p>fold就是折纸，给你一张纸条，你可以将其分为若干等份（一个集合），然后从左向右一点一点卷折起来，折成一个你想要的形状，当然也可以从右向左，还可以对半折。</p>\\n<pre><code>+---+---+---+---+---+---+---+---+---+---+---+---+\\n|   |   |   |   |   |   |   |   |   |   |   |   |\\n| --->  |   |   |   |   |   |   |   |   |   |   |\\n|   |   |   |   |   |   |   |   |   |   |   |   |\\n+---+---+---+---+---+---+---+---+---+---+---+---+\\n</code></pre>\\n<p>这里“你想要的形状”，就是最终<code>fold</code>的输出。</p>\\n<p>风向的例子，北风就是从北面吹来的风。同样的，foldRight就是从右向左折叠，操作对象是seed集合，参数是前面集合的最后一个元素。</p>\\n<h2>foldRight</h2>\\n<!-- language:lang-scala -->\\n<pre><code>List(1,2,3).foldRight(seed)(f) = f(1, f(2, f(3, seed)))\\n</code></pre>\\n<p>记住：等式两边各个因子出现的顺序是相同的，都是1 -> 2 -> 3 -> seed，之所以重要，是因为最后一个<code>f(3, seed)</code>接受的参数是一个tuple: (ele, seed)，而不是(seed, ele)。\\n形象化一点，假设<code>f</code>是<code>cons</code>操作，也就是<code>::</code>:</p>\\n<pre><code>    ::\\n  /   \\\\\\n1       ::\\n       /  \\\\\\n      2     ::\\n           /  \\\\\\n          3    seed \\n</code></pre>\\n<p>例子：求整数集合之和。</p>\\n<!-- language:lang-scala run -->\\n<pre><code>val sum = List(1,2,3).foldRight(0) { (ele, seed) => { println(ele); seed + ele } }\\nprintln(sum)\\n</code></pre>\\n<p>点击<code>run</code>，可以看到，输出的<code>ele</code>顺序是<code>3 -> 2 -> 1</code>.</p>\\n<h2>foldLeft</h2>\\n<!-- language:lang-scala -->\\n<pre><code>List(1,2,3).foldLeft(seed)(g) = g(g(g(seed, 1), 2), 3)\\n</code></pre>\\n<p>这里，前面List中元素的处理顺序还是从左向右的，只是seed跑到了最前面，所以tuple变成了：(seed, ele)。</p>\\n<p>树形结构：</p>\\n<pre><code>            g\\n          /   \\\\\\n        g      3\\n      /   \\\\\\n    g       2\\n  /   \\\\\\nseed   1\\n</code></pre>\\n<p>注意：这里我用的函数换成了<code>g</code>，而不是前面的<code>f</code>，就是想提醒大家，这是两个不同的函数，其参数都是tuple，但是seed的顺序不同。这在编程的时候经常搞混。</p>\\n<p>相同的例子：求一个整数集合的和。</p>\\n<!-- language:lang-scala run -->\\n<pre><code>val sum = List(1,2,3).foldLeft(0) { (seed, ele) => { println(ele); seed + ele } }\\nprintln(sum)\\n</code></pre>\\n<p>点击<code>run</code>，可以看到，输出的<code>ele</code>顺序是<code>1 -> 2 -> 3</code>.</p>\\n<h2>助记</h2>\\n<p>foldLeft/foldRight中block的参数tuple顺序经常搞混，为了方便记忆，我们可以这么来看，我们用seed做基准：</p>\\n<ul>\\n<li>foldRight，从右向左，tuple中seed在右<code>(elem, seed)</code></li>\\n<li>foldLeft, 从左向右，tuple中seed在左<code>(seed, elem)</code></li>\\n</ul>\\n<p>有了fold是卷折纸的概念，我们就比较容易理解unfold.</p>\\n<h2>unfold</h2>\\n<p>与<code>fold</code>对应，<code>unfold</code>就是反过来将一个卷折好的纸分解开，变成若干等份（集合），所以unfold是一个集合的构造过程。</p>\\n<h2>例子</h2>\\n<p>我们这里举一个实际的例子。</p>\\n<!-- language:lang-scala -->\\n<pre><code>def retry(n: Int)(block: => Future[T]): Future[T] = {\\n  if (n &#x3C;= 0) {\\n    Future.failed{ new RuntimeException(\\\"failed even if retried\\\") }\\n  } else {\\n    block fallbackTo {\\n      retry(n - 1)(block)\\n    }\\n  }\\n}\\n</code></pre>\\n<p>这里我们用了递归，但是如Erik Meijer所说，递归是FP的GOTO，不容易理解，容易出错，我们来用fold来替换一下。</p>\\n<p>可是一般来说fold都是需要一个集合的，而这里有什么集合？没有条件，创造条件也要上！我们可以将<code>n</code>也就是次数看成是一个集合，因为逻辑上我们要作几次，每次算一个集合元素，那么这不就是一个集合吗？</p>\\n<p>这个集合就是：<code>val attempts = (1 to n) map { _ => () => block }</code>，有了操作的集合，我们就可以开始玩折纸游戏了。</p>\\n<p>我们最终要“折的形状”是：成功的话返回<code>T</code>，否则返回一个Failure。我们可以将一个缺省的failure作为seed开始。</p>\\n<p>而且我们期望的执行顺序是：<code>block1 recoverWith (block2 recoverWith (block3 recoverWith failure))</code>，很明显，这是一个<code>foldRight</code>。</p>\\n<!-- language:lang-scala -->\\n<pre><code>def retry(n: Int)(block: => Future[T]) = {\\n  val ns = (1 to n).iterator\\n  // 注意：这里的map不关心ns中的系数，所以用'_'，后面需要一个by name参数，所以需要一个() => block，否则将会提前计算，达不到重试效果。\\n  val attempts = ns map { _ => () => block }\\n  val failure = Future.failed{ new RuntimeException(\\\"failed even if retried\\\") }\\n  // 这里seed是一个call by name\\n  attempts.foldRight(() => failure) { (attempt, seed) =>\\n    // seed是call by name，这里也需要是call by name\\n    () => attempt() fallbackTo{ seed() }\\n  }\\n}\\n</code></pre>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/fold编程.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-27T19:16:45.000Z\",\"path\":\"/2013/fold\",\"title\":\"折纸的艺术：fold编程\",\"excerpt\":\"Eric Meijer说：递归是函数式编程的GOTO，应该尽可能避免。如何避免，OO中我们用while循环，FP中我们用`fold`。\",\"tags\":[\"scala\",\"functional programming\",\"fold\"]}}},{\"node\":{\"html\":\"<p>函数式语言与OO（确切地讲是指令式编程）的思维方式是完全不同的，很多OO中的经验在函数式语言中不是很匹配，比如设计模式，那就是一个OO中的特定术语，而在FP中，大家常谈的是对于习惯OO思维的程序员来说玄而又玄的Monad。</p>\\n<p>虽然术语不同，其实要解决的问题是相同的，设计模式也好、Monad也好，都是为了如何更好地处理异常、让代码更加简洁易懂、容易扩展等等。【所以透彻地了解问题本身，比学习一个新的技术更加重要。】</p>\\n<p>本系列文章试图能够将Monad这个及其抽象的东东具体化，将其落地，变为能够理解的例子，看看在具体问题下如何使用Monad来抽象问题，简化代码。</p>\\n<h2>什么是Monad</h2>\\n<h3>定义</h3>\\n<p>一个Monad就是一个实现了flatMap, unit等函数，包含某种数据类型的容器，更加术语化一点是参数化类型<code>M[T]</code>.</p>\\n<!-- language:lang-scala -->\\n<pre><code>trait M[T] {\\n  def flatMap[U](f: T => M[U]) : M[U]\\n  def unit[T](x: T) : M[T]\\n}\\n</code></pre>\\n<p>Monad需要满足三个定理（没错，就是定理，感觉回到了小学、初中的数学课堂）。</p>\\n<ul>\\n<li>\\n<p>组合律</p>\\n<p><code>(x flatMap f) flatMap g == x flatMap (y => f(y) flatMap g)</code></p>\\n<p>有些人可能会问，右边为什么不是 <code>x flatMap (f flatMap g)</code>呢？ 你试一下就知道了，编译器报类型匹配错误，这里<code>x</code>是一个monad，<code>f</code>, <code>g</code>都是函数，所以<code>f flatMap g</code>会类型不匹配。</p>\\n</li>\\n<li>\\n<p>左单一</p>\\n<p><code>unit(x) flatMap f == f(x)</code></p>\\n</li>\\n<li>\\n<p>右单一</p>\\n<p><code>x flatMap unit == x</code></p>\\n</li>\\n</ul>\\n<h3>Monad举例</h3>\\n<p>在Scala中Monad不是新鲜玩意，其实只要你学scala，那你就会天天用，常用的Monad有：</p>\\n<ul>\\n<li>Collection类，比如：List, Set, Map</li>\\n<li>描述可能性的Option  (Some, None)</li>\\n<li>异常处理类 Try, scalaz中的Validation等</li>\\n<li>描述未来的 Future</li>\\n<li>封装状态变化的State</li>\\n<li>封装IO的IO</li>\\n</ul>\\n<h2>Monad解决什么问题</h2>\\n<p>正如上面列举的几个Monad，每种Monad都是为了解决某种具体问题而存在的，正如OO中设计模式一样，只不过Monad的侧重点是：</p>\\n<ul>\\n<li>\\n<p>让你只关注代码主流程，而将异常等分支交给flatMap来处理。</p>\\n</li>\\n<li>\\n<p>每个Monad是一个容器或者一个平行空间，让你可以在该容器（空间）中安全地、方便地操作容器中的数据类型，而不用关心相关问题。比如：在Option空间中，你不用考虑是否有返回值的问题，不需要像指令式编程那样<code>if (rtn == null) ... else ...</code>，再比如Future，让你能够在“未来的时空”中对数据进行操作，不用担心同步的问题，因为你的运算都发生在“未来”空间中。</p>\\n</li>\\n<li>\\n<p>结合for表达式，让你的代码更加简洁、易读。</p>\\n<p><code>for { x &#x3C;- monad; y &#x3C;- f(x); ...}</code></p>\\n<p>而前面讲的定律（主要是结合律和右单一），可以确保monad在for表达式中使用的正确性，比如结合律：</p>\\n</li>\\n</ul>\\n<!-- language:lang-scala -->\\n<pre><code>for {\\n  y &#x3C;- for (x &#x3C;- m; y &#x3C;- f(x)) yield y\\n  z &#x3C;- g(y)\\n} yield z\\n</code></pre>\\n<p>因为满足结合律，就可以简化为：</p>\\n<!-- language:lang-scala -->\\n<pre><code>for {\\n  x &#x3C;- m\\n  y &#x3C;- f(x)\\n  z &#x3C;- g(y)\\n} yield z\\n</code></pre>\\n<p>如果翻译为map/flatMap，前者翻译为：<code>m flatMap f flatMap g</code>，后者翻译为：<code>m flatMap (x => f(x) flatMap g)</code>.</p>\\n<p>而右单一定律可以保证：<code>for {x &#x3C;- m} yield x == m</code>，如果你看过scalaz，你就了解为什么scalaz中需要有专门的test case来测试这些定律了。</p>\\n<p>一般来说我们不太需要关注这些定律的问题，但是如果你需要自己开发一个自己的Monad，那么你就得保证你的Monad符合这些定律，因为这样才能让你的Monad安全地应用在for表达式中。</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Monad.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-26T07:16:45.000Z\",\"path\":\"/2013/monad\",\"title\":\"Monad\",\"excerpt\":\"函数式语言与OO（确切地讲是指令式编程）的思维方式是完全不同的，很多OO中的经验在函数式语言中不是很匹配，比如设计模式，那就是一个OO中的特定术语，而在FP中，大家常谈的是对于习惯OO思维的程序员来说玄而又玄的Monad。\",\"tags\":[\"scala\",\"functional programming\",\"monad\"]}}},{\"node\":{\"html\":\"<p>所谓高阶函数（high order function），其实就是可以接受其他函数作为参数的函数。</p>\\n<p>这里其实还有另外一个概念：<em>头等函数</em>（First Class Function），First Class应该是指头等公民的含义。在Java中的一个方法（函数），只能被调用，相比值Value就像个二等公民，不能像值Value一样，既可以在表达式中被引用，又可以作为参数传入其他方法。</p>\\n<p>头等函数也就是可以将其作为一个值进行传递的函数。看上去很简单，可带来的变化是巨大的。</p>\\n<p>头等函数加上高阶函数，可以极大地简化代码，实现DSL。</p>\\n<h2>简化代码</h2>\\n<h3>Java中的匿名类</h3>\\n<!-- language:lang-java -->\\n<pre><code>import java.util.*\\n\\nTimer timer = new Timer();\\nTimerTask helloTimer = new TimerTask(){\\n    public void run(){\\n        System.out.println(\\\"Hello Timer\\\");\\n    }\\n};\\ntimer.schedule(helloTimer, 1);\\n\\nTimerTask helloWorld = new TimerTask(){\\n    public void run(){\\n        System.out.println(\\\"Hello World\\\");\\n    }\\n};\\ntimer.schedule(helloWorld, 1);\\n</code></pre>\\n<p>然后每次都需要new一个TimerTask匿名类，用起来真心不方便，尤其是当你有多个匿名类要一起使用的时候，那代码看起来简直就像一坨翔，丑陋无比！本来正常的、相同抽象层次的代码应该具有相同的缩进层次，这样阅读起来很易懂、顺畅。但是因为引入匿名类，就得放在不同的缩进层次中，加上不必要的类签名定义，方法定义等boilerplate code, 阅读起来那叫一个费劲！</p>\\n<p>看看scala的方式：</p>\\n<h1>Scala</h1>\\n<!-- language:lang-scala run -->\\n<pre><code>import scala.concurrent._\\nimport scala.concurrent.duration._\\nimport scala.concurrent.ExecutionContext.Implicits.global\\n\\nval timer = new java.util.Timer()\\ndef timeout[A](a: => A, duration: Duration)(implicit ec: ExecutionContext): Future[A] = {\\n    val p = Promise[A]()\\n    timer.schedule(new java.util.TimerTask() {\\n        def run() = {\\n            p.success(a)\\n        }\\n    }, duration.toMillis)\\n    p.future\\n}\\n\\ntimeout(println(\\\"Hello World\\\"), 1 millisecond)\\ntimeout(println(\\\"Hello Timer\\\"), 1 millisecond)\\n</code></pre>\\n<p>定义一个timeout高阶函数，接受一个<code>=> A</code>函数作为参数，然后就可以方便地重复调用了。\\n</p>\\n<h2>自定义控制结构+鸭子类型</h2>\\n<h3>try with resources</h3>\\n<p>在Java中，在处理一些资源相关的数据时，经常需要用一个<code>try .... catch ... finally { res.close(); }</code>的结构，同样地，这种结构使得代码的缩进层次和逻辑抽象层次不同而影响阅读。另外更严重的问题是常常忘记关闭资源。</p>\\n<p>Java中的一种解决方案是用<code>template method</code>模式，比如Spring JdbcTemplate，传入一个匿名类，比如：</p>\\n<!-- language: lang-java -->\\n<pre><code>jdbcTemplate.execute(new StatementCallback(){\\n    public Object doInStatement(Statement stmt) throws SQLException, DataAccessException {\\n        // your real logic here\\n    }\\n}\\n</code></pre>\\n<p>可以看到，真正的逻辑被缩进了两层，有很多boilerplate代码。</p>\\n<p>Java 1.7中引入了try with resources的语法，一定程度上解决了这个问题：</p>\\n<!-- language: lang-java -->\\n<pre><code>try (BufferedReader br = new BufferedReader(new FileReader(path))) {\\n    return br.readLine();\\n}\\n</code></pre>\\n<p>但是要求在try里面的资源必须实现<code>AutoCloseable</code>接口。当然了，Java中很多东西都是围绕接口转。接口就意味着规约，要使用try-with-resources语法，就必须符合这个规约。</p>\\n<p>再看看Scala中如何实现：</p>\\n<!-- language: lang-scala run -->\\n<pre><code>def using[T &#x3C;: { def close() }](resource: T)(block: T => Unit) {\\n  try {\\n    block(resource)\\n  }finally {\\n    if (resource != null) resource.close()\\n  }\\n}\\ncase class Resource {\\n    def close() = println(\\\"I'm closing\\\")\\n    def doSomething() = println(\\\"boring\\\")\\n}\\n\\nval res = Resource()\\n\\nusing[Resource](res){ res =>\\n    res.doSomething()\\n}\\n</code></pre>\\n<p>和<code>try-with-resources</code>的语法比较像吧，不过不同的是，<code>using</code>不要求传入的resource必须实现某种接口，只需要该类型定义了一个<code>def close(): Unit</code>方法。这就是所谓的鸭子类型，只要你走起来像鸭子，那你就是鸭子，不是一个很好的比喻，不过将就吧。</p>\\n<h3>break</h3>\\n<p>当你学习scala的时候，你会发现很多java中的关键字在scala中是不支持的，其中一个就是：<code>break</code>。</p>\\n<p>在一个循环的时候，当满足某个条件就退出当前循环，是一个很普遍的用法，为什么scala中会不是一个关键字呢？我自己感觉是scala强调FP，而break有很浓的指令式编程的味道。</p>\\n<p>那我就是想用break怎么办？不要紧，我们可以自己定义一个自己的break。</p>\\n<!-- language: lang-scala run -->\\n<pre><code>class Breaks {\\n  private class BreakControl extends RuntimeException\\n  private val breakException = new BreakControl\\n\\n  // breakable接受一个() => Unit的函数作为参数，是一个高阶函数。\\n  def breakable(op: => Unit) {\\n    try {\\n      op\\n    } catch {\\n      case ex: BreakControl =>\\n        if (ex ne breakException) throw ex\\n    }\\n  }\\n\\n  def break(): Nothing = { throw breakException }\\n}\\nobject Breaks extends Breaks\\n\\n\\nimport Breaks.{break, breakable}\\n// 通过高阶函数来实现break\\nbreakable {\\n  for (i &#x3C;- (1 to 1000)) {\\n    if (i > 10){\\n      break\\n    } else {\\n      println(i)\\n    }\\n  }\\n}\\n</code></pre>\\n<p>是不是很棒？！scala没有我们可以自己造。这就是高阶函数的用处之一。</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/高阶函数.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-21T19:16:45.000Z\",\"path\":\"/2013/high-order-function\",\"title\":\"高阶函数\",\"excerpt\":\"所谓高阶函数（high order function），其实就是可以接受其他函数作为参数的函数。\",\"tags\":[\"scala\",\"functional programming\",\"high order function\"]}}},{\"node\":{\"html\":\"<h2>上下文</h2>\\n<p>很多时候为了提高性能，减少IO操作，都会将数据load出来之后缓存在内存中。本站的实现过程中也遇到类似的问题，不希望每次有人访问的时候就读取一次md文件，或者从MongoDB中查一次，而是直接在内存中读取。</p>\\n<p>带来因减少IO而提升性能的好处的同时，也出现一个人和“缓存”解决方案都会遇到的问题：数据一致性。</p>\\n<p>简单来说，就是你有同样的一份数据，冗余存放在两个地方，如何确保这两个地方的数据是一致的？再具体一点，可能的问题有：</p>\\n<ul>\\n<li>\\n<p>数据更新的原子性</p>\\n<p>更新数据的时候，同时将两个地方的数据都同步更新，任何一个地方更新失败，则整体更新失败。</p>\\n</li>\\n<li>\\n<p>缓存线程安全的问题</p>\\n<p>如果缓存既可以被读取，又可能被更新，那么就又线程安全问题：多个线程同时操作同一个值的时候怎么协调？</p>\\n</li>\\n</ul>\\n<h2>具体问题</h2>\\n<p>开始的时候，我将所有的文章列表放在一个<code>scala.collection.mutable.ListBuffer</code>中：</p>\\n<!-- language:lang-scala -->\\n<pre><code>object Application extends Controller {\\n  lazy val allPosts: ListBuffer[Post] = ...\\n\\n}\\n</code></pre>\\n<p>因为新发布博客会增加集合内数据，所以这里用ListBuffer比较自然。当然用<code>var</code> + immutable collection也可以。</p>\\n<p>对<code>allPost</code>的操作主要有三个：</p>\\n<ol>\\n<li>\\n<p>在线编写一个博客的时候需要添加到集合中</p>\\n</li>\\n<li>\\n<p>该集合本身是无序的，因为排序的规则可能有多种，展现的时候再排序</p>\\n</li>\\n<li>\\n<p>更新一篇博文的时候同时更新集合中内容。</p>\\n</li>\\n</ol>\\n<p>因为本身Application Object是单例的，多个线程共同运行的场景下就会出现线程安全的问题，类似Servlet中instance级别变量的问题。</p>\\n<h2>解决方案</h2>\\n<p>直观地想，理想的解决方案就是将所有对<code>allPost</code>的写操作都串行起来，这样即使有多个线程同时操作，也没问题了。但是如何将实现串行呢？</p>\\n<p>在指令式编程的世界里，这个问题比较难于解答，一般需要通过加锁来解决。而一般的程序员看到<code>lock</code>, <code>synchronized</code>这些关键字就头疼了，即使经过无数次盲试之后侥幸实现了，也会在产品上线的时候出现这样那样、莫名其妙、让你大呼“这不科学”，“WTF”的惊呼！</p>\\n<p>但是在scala中，我们却不用担心，因为我们有<code>Akka Actor</code>。</p>\\n<p>Actor是另外一种并行计算方式，不同于线程共享内存的并发模型，Actor是基于消息的，强调不同Actor之间不共享数据。有了Actor，问题就迎刃而解了。</p>\\n<p>具体思路是：重建一个单例Actor，由该Actor来维护ListBuffer变量，所有的写操作，全部通过该消息提交任务交给其处理，这样就将并发的多个写请求串行起来了。</p>\\n<p>代码片段：</p>\\n<!-- language:lang-scala -->\\n<pre><code>object PostManager {\\n  // 单例manager actor\\n  lazy val manager = Akka.system.actorOf(Props[PostManager])\\n  case class NewPost(post: Post)\\n  \\n  def saveOrUpdate(unsavedPost: Post) = {\\n    manager ! NewPost(unsavedPost)\\n  }\\n}\\n\\nclass PostManager extends Actor {\\n  import PostManager._\\n  // actor是单例的，所以文章集合也是单例的。\\n  // all posts, but not ordered.\\n  lazy val allPosts: ListBuffer[Post] = Post.allPosts\\n  \\n  def receive = {\\n    case NewPost(newPost) =>\\n      // 先更新数据库，这样如果更新失败，就不会运行之后代码。一定程度上实现原子性。\\n      Post.upsert(newPost)\\n      \\n      val idx = allPosts.indexWhere( _.fileName == newPost.fileName )\\n      \\n      if (idx == -1){\\n        allPosts += newPost\\n      } else {\\n        allPosts.update(idx, newPost)\\n      }\\n  }\\n}\\n</code></pre>\\n<p>全站一个文章集合变量感觉有点\\\"玩具\\\"的感觉，不过这个模型其实是可以扩展的，比如将来如果支持多用户、多博客系统，我们可以每个用户创建一个Actor、维护该用户自己的文章列表。这个Actor模型还是可以重用的。</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Actor协调并发场景下的集合操作.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-17T14:16:45.000Z\",\"path\":\"/2013/actor-collection-collabration\",\"title\":\"边建边学-3：Actor协调并发场景下的集合操作\",\"excerpt\":\"很多时候为了提高性能，减少IO操作，都会将数据load出来之后缓存在内存中。本站的实现过程中也遇到类似的问题，不希望每次有人访问的时候就读取一次md文件，或者从MongoDB中查一次，而是直接在内存中读取。\",\"tags\":[\"scala\",\"functional programming\"]}}},{\"node\":{\"html\":\"<h2>Context</h2>\\n<p>插曲：前不久微博上看到一技术“牛人”大V评论Java8的一些特性，引入lambada但没有扩展能力，集合的查询都得靠新stream api而不是Enumerator / Iterator云云。一时手欠回复了下“似乎应该是Enumerator / Iteratee“, 结果引来一身骚，被该大V泼口大骂了一个下午，没错就是像网吧里面无聊的小青年一样无营养地谩骂，实在没搞懂到底是为什么，说我说的Iteratee和他说的没”鸡毛“关系，不懂，也不想搞懂了，还是他玩他的Iterator我介绍我的Iteratee吧。</p>\\n<p>因为我们的内存、磁盘等资源还是有限的，对于一个大的Stream，Collection，我们在处理的时候不应该将其作为整体进行处理，因为这样会带来潜在的风险，比如：内存溢出，降低系统吞吐量等等。</p>\\n<p>正确的方式是将大的不可预见（unpredictable）的stream，Collection进行分解，将其分解为小的，可预见（predictable）的块进行处理。这是流模式的思想，也是Iteratee的设计目标之一。</p>\\n<p>Stream对于指令式编程已经比较成熟了，有大量的类库，丰富的API。但是对于强调不可变量，尽可能无副作用的FP来说，要考虑语言适配的问题，而目前，流行的解决方案就是：Enumerator/Iteratee。</p>\\n<p>另外，就是需要用统一的API来处理所有类型的Stream，就像指令式编程中的<code>InputStream.read</code>, <code>OutputStream.write</code>，无论什么Stream都需要支持这些基本方法。</p>\\n<h2>High Level Concept Model</h2>\\n<p>Enumerator / Iteratee说起来很复杂，其实就是一个生产者 / 消费者模型。 Enumerator是生产者，创建诸多个可控的chunk，Iteratee是消费者，消费任意类型的Input Chunk。</p>\\n<!-- language:lang-scala -->\\n<pre><code>trait Enumerator {\\n  def |>>[A](i: Iteratee[E, A]): Future[Iteratee[E, A]] = apply(i)\\n}\\n</code></pre>\\n<p>Enumerator驱动一个Iteratee，Iteratee处理一个Chunk之后，返回下一个状态的Iteratee. 在构造Enumerator的时候不会真正读取数据，只有在真正消费时才产生IO。</p>\\n<p>而且多个Enumerator之间可以组合，不同类型的消费者（Iteratee）也可以进行组合、变换，简言之，组合的概念就是将每个Enumerator / Iteratee都看成是一个可组合的积木，每个积木相对独立可复用，写代码就是将这些积木组合达成你想要形状的过程。这个说法很常见，OO里提倡“组合优于继承”也是一样的思想，其中的关键是如何找到最小的可复用的component，然后是通过什么样的方式进行灵活地组合。</p>\\n<p>Enumerator / Iteratee / Enumeratee就是一个非常好的例子。</p>\\n<h2>消费者 Iteratee</h2>\\n<!-- language:lang-scala -->\\n<pre><code>class Iteratee &#x3C;&#x3C; (T, #00FF00) >> {\\n  Future[B] fold[B](folder: Step[E, A] => Future[B])\\n}\\nclass ImmediateIteratee &#x3C;&#x3C; (T, #00FF00) >>\\nclass Done &#x3C;&#x3C; (O, #FF0000) >>\\nclass Cont &#x3C;&#x3C; (O, #FF0000) >>\\nclass Error &#x3C;&#x3C; (O, #FF0000) >>\\nclass Step &#x3C;&#x3C; (T, #00FF00) >>\\nclass Input &#x3C;&#x3C; (T, #00FF00) >>\\n\\nIteratee &#x3C;|-- ImmediateIteratee\\nIteratee &#x3C;|-- FutureIteratee\\nIteratee &#x3C;.left.> Step\\nStep .left.> Input\\n\\nImmediateIteratee &#x3C;|-- DoneIteratee\\nDoneIteratee .. Done\\nImmediateIteratee &#x3C;|-- ContIteratee\\nContIteratee .. Cont\\nImmediateIteratee &#x3C;|-- ErrorIteratee\\nErrorIteratee .. Error\\n\\nnote \\\"company objects\\\" as oNote\\nDone .. oNote\\nCont .. oNote\\nError .. oNote\\n</code></pre>\\n<p>Iteratee是一个Input的消费者，注意：这里的Input不是全部输入，而是a chunk of input，这个很重要，没有一个Iteratee来消费所有输入数据，而是每块一个消费者，然后通过函数组合的方式将所有块穿起来。</p>\\n<ul>\\n<li>\\n<p>为什么不是一个完整输入对应一个消费者呢？\\n这是指令式编程的思维方式，因为你需要自己考虑实现细节，设计一些游标，每次读取步进的长度，判断游标的位置来判断下一步如何操作。</p>\\n</li>\\n<li>\\n<p>为什么不是所有的输入chunk共享一个消费者呢？\\n嗯，这个问题我不是很确定，应该是有一部分上面的原因，另外就是副作用的问题，每个Step自己维护自己的状态，可以比较容易地实现“懒加载”，在最后一步（调用<code>run</code>）的时候才真正发生IO，而之前，可以通过函数组合任意对每一步进行transform等操作。</p>\\n</li>\\n</ul>\\n<p>Iteratee还有一个需要注意的地方，fold函数是一个<code>curried function</code>，有一个implicit的参数ExecutionContext，也就是在哪个线程池中执行，这个现象在Play中很普遍。</p>\\n<p>ImmediateIteratee描述了一个已经预先知道其state的Iteratee，而FutureIteratee当然就是未来才能知道其State的Iteratee。[个人感觉这个地方设计有点怪，FutureIteratee似乎应该用Future[Iteratee]更好。] </p>\\n<!-- language:uml -->\\n<pre><code>class Step &#x3C;&#x3C; (T, #00FF00) >> {\\n  Iteratee[E, A] it\\n}\\nclass Iteratee &#x3C;&#x3C; (T, #00FF00) >>\\nclass Input &#x3C;&#x3C; (T, #00FF00) >>\\nStep .left.> Input\\nStep &#x3C;-right-> Iteratee\\nStep &#x3C;|-- Done\\nStep &#x3C;|-- Cont\\nStep &#x3C;|-- Error\\n</code></pre>\\n<p>Step描述的是一个Iteratee的状态，其本身包含一个Iteratee不变量<code>it</code>，而Done、Cont、Error也是简单的<code>case class</code>，所以构造也很简单。</p>\\n<!-- language:uml -->\\n<pre><code>class Input &#x3C;&#x3C; (T, #00FF00) >>\\nInput &#x3C;|-- El\\nInput &#x3C;|-- Empty\\nInput &#x3C;|-- EOF\\n</code></pre>\\n<p>Input[E]描述的是<code>一块</code>输入(a chunk of input，不是全部输入)，构造其实很简单，就是一个简单的case class，可以按照你熟悉的方式来构造。</p>\\n<h2>生产者 Enumerator</h2>\\n<p>先来看看Enumerator的定义：</p>\\n<!-- language:lang-scala -->\\n<pre><code>trait Enumerator[E] {\\n\\n  /**\\n   * Apply this Enumerator to an Iteratee\\n   */\\n  def apply[A](i: Iteratee[E, A]): Future[Iteratee[E, A]]\\n  def |>>[A](i: Iteratee[E, A]): Future[Iteratee[E, A]] = apply(i)\\n  ...\\n\\n}\\n</code></pre>\\n<p>由上面定义可以看到，一个<code>Enumerator</code>接受一个<code>Iteratee[E, A]</code>，并返回一个<code>Future[Iteratee[E, A]]</code>，翻译一下就是：Enumerator驱动一个消费者，消费数据之后产生一个下个状态的消费者。</p>\\n<p>Enumerator提供了大量的工厂方法（在scala中是通过伴生对象来实现），比如，你可以从一个数组创建一个Enumerator:</p>\\n<!-- language:lang-scala -->\\n<pre><code>val enumerateCountries = Enumerator[String] = Enumerator(\\\"China\\\", \\\"America\\\", \\\"Japan\\\", \\\"Russia\\\", \\\"England\\\")\\n</code></pre>\\n<p>可以从一个文件中创建：</p>\\n<!-- language:lang-scala -->\\n<pre><code>val enumerateFile: Enumerator[Array[Byte]] = Enumerator.fromFile(new File(\\\"path/to/some/big/file\\\"))\\n</code></pre>\\n<p>或者从一个Stream中创建：</p>\\n<!-- language:lang-scala -->\\n<pre><code>val enumerateFile: Enumerator[Array[Byte]] = Enumerator.fromStream(new java.io.FileInputStream(new File(\\\"path/to/some/big/file\\\")))    \\n</code></pre>\\n<p>更加通用的方式是从一个<code>e: ()=>Future[Option[E]]</code>函数来创建，因为这个函数声明了：未来可能会产生一个<code>E</code>:</p>\\n<!-- language:lang-scala -->\\n<pre><code>def generateM[E](e: => Future[Option[E]])(implicit ec: ExecutionContext): Enumerator[E] = {\\n    ...\\n}\\n</code></pre>\\n<p>发挥一下你的想象，很多事情都可以看成是Stream，比如时间：</p>\\n<!-- language:lang-scala -->\\n<pre><code>import play.api.libs.concurrent.Promise\\nimport play.api.libs.iteratee._\\nimport scala.concurrent.duration._\\nimport scala.concurrent.ExecutionContext.Implicits.global\\nimport java.util.Date\\n\\n// 截止时间\\nval alertTo = new Date(System.currentTimeMillis + 1000*60)\\n\\n// 一个时间流，截止到alertTo\\nval timeStream = Enumerator.generateM {\\n    Promise.timeout(\\n      if (new Date before alertTo) Some(new Date) else None, \\n      1 seconds)\\n}\\n\\nval printlnSink = Iteratee.foreach[Date](date => println(date))\\n// 每隔一秒钟打印一次，直到alertTo\\ntimeStream |>> printlnSink\\n</code></pre>\\n<p>如果你想再play console里面运行上面的代码，可能会失败，说什么:no application started之类的，这时你需要前面加上：</p>\\n<!-- language:lang-scala -->\\n<pre><code>val app = new play.core.StaticApplication(new java.io.File(\\\".\\\"))\\n</code></pre>\\n<p>创建一个测试用的application，再试一下就OK了。</p>\\n<p>除了这个例子，我觉得也可以将数据库中的游标查询用Enumerator来实现。</p>\\n<p>在Play框架中，还有一个实际的例子是<code>WebSocket</code>，有机会我们再单独介绍。</p>\\n<h2>适配器 Enumeratee</h2>\\n<p>对应OO Design Pattern中的Adaptor模式，<code>Enumeratee</code>就是一个Adaptor，将不同规格的组件适配在一起。比如下面这个例子：</p>\\n<p>我们有一个String类型的Enumerator, <code>Enumerator(\\\"123\\\", \\\"456\\\", \\\"789\\\", \\\"222\\\", \\\"333\\\", \\\"444\\\")</code>，还有一个累加器，<code>Iteratee.fold[Long, Long](0:Long) { (acc, el) => acc + el }</code>，两者的“规格”是不同的，一个是String， 但另外一个是Long，当然我们可以再定义一个新的Iteratee，比如：<code>Iteratee.fold[String, Long](0:Long) { (acc, el) => acc + el.toLong }</code>，但是显然，这里面有重复代码的臭味道。更加合理的方式是做一个适配，用一个适配器来讲两个已经存在的component转接后一起工作。</p>\\n<!-- language:lang-scala run -->\\n<pre><code>import play.api.libs.iteratee._\\nimport scala.concurrent.ExecutionContext.Implicits.global\\n\\nval strings = Enumerator(\\\"123\\\", \\\"456\\\", \\\"789\\\", \\\"222\\\", \\\"333\\\", \\\"444\\\")\\nval sum = Iteratee.fold[Long, Long](0:Long) { (acc, el) => acc + el }\\nval toLong = Enumeratee.map[String]( x => x.toLong )\\n\\nstrings |>> toLong &#x26;>> sum flatMap { x => x.run } onSuccess { case s => println(s) }\\n// Or, transform the Enumerator first.\\nstrings &#x26;> toLong |>> sum flatMap { x => x.run } onSuccess { case s => println(s) }\\n</code></pre>\\n<p>上面例子可以看到，<code>Enumeratee</code>不但可以适配<code>Iteratee</code>，还可以转换<code>Enumerator</code>。</p>\\n<p>留个问题：<code>strings &#x26;> toLong</code>会不会产生memory的问题？ </p>\\n<h2>指令式 VS. 函数式</h2>\\n<p>这里用一个很无聊的例子：遍历一个大文件来统计文件大小。</p>\\n<h3>指令式风格</h3>\\n<p>Use Java FileInputStream, more imperative style:</p>\\n<!-- language:lang-scala -->\\n<pre><code>val fis = new java.io.FileInputStream(new java.io.File(\\\"/Users/leo/Movies/big_file.mkv\\\"))\\n\\n// mutable variables\\nvar readLength = 0\\nvar fileSize: Long = 0\\nvar buf = new Array[Byte](1024 * 8) // chunk size used in Enumerator\\nval begin = System.currentTimeMillis\\ndo {\\n  readLength = fis.read(buf)\\n  if (readLength != -1)\\n    fileSize = fileSize + readLength\\n}while(readLength != -1)\\n\\nprintln(s\\\"File Size: $fileSize, and it took ${System.currentTimeMillis - begin} ms\\\")\\n</code></pre>\\n<p>And output like <code>File Size: 4003885806, and it took 54701 ms</code>, the memory usage is about <code>78Mb</code>.</p>\\n<h3>函数式风格</h3>\\n<p>Use Enumerator / Iteratee to get file size:</p>\\n<!-- language:lang-scala -->\\n<pre><code>import play.api.libs.iteratee._\\n// construct an Enumerator from a file\\nval fileEnum = Enumerator.fromFile(new java.io.File(\\\"/Users/leo/Movies/big_file.mkv\\\")) \\n// create a consumer\\nval counter = Iteratee.fold[Array[Byte], Long](0: Long){ (acc, ele) => ele.size + acc }\\n\\nval begin = System.currentTimeMillis\\n// where the IO really happens.\\nIteratee.flatten(fileEnum |>> counter).run.onSuccess { case x => println(s\\\"File Size: $x, and it took ${System.currentTimeMillis - begin} ms\\\") }\\n</code></pre>\\n<p>Here's the output: <code>File Size: 4003885806, and it took 57213 ms</code>, and max memory usage is about <code>120Mb</code>. </p>\\n<p>Note: If you are running above code with Scala version &#x3C; 2.10.3, you'll run into <code>OutOfMemory</code> Error, it's so funny right? Enumerator / Iteratee suppose to be designed to solve the OutOfMemory issue, actually, it's not Enumerator/Iteratee 's problem, it's a bug of scala, see <a href=\\\"https://issues.scala-lang.org/browse/SI-7336\\\">SI-7336</a></p>\\n<h3>对比</h3>\\n<p>从上面的两种实现来看，从执行时间上，两种方式没有太大差异，但是指令式编程在内存占用方面要优于函数式编程，毕竟var变量可以复用，val变量需要重新生成。但是差别并没有想象中那么大，处理一个4G的文件，差别只是40M左右。但是带来的好处是显而易见的：因为没有mutable变量，没有副作用，并发、代码可读性有提高。</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Enumerator-Iteratee-Enumeratee.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-11T14:16:45.000Z\",\"path\":\"/2013/enumerator-iteratee-enumeratee\",\"title\":\"Enumerator / Iteratee / Enumeratee\",\"excerpt\":\"Stream对于指令式编程已经比较成熟了，有大量的类库，丰富的API。但是对于强调不可变量，尽可能无副作用的FP来说，要考虑语言适配的问题，而目前，流行的解决方案就是：Enumerator/Iteratee。\",\"tags\":[\"scala\",\"playframework\",\"blog\"]}}},{\"node\":{\"html\":\"<p>Markdown是一个很爽的写作格式（或者说语言更合适一点），我们不再需要复杂的富文本编辑器，用纯文本就可以编写出布局漂亮的文章。</p>\\n<p>不过Markdown对于技术类文章来说还有一个不足：我们经常需要画一些图来阐述自己的思路，但是Markdown只能引用已经存在的图。</p>\\n<p>有没有可能用Plain Text来画图呢？AscII艺术图？太原始了。试试PlantUML吧。</p>\\n<h2>PlantUML介绍</h2>\\n<p>从某个角度说，<a href=\\\"http://plantuml.sourceforge.net\\\">PlantUML</a>简直就是Markdown的绝配，也只需要纯文本就可以实现漂亮的效果，只是这里变成更炫的UML图。</p>\\n<p>比如我想画一个类图，Cat和Dog继承Animal，用PlantUML来实现就是：</p>\\n<pre><code>@startuml\\nAnimal &#x3C;|-- Cat\\nAnimal &#x3C;|-- Dog\\n@enduml\\n</code></pre>\\n<p>是不是很简单？来看看效果：</p>\\n<!-- language:uml -->\\n<pre><code>Animal &#x3C;|-- Cat\\nAnimal &#x3C;|-- Dog\\n</code></pre>\\n<p>怎么样？不错吧，这个图片哪里来的？其实在我发布这篇文章的时候，这个类图还不存在，只有在你访问这篇文章的时候才自动生成的。PlantUML有一个jQuery插件，可以在运行时生成图片。</p>\\n<p>PlantUML的jQuery插件用法很简单，你只需要在html中编辑：</p>\\n<!-- language:lang-html -->\\n<pre><code>&#x3C;img uml=\\\"\\n  Animal &#x3C;|-- Cat\\n  Animal &#x3C;|-- Dog\\n\\\">\\n</code></pre>\\n<p>jQuery插件会自动增强这个img元素，具体实现还挺有意思，这里不细说了。</p>\\n<p>可这还不够，怎么在Markdown中写<code>img</code>呢？如果你照抄上面的img代码，pegdown解析器会抛错，'&#x3C;'不匹配云云。</p>\\n<h2>解决方案</h2>\\n<p>基本上这种问题可以从两个方面想办法，一个是服务器端，实现一个markdown parser plugin，来定制一个特殊语法，另一个方向是从浏览器端想办法。</p>\\n<p>从上面的介绍中我们知道，已经有jQuery插件了，那从前端做似乎更加容易一些。此外，从<a href=\\\"http://www.learn-scala.net/blogs/2013-11-01_14.md\\\">上一篇</a>我们已经知道，在<code>pre code</code>前面加上一个<code>&#x3C;!-- language:lang-scala --></code>来实现语法高亮显示问题。</p>\\n<p>PlantUML的内容也可以认为是一种code，很自然地，我们可以用<code>pre code</code>来封装。比如我们可以用：</p>\\n<!-- language:lang-html -->\\n<pre><code>&#x3C;!-- language:uml -->\\n    Animal &#x3C;|-- Cat\\n    Animal &#x3C;|-- Dog\\n</code></pre>\\n<p>这里我们自定义了一种language类型<code>uml</code>，在前端解析的时候，就能知道这个代码块是用来画图的了。</p>\\n<p>好，我们来看前端JS代码的实现：</p>\\n<!-- language:lang-javascript -->\\n<pre><code>function init() {\\n  var plantuml = false;\\n  var blocks = document.querySelectorAll('pre code');\\n  // 遍历所有pre code\\n  for (var i = 0; i &#x3C; blocks.length; i += 1) {\\n    var code = blocks[i];\\n    //code.className += ' prettyprint';\\n    var pre = code.parentNode;\\n    var above = pre;\\n    do {\\n      above = above.previousSibling;\\n    } while (above.nodeType == Node.TEXT_NODE)\\n    // 检查注释元素据\\n    if (above.nodeType == Node.COMMENT_NODE) {\\n      var comment = above.data;\\n      // 正则表达式，获取语言类型\\n      var pattern = /^\\\\s*language:\\\\s*([\\\\w\\\\-]+)\\\\s*(\\\\w+)?\\\\s*$/i;\\n      var match = pattern.exec(comment);\\n      if (match != null) {\\n        var lang = match[1];\\n        // 如果是uml，动态生成一个img元素，并设置uml属性值为pre code的内容。\\n        if (lang &#x26;&#x26; lang == \\\"uml\\\") {\\n          var container = document.createElement(\\\"div\\\");          \\n          var img = document.createElement(\\\"img\\\");\\n          img.setAttribute(\\\"uml\\\", code.innerText || code.textContent);\\n\\n          container.appendChild(img);\\n          container.className = \\\"text-center\\\";\\n\\n          pre.insertAdjacentElement('afterEnd', container);\\n          // 将pre code隐藏起来，只显示图片\\n          pre.style.display = \\\"none\\\";\\n          plantuml = true;\\n        }\\n      }\\n    }\\n  }\\n  // 调用jQuery插件生成图片。\\n  if (plantuml) {\\n    plantuml_runonce();\\n  }\\n}\\n</code></pre>\\n<p>然后，在html中调用：</p>\\n<!-- language:lang-html -->\\n<pre><code>&#x3C;script type='text/javascript'>\\n  window.onload = init;    \\n&#x3C;/script>  \\n</code></pre>\\n<p>搞定，收工！！写作、布局编排、画图全部纯文本，爽！</p>\\n<p>附上一个PlantUML的参考文档，原本上sourceforge网站就可以了，可惜被墙了，点击<a href=\\\"http://www.learn-scala.net/assets/ebooks/PlantUML_Language_Reference_Guide.pdf.zip\\\">这里</a>下载吧。</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/集成PlantUML和Markdown.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-07T19:16:45.000Z\",\"path\":\"/2013/markdown-plantuml-integration\",\"title\":\"边建边学-2：集成PlantUML和Markdown\",\"excerpt\":\"如何用Markdown+PlantUML结合来写图文并茂的博客。\",\"tags\":[\"markdown\",\"plantuml\",\"blog\"]}}},{\"node\":{\"html\":\"<h2>Play!框架的核心</h2>\\n<p>Play!的内核其实非常简单，简单地说，Play框架所实现的可以用一个函数表达式来描述：</p>\\n<p><code>RequestHeader -> Array[Byte] -> Result</code></p>\\n<p>具体讲，就是接受一个<code>RequestHeader</code>，然后读入类型为<code>Array[Byte]</code>的Request Body，计算完毕之后返回一个<code>Result</code>。</p>\\n<p>注：函数式语言的表达就是高度抽象，但异常简洁。</p>\\n<h2>问题及优化</h2>\\n<h3>文件上传</h3>\\n<p>上面的描述有一个问题：我们假定要把请求内容<em>全部</em>读入内存（或者写入磁盘），对于简单应用不是什么问题，但是对于文件上传等场景，这肯定是有问题的，所以，Play开发者做了优化。</p>\\n<p>注：此处可以看出函数式语言的一个优点：仅需要了解你的函数定义，就能分析出潜在的问题。而如果面向对象的方式一般关注在对象之间的通信、方法调用，从方法签名上往往会忽略这些细节。</p>\\n<p>优化的思路当然是将请求内容一部分一部分地读入（chunk），所以这个函数就变成了：</p>\\n<p><code>RequestHeader -> Iteratee[Array[Byte], Result]</code></p>\\n<p><code>Iteratee</code>是个什么东东？简单讲就是一个<code>Monad</code>，什么是Monad？可以类比为OO世界中的设计模式：专门为了解决某类问题的特定方法。Iteratee可以将输入（Input）分步(Step)读入，而且可以进行精细控制遇到EOF、Empty、El(chunk)的时候应该如何处理，是继续（Cont），结束（Done）还是抛错（Error）。这里不做详细介绍。有兴趣的可以参见：<a href=\\\"http://apocalisp.wordpress.com/2010/10/17/scalaz-tutorial-enumeration-based-io-with-iteratees/\\\">这篇博客</a></p>\\n<p>Iteratee本身也是一个<code>Arrow</code>（简单理解为函数），所以如果我们定义一个新类型：</p>\\n<!-- language:lang-scala -->\\n<pre><code>type ==>[E, R] = Iteratee[E, R]\\n</code></pre>\\n<p>上面的函数用scala来写就会变为：</p>\\n<!-- language:lang-scala -->\\n<pre><code>RequestHeader => Array[Byte] ==> Result\\n</code></pre>\\n<p>注：<code>==>[E, R]</code>和<code>E ==> R</code>是等价的，是scala的一个语法糖。</p>\\n<p>上面的表达式看上去更简洁，更有趣了。</p>\\n<h3>文件下载</h3>\\n<p>有了<code>Iteratee</code>我们就可以分块处理请求了，但是响应呢？同样地，如果响应中的数据量很大，比如文件下载，从上面的函数定义看，依旧会把文件完全读入到内存中，同样的问题。</p>\\n<p>解决的思路也是一样的。我们可以将<code>Result</code>看做下面的数据结构：</p>\\n<!-- language:lang-scala -->\\n<pre><code>case class Result(header: ResponseHeader, body: Array[Byte])\\n</code></pre>\\n<p>问题主要在<code>body</code>上，类型是Array[Byte]，需要有一个新的数据类型将起封装，可以分块地处理输出内容，这就是<code>Enumerator</code>，一个用来将响应数据分块(chunk)的东东。</p>\\n<p>所以最终Play框架核心可以看做下面的API：</p>\\n<!-- language:lang-scala -->\\n<pre><code>case class Result[E](headers:ResponseHeaders, body:Enumerator[E])(implicit writeable:Writeable[E])\\ntype ==>[E, R] = Iteratee[E, R]\\nRequestHeader => Array[Byte] ==> Result\\n</code></pre>\\n<p>下面我们来看看Request和Result各自的类图，了解一下都有哪些实现。</p>\\n<!-- language:uml -->\\n<pre><code>title Request Class Hierarchy\\nclass RequestHeader &#x3C;&#x3C; (T, #00FF00)>>\\nclass Request &#x3C;&#x3C; (T, #00FF00)>>\\n\\nRequestHeader &#x3C;|-- Request\\nRequest &#x3C;|-- WrappedRequest\\nRequest &#x3C;|-- FakeRequest\\nWrappedRequest &#x3C;|-- AuthenticatedRequest\\n\\ncenter footer 图一：Request 类图\\n</code></pre>\\n<p>真简单啊，比OO世界里面的一些MVC框架中的类层次结构少多了。</p>\\n<!-- language:uml -->\\n<pre><code>title Result Class Hierarchy\\nclass WithHeaders &#x3C;&#x3C; (T, #00FF00) >>\\nclass Result &#x3C;&#x3C; (T, #00FF00) >>\\n\\nclass PlainResult &#x3C;&#x3C; (T, #FF0000) deprecated>>\\nclass AsyncResult &#x3C;&#x3C; (C, #FF0000) deprecated>>\\nclass ChunkedResult &#x3C;&#x3C; (D, #FF0000) deprecated>>\\n\\nWithHeaders &#x3C;|-- Result\\nResult &#x3C;|-- PlainResult\\nResult &#x3C;|-- AsyncResult\\nPlainResult &#x3C;|-- SimpleResult\\nSimpleResult &#x3C;|-- ChunkedResult\\nSimpleResult &#x3C;|-- Status\\n\\ncenter footer 图二：Result 类图\\n</code></pre>\\n<p>目前Play2.2中Result有两个子类：PlainResult和AsyncResult，但这两个Result已经被标记为deprecated了，从2.3开始，Play将只支持SimpleResult。为什么呢？ 想想其实很简单：单一职责原则。所谓<code>AsyncResult</code>其实本身职责不单一，有异步和Result两个，而直接使用：<code>Future[SimpleResult]</code>则清晰很多。另外ChunkedResult被废弃的原因也一样。</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/EssentialAction-in-Playframework.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-05T09:16:45.000Z\",\"path\":\"/2013/essential-action-in-play\",\"title\":\"EssentialAction in Playframework\",\"excerpt\":\"Playframework中EssentialAction理解\",\"tags\":[\"scala\",\"playframework\"]}}},{\"node\":{\"html\":\"<p>本文将是一个系列文章，循序渐进地介绍本站的构建过程，不只是简单的技术介绍，重点是建站过程遇到的问题分析，以及解决的过程，所以起名<strong>“边建边学”</strong>系列。</p>\\n<p>希望对学习<code>Scala</code>+<code>Playframework</code>的童鞋有所启发。</p>\\n<p>本篇重点介绍如何用markdown来写技术文章，以及如何优化代码片段。</p>\\n<h2>需求</h2>\\n<ul>\\n<li>用markdown来写博客，对不同代码类型能够进行美化</li>\\n<li>技术博客一般会在文中包含部分代码片段，在看文章的时候，如果能运行一下这个代码片段，看看执行结果是什么，会对理解技术有所帮助，所以这里需要一个Web REPL (Read Eval Print Loop)</li>\\n<li>博文列表中只显示博文头</li>\\n</ul>\\n<h2>实现</h2>\\n<h3>markdown</h3>\\n<p>用Markdown写文章的流程是这样的：</p>\\n<ol>\\n<li>\\n<p>在本地创建md文件，用markdown语法写文章</p>\\n<p>markdown语法不是本文的介绍重点，需要温习的童鞋请查看<a href=\\\"http://zh.wikipedia.org/zh-cn/Markdown\\\">维基百科</a>，编辑工具可以考虑使用：<a href=\\\"http://mouapp.com\\\">Mou</a>，或者chrome插件stackedit。</p>\\n</li>\\n<li>\\n<p>将文章发布到网站。</p>\\n<p>发布的最终目的是将文章上传到网站，可以是存到数据库中，可以是上传为一个文件，因为文章的特殊性，创作过程需要跟踪记录，而且md文章本身也是一个文件，所以直接将文件上传搞定。</p>\\n<p>具体上传途径是通过git。其实从版本管理的角度，md文件和其他源代码文件没有什么不同。</p>\\n</li>\\n<li>\\n<p>mardkown解析成为HTML</p>\\n<p>这个解析有两种选择，一个是在服务器端解析，另外一个是在浏览器端通过javascript来解析。个人觉得没有太大不同，这里选择一个github上开源的工具来实现：<a href=\\\"https://github.com/sirthias/pegdown\\\">Pegdown</a>。</p>\\n<p>具体代码非常简单：</p>\\n</li>\\n</ol>\\n<!-- language:lang-scala -->\\n<pre><code>val processor = new PegDownProcessor()\\nval markdownContent = \\\"##title2\\\\n*item1\\\"\\nval htmlContent = processor.markdownToHtml(markdownContent)\\n</code></pre>\\n<ol start=\\\"4\\\">\\n<li>\\n<p>代码美化</p>\\n<p>将MD转换为html之后，代码片段只是被转换为：<code>&#x3C;pre>&#x3C;code> .... &#x3C;/code>&#x3C;/pre></code>，但是如何按照相应语言的语法进行高亮显示呢？其实任何Web效果的东西都没有什么神秘的，只是应用CSS而已。</p>\\n<p>这里我们选用的是<a href=\\\"https://code.google.com/p/google-code-prettify/\\\">prettify.js</a>，当然，还可以选择其他方案，比如<a href=\\\"http://highlightjs.org\\\">highlight.js</a>.</p>\\n<p>具体方案如下：</p>\\n</li>\\n</ol>\\n<!-- language:lang-javascript -->\\n<pre><code>&#x3C;script type='text/javascript'>\\n    function init() {\\n        var prettify = false;\\n        var blocks = document.querySelectorAll('pre code')\\n        for (var i = 0; i &#x3C; blocks.length ; i++) {\\n            blocks[i].className += 'prettyprint';\\n            prettify = true;\\n        }\\n        if (prettify) {\\n          prettyPrint();\\n        }\\n    }\\n    window.onload = init;\\n&#x3C;/script>\\n</code></pre>\\n<p>简单说，就是在页面（dom）加载完成之后，查找所有的pre+code元素，然后给该元素class添加<code>prettyprint</code>，这样有了预定义的样式表，代码语法高亮特性就实现了。\\n<br>\\n代码片段执行的部分将有专门的章节介绍，此处略过。\\n</p>\\n<h3>博文列表只显示文章头</h3>\\n<p>在列表页面，将在一个页面列出大量的内容，如果将每篇文章都完整地列出来，那么页面将变得很长，而且也不方便用户查找，而如果能够只显示文章的开头部分，就可以让读者快速地了解文章大致内容，并且快速浏览近期文章，有选择性地查看文章。</p>\\n<p>这个说起来其实很简单，展示部分内容逻辑上也很简单，只是简单截取文章开头的前N个字符而已。总体上是这个思路，可实际上会比这个稍微复杂一些。原因在于博文不是简单的plain text，而是HTML代码，如果只简单截取前面N个字符，极有可能会造成HTML片段不完整导致页面错误。</p>\\n<p>知道问题所在之后，解决办法其实也就简单了。我们可以简单分析一下markdown转换为html之后的代码结构，比如：</p>\\n<!-- language:lang-html -->\\n<pre><code>&#x3C;h1>手工打造博客站点-1: 用Markdown写博文&#x3C;/h1>\\n&#x3C;p>本文将是一个系列文章，循序渐进地介绍本站的构建过程，不只是简单的技术介绍，重点是建站过程遇到的问题分析，以及解决的过程。&#x3C;/p>\\n&#x3C;p>希望对学习&#x3C;code>Scala&#x3C;/code>+&#x3C;code>Playframework&#x3C;/code>的童鞋有所启发。&#x3C;/p>\\n&#x3C;p>本篇重点介绍如何用markdown来写技术文章，以及如何优化代码片段。&#x3C;/p>\\n&#x3C;h2>需求&#x3C;/h2>\\n……\\n</code></pre>\\n<p>很明显，标题、段落等html元素都是同级的，所以我们只需要一次计算每个html元素所包含内容的长度，当叠加到超过阀值时，将前面元素内容输出就好了。具体的办法是：先将html字符串解析为XML DOM，然后迭代每个一级children节点。</p>\\n<!-- language:lang-scala -->\\n<pre><code>val content = Source.fromFile(file, \\\"UTF-8\\\", 1024).mkString\\nval htmlContent = \\\"&#x3C;article>\\\" + processor.markdownToHtml(content) + \\\"&#x3C;/article>\\\"\\n// only show part of the article\\nval xml = scala.xml.XML.loadString(htmlContent)\\nvar i: Long = 0L\\nval elemList = xml.child.takeWhile( el => { i += el.toString().length; i &#x3C; ConfigUtils.BLOG_HEAD_LENGTH } )\\nval part = \\\"&#x3C;article>\\\" + elemList.mkString + s\\\"\\\"\\\"&#x3C;p>&#x3C;a href=\\\"/blogs/${file.getName}\\\">[...]&#x3C;/a>&#x3C;/p>&#x3C;/article>\\\"\\\"\\\"\\n</code></pre>\\n<p>备注：</p>\\n<ul>\\n<li>在转换为html之后，需要在外面包一个<code>&#x3C;article></code>容器元素。</li>\\n<li>从一个Seq容器元素中截取前面部分元素用<code>takeWhile</code>，此处有一个<code>var</code>可变参数的使用，其实也可以不用，只是用在这里容易一些。</li>\\n<li>在最后添加一个指向文章全文的链接。</li>\\n</ul>\\n<h2>预告</h2>\\n<p>下篇，将介绍如何将网页中的代码片段提交到服务器端执行并返回执行结果，也就是Web GUI REPL，敬请关注。</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/用markdown写博客.markdown absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-01T14:06:45.000Z\",\"path\":\"/2013/blogging-with-markdown\",\"title\":\"边建边学-1: 用Markdown写博文\",\"excerpt\":\"本文将是一个系列文章，循序渐进地介绍本站的构建过程，不只是简单的技术介绍，重点是建站过程遇到的问题分析，以及解决的过程，所以起名**“边建边学”**系列。\",\"tags\":[\"markdown\",\"blog\"]}}},{\"node\":{\"html\":\"<h2>引子</h2>\\n<p>从有了博客这个东西开始，就一直开始找各种好用的博客站点，csdn、新浪、搜狐、博客大巴、点点、google site、Github，甚至自己定制内容管理系统（CMS）Liferay，来建立自己的博客站点。免费的、收费的，都尝试了，可总觉得这里或者那里有点不满意。</p>\\n<p>所以就有一个小心愿能实现一个自己喜欢的站点。</p>\\n<p>这个站点应该可以：</p>\\n<ul>\\n<li>用比较“极客”的方式来写，符合我们这种工科IT男的作风。</li>\\n<li>可以很灵活地定制，想加什么功能就加什么功能。</li>\\n<li>最好有个主题，不是一个记流水账的地方。</li>\\n</ul>\\n<p>近来学习scala这门语言，对于我这个多年在OO世界中打拼的程序员在思维方式上的触动很大，有了找一个地方写一些关于scala学习方面的专题文章。</p>\\n<p>两者一结合，就有了这个网站。</p>\\n<h2>站点简介</h2>\\n<p>这个网站是用下列技术构建的：</p>\\n<ul>\\n<li>Scala</li>\\n<li>Playframework</li>\\n<li>Markdown</li>\\n<li>Websockets</li>\\n<li>Redis</li>\\n<li>MongoDB</li>\\n<li>Twitter Bootstrap</li>\\n</ul>\\n<p>运行在Heroku上，除了域名，一切免费。</p>\\n<h2>博客内容预告</h2>\\n<p>这一系列文章将包括，但不限于：</p>\\n<ul>\\n<li>\\n<p>构建本站技术介绍\\n如何一步一步地搭建一个完整的网站。</p>\\n</li>\\n<li>\\n<p>Scala语言特性</p>\\n</li>\\n<li>\\n<p>一些Scala世界的常用工具，比如Akka、Scalaz的介绍等等。</p>\\n</li>\\n</ul>\\n<p>你可以方便地在网站上直接测试一些小的代码，比如：</p>\\n<!-- language:lang-scala run -->\\n<pre><code>val i = 10\\nprintln(i + 2)\\nval j = 10\\nprintln(j - i)\\n</code></pre>\\n<p>点击<code>Run</code>你就能看到执行结果。</p>\\n<h2>TODO LIST</h2>\\n<ul>\\n<li>简单的搜索</li>\\n<li>分页</li>\\n<li>评论功能</li>\\n</ul>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/开篇.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-10-25T17:06:45.000Z\",\"path\":\"/2013/start\",\"title\":\"开篇\",\"excerpt\":\"网络博客\",\"tags\":[]}}}],\"pathPrefix\":\"/\",\"first\":false,\"last\":true,\"index\":2,\"pageCount\":2}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---2-4621d14a453ac5d1803c.js","module.exports = {\"data\":{\"allMarkdownRemark\":{\"totalCount\":20,\"edges\":[{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/为你的Gatsby博客添加评论功能.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"为你的Gatsby博客添加评论功能\",\"date\":\"March 12, 2018\",\"path\":\"/2018/enable-comments-for-gatsby-blog\",\"tags\":[\"blog\"],\"excerpt\":\"Gatsby打造的博客已经很不错了，但是缺少一个评论功能。本文简单介绍如何集成Disqus评论服务到你的博客站点。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/转用Gatsby搭建博客.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"转用Gatsby打造基于github的博客站点\",\"date\":\"March 08, 2018\",\"path\":\"/2018/blog-with-gatsby\",\"tags\":[\"blog\",\"github\",\"gatsby\"],\"excerpt\":\"如何用Gatsby打造一个博客\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/一则奇怪的Toubleshooting.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"记一次奇怪的troubleshooting\",\"date\":\"March 08, 2018\",\"path\":\"/2018/skipper-sni-domain-fronting\",\"tags\":[\"skipper\",\"SNI\",\"domain fronting\"],\"excerpt\":\"在Skipper转发请求到一个https站点的时候，返回莫名404.\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2016/JSON解析利器JQ.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"JSON解析利器---JQ\",\"date\":\"March 25, 2016\",\"path\":\"/2013/jq\",\"tags\":[\"bash\",\"jq\",\"json\"],\"excerpt\":\"在API first的时代，json作为最常用的格式，充斥着程序猿的屏幕各个角落，掌握一门解析、过滤、转换json输出的工具，已经成为程序猿们安身立命的必要技能。 这里隆重向大家介绍[jq](https://stedolan.github.io/jq/).\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2016/Function的协变.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Function的协、逆变\",\"date\":\"February 04, 2016\",\"path\":\"/2016/function-covariant-contravariant\",\"tags\":[\"scala\",\"functional programming\"],\"excerpt\":\"泛型编程的时候，协变(covariant)还是逆变(contravariant)很重要，在设计上层API接口的时候，正确的使用协变、逆变可以更好地约束程序员的行为，让实现变得安全、一致。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/如何在Scala中实现AOP.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"用Mixin组合实现Scala中的AOP\",\"date\":\"August 13, 2015\",\"path\":\"/2015/aop-by-mixin-in-scala\",\"tags\":[\"scala\",\"functional programming\",\"AOP\",\"mixin\"],\"excerpt\":\"在Java世界，AOP（Aspect Oriented Programming， 面向方面编程)是很多框架的基础。这种将关注点按照“方面”来切分的编程模型极大地简化了编程的复杂度，尤其是在多维度因子交织在一起的时候的各种场景。对于代码的可读性、可维护性、可重用性都是极大的帮助。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Scala雾里看花.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Scala雾里看花\",\"date\":\"April 23, 2015\",\"path\":\"/2015/scala-trouble-shooting\",\"tags\":[\"scala\",\"trouble shooting\"],\"excerpt\":\"Scala的学习过程中，经常会碰到一些莫名其妙的现象，很多时候，这些语言层面的“怪象”都与scala编译器或者scala的类型系统有关。本文不是对编译器和类型系统的介绍，而是重点介绍遇到这些现象的时候，用什么样的方式，拨开云雾见蓝天，通过这些工具获取一些细节帮你了解编译器和类型系统如何工作。工欲善其事，必先利其器。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Docker创建MySQL主从复制以及CDC测试.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"MySQL Master/Slave Replication on Docker\",\"date\":\"April 21, 2015\",\"path\":\"/2015/mysql-replication-on-docker\",\"tags\":[\"docker\",\"mysql\"],\"excerpt\":\"How to setup Mysql master/slave replication.\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2014/Scala函数式异常处理.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Scala函数式异常处理\",\"date\":\"May 04, 2014\",\"path\":\"/2014/scala-error-handling-in-fp-style\",\"tags\":[\"scala\",\"functional programming\",\"exception handling\"],\"excerpt\":\"经常看到很多示例代码，简洁的让人爱不释手，可是真正自己实现的时候，不得不添加各种各样的异常处理逻辑，最后发现代码总量的80%都是再做异常处理，而真正的代码逻辑只有很少的一部分。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2014/高种泛型.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"高种泛型 (Generics of a Higher Kind)\",\"date\":\"January 08, 2014\",\"path\":\"/2014/generics-of-a-higher-kind\",\"tags\":[\"scala\",\"functional programming\",\"Generics\"],\"excerpt\":\"Generics of a Higher Kind翻译加自我理解。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/map-flatMap-for.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"map/flatMap/for in Action\",\"date\":\"December 01, 2013\",\"path\":\"/2013/map-flatmap-for\",\"tags\":[\"scala\",\"functional programming\"],\"excerpt\":\"前文说过了，高阶函数式函数式语言中的基石，而`map`, `flatMap`更是重要。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/fold编程.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"折纸的艺术：fold编程\",\"date\":\"November 27, 2013\",\"path\":\"/2013/fold\",\"tags\":[\"scala\",\"functional programming\",\"fold\"],\"excerpt\":\"Eric Meijer说：递归是函数式编程的GOTO，应该尽可能避免。如何避免，OO中我们用while循环，FP中我们用`fold`。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Monad.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Monad\",\"date\":\"November 26, 2013\",\"path\":\"/2013/monad\",\"tags\":[\"scala\",\"functional programming\",\"monad\"],\"excerpt\":\"函数式语言与OO（确切地讲是指令式编程）的思维方式是完全不同的，很多OO中的经验在函数式语言中不是很匹配，比如设计模式，那就是一个OO中的特定术语，而在FP中，大家常谈的是对于习惯OO思维的程序员来说玄而又玄的Monad。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/高阶函数.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"高阶函数\",\"date\":\"November 21, 2013\",\"path\":\"/2013/high-order-function\",\"tags\":[\"scala\",\"functional programming\",\"high order function\"],\"excerpt\":\"所谓高阶函数（high order function），其实就是可以接受其他函数作为参数的函数。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Actor协调并发场景下的集合操作.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"边建边学-3：Actor协调并发场景下的集合操作\",\"date\":\"November 17, 2013\",\"path\":\"/2013/actor-collection-collabration\",\"tags\":[\"scala\",\"functional programming\"],\"excerpt\":\"很多时候为了提高性能，减少IO操作，都会将数据load出来之后缓存在内存中。本站的实现过程中也遇到类似的问题，不希望每次有人访问的时候就读取一次md文件，或者从MongoDB中查一次，而是直接在内存中读取。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Enumerator-Iteratee-Enumeratee.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Enumerator / Iteratee / Enumeratee\",\"date\":\"November 11, 2013\",\"path\":\"/2013/enumerator-iteratee-enumeratee\",\"tags\":[\"scala\",\"playframework\",\"blog\"],\"excerpt\":\"Stream对于指令式编程已经比较成熟了，有大量的类库，丰富的API。但是对于强调不可变量，尽可能无副作用的FP来说，要考虑语言适配的问题，而目前，流行的解决方案就是：Enumerator/Iteratee。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/集成PlantUML和Markdown.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"边建边学-2：集成PlantUML和Markdown\",\"date\":\"November 07, 2013\",\"path\":\"/2013/markdown-plantuml-integration\",\"tags\":[\"markdown\",\"plantuml\",\"blog\"],\"excerpt\":\"如何用Markdown+PlantUML结合来写图文并茂的博客。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/EssentialAction-in-Playframework.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"EssentialAction in Playframework\",\"date\":\"November 05, 2013\",\"path\":\"/2013/essential-action-in-play\",\"tags\":[\"scala\",\"playframework\"],\"excerpt\":\"Playframework中EssentialAction理解\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/用markdown写博客.markdown absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"边建边学-1: 用Markdown写博文\",\"date\":\"November 01, 2013\",\"path\":\"/2013/blogging-with-markdown\",\"tags\":[\"markdown\",\"blog\"],\"excerpt\":\"本文将是一个系列文章，循序渐进地介绍本站的构建过程，不只是简单的技术介绍，重点是建站过程遇到的问题分析，以及解决的过程，所以起名**“边建边学”**系列。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/开篇.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"开篇\",\"date\":\"October 25, 2013\",\"path\":\"/2013/start\",\"tags\":[],\"excerpt\":\"网络博客\"}}}]}},\"pathContext\":{\"group\":[{\"node\":{\"html\":\"<p>前文说过了，高阶函数式函数式语言中的基石，而<code>map</code>, <code>flatMap</code>更是重要。</p>\\n<p>对于map，就是一个空间转换的概念，从这个空间映射到另外一个空间：</p>\\n<ul>\\n<li>必须是一一对应的，也就是这个空间的一个点也需要映射到另外一个空间的一个点。</li>\\n</ul>\\n<p>对于flatMap，一种理解是map + flatten，但是我觉得这种理解不好，应为在FP中，flatMap远比map重要。</p>\\n<p>而map、flatMap加上withFilter和foreach实现了scala中最强大的for表达式。</p>\\n<p>其实叫for表达式不准确，英文是有两种称谓：</p>\\n<ul>\\n<li>\\n<p>for comprehension</p>\\n<p>for {\\nx &#x3C;- e1\\ny &#x3C;- e2\\n} yield e</p>\\n<p>comprehension的含义是“理解力”，人如其名，这个表达式也有很强大的理解力。看文本文希望能够对这个方面有所帮助。</p>\\n</li>\\n<li>\\n<p>for loop</p>\\n</li>\\n</ul>\\n<pre><code>for {\\n    i &#x3C;- e1\\n} {\\n    // do something.\\n}\\n</code></pre>\\n<p>本文这里套用Martin在\\\"Reactive Programming\\\"中的例子，对如何应用map, flatMap, for表达式做个简单介绍。</p>\\n<h2>例子</h2>\\n<p>这个例子中，我们需要实现一个随机生成器，能够随机生成：Int, Boolean, Pair, List, Tree</p>\\n<h2>实现</h2>\\n<h3>规约定义</h3>\\n<p>先定义一个Generator类，里面主要的方法就是一个<code>generate</code>，返回一个T</p>\\n<!-- language:lang-scala -->\\n<pre><code>trait Generator[T] { self =>\\n  def generate : T\\n}\\n</code></pre>\\n<h3>随机整数生成器</h3>\\n<p>我们来实现一个随机整数生成器。</p>\\n<!-- language:lang-scala -->\\n<pre><code>val integers = new Generator[Int] {\\n  def generate = {\\n    val r = new java.util.Random\\n    r.nextInt\\n  }\\n}\\n</code></pre>\\n<h3>随机布尔值生成器</h3>\\n<p>再生成一个布尔值随机生成器。</p>\\n<!-- language:lang-scala -->\\n<pre><code>val booleans = new Generator[Boolean] {\\n  def generate = {\\n    val r = new java.util.Random\\n    r.nextInt >= 0\\n  }\\n}\\n</code></pre>\\n<p>现在问题来了，上面的代码有两个问题：</p>\\n<p>1.代码重复\\n<code>val r = new java.util.Random ; r.nextInt</code>出现了两次</p>\\n<p>2.有boilerplate代码，<code>new Generator[Boolean]</code>, <code>def generate</code>等等\\n理想的情况应该是这样的：</p>\\n<!-- language:lang-scala -->\\n<pre><code>val booleans = for (i &#x3C;- integers) yield i > 0\\n</code></pre>\\n<p>但是如果你在REPL中尝试的话，会发现报错：</p>\\n<!-- language:lang-scala -->\\n<pre><code>scala> val boolean = for (i &#x3C;- integers) yield i >= 0\\n&#x3C;console>:9: error: value map is not a member of Generator[Int]\\n       val boolean = for (i &#x3C;- integers) yield i >= 0\\n</code></pre>\\n<p>OK, 因为for表达式就是对<code>map</code>, <code>flatMap</code>的简化，上面的代码会被翻译为：</p>\\n<!-- language:lang-scala -->\\n<pre><code>integers map { i => i > 0 }\\n</code></pre>\\n<p>我们没有在Generator中定义map，所以报错是必然的。修改一下：</p>\\n<!-- language:lang-scala run -->\\n<pre><code>trait Generator[T] { self =>\\n  def generate : T\\n\\n  def map[S](f: T => S): Generator[S] = new Generator[S] {\\n    def generate = f(self.generate)\\n  }\\n}\\nval integers = new Generator[Int] {\\n  def generate = {\\n    val r = new java.util.Random\\n    r.nextInt\\n  }\\n}\\n\\nval booleans = for (i &#x3C;- integers) yield i >= 0\\nbooleans.generate\\n</code></pre>\\n<p>点击<code>run</code>按钮试试，一切顺利！不错。</p>\\n<h3>随机Pair生成器</h3>\\n<p>我们再继续，来点难点的，来个随机<code>(Int, Int)</code>生成器，想一下，很简单，调用两次<code>integers.generate</code>就可以了。</p>\\n<!-- language:lang-scala -->\\n<pre><code>val pairs = new Generator[(Int, Int)] {\\n  def generate = (integers.generate, integers.generate)\\n}\\n</code></pre>\\n<p>同样的，我们不希望有boilerplate代码，每次new一个匿名类，还要重新定义<code>generate</code>，这是java中的无奈之举，对于scala来说，我们希望这么写：</p>\\n<!-- language:lang-scala -->\\n<pre><code>val pairs = for {\\n  x &#x3C;- integers\\n  y &#x3C;- integers\\n} yield (x, y)\\n</code></pre>\\n<p>但是当你试运行一下的时候会出现：</p>\\n<pre><code>scala> val pairs = for (x &#x3C;- integers ; y &#x3C;- integers) yield (x, y)\\n&#x3C;console>:9: error: value flatMap is not a member of Generator[Int]\\n       val pairs = for (x &#x3C;- integers ; y &#x3C;- integers) yield (x, y)\\n</code></pre>\\n<p>编译器抱怨说没有flatMap定义在Generator上，怎么回事？</p>\\n<p>同理，我们需要了解for表达式的翻译机理，上面的代码会背翻译为：</p>\\n<!-- language:lang-scala -->\\n<pre><code>integers flatMap { x => integers map { (x, _) }}\\n</code></pre>\\n<p>我们没有实现flatMap当然会出现这样的错误。好吧，我们来增强一下：</p>\\n<!-- language:lang-scala run -->\\n<pre><code>trait Generator[T] { self =>\\n  def generate : T\\n\\n  def map[S](f: T => S): Generator[S] = new Generator[S] {\\n    def generate = f(self.generate)\\n  }\\n\\n  def flatMap[S](f: T => Generator[S]): Generator[S] = new Generator[S] {\\n    def generate = f(self.generate).generate\\n  }\\n}\\n\\nval integers = new Generator[Int] {\\n  def generate = {\\n    val r = new java.util.Random\\n    r.nextInt\\n  }\\n}\\n\\nval pairs = for {\\n  x &#x3C;- integers\\n  y &#x3C;- integers\\n} yield (x, y)\\n\\npairs.generate\\npairs.generate\\n</code></pre>\\n<p>不错吧，everything just works like a charm. </p>\\n<p>我们还可以定义一些小工具，比如：</p>\\n<!-- language:lang-scala -->\\n<pre><code>def single[T](s: T) = new Generator[T] {\\n  def generate = s\\n}\\n\\ndef choose(from: Int, to: Int) = for { i &#x3C;- integers } yield (from + Math.abs(i) % (to - from))\\n\\ndef oneOf[T](choices: T*) = for ( idx &#x3C;- choose(0, choices.length) ) yield choices(idx)\\n</code></pre>\\n<p>看到OO中策略模式的影子了吗？</p>\\n<h3>List[Int]生成器</h3>\\n<!-- language:lang-scala -->\\n<pre><code>def nonEmptyList = for {\\n  head &#x3C;- integers\\n  tail &#x3C;- lists\\n} yield (head :: tail)\\n\\nval lists: Generator[List[Int]] = for {\\n  isEmpty &#x3C;- oneOf(true, false, false, false, false)\\n  list &#x3C;- if (isEmpty) single(Nil) else nonEmptyList\\n} yield list\\n</code></pre>\\n<h3>Tree生成器</h3>\\n<!-- language:lang-scala -->\\n<pre><code>trait Tree\\ncase class Node(left: Tree, right: Tree) extends Tree\\ncase class Leaf(x: Int) extends Tree\\n\\ndef leafs: Generator[Leaf] = for ( i &#x3C;- integers ) yield Leaf(i)\\n\\n//不是尾递归，很容易StackOverflow\\ndef nodes: Generator[Node] = for {\\n  left &#x3C;- trees\\n  right &#x3C;- trees\\n} yield Node(left, right)\\n\\ndef trees: Generator[Tree] = for {\\n  isLeaf &#x3C;- booleans\\n  tree &#x3C;- if (isLeaf) leafs else nodes\\n} yield tree\\n</code></pre>\\n<p>上面的代码因为用了递归，而且不是尾递归，很容易stackoverflow，一种workaround是增大<code>isLeaf</code>的概率，比如用<code>oneOf(true, true, true, false, false)</code>来替换<code>booleans</code>，这样就有2/3的概率为leaf，退出递归，但是还是很容易出错。下面用指令式的方式来实现以下：</p>\\n<!-- language:lang-scala -->\\n<pre><code>// 先根据深度，生成所有的叶子\\nprivate def leafs(depth: Int): List[Option[Leaf]] = (Math.pow(2, depth - 1).toInt to 1 by -2).toList.foldLeft(List[Option[Leaf]]()) { (acc, ele) =>\\n  val isLuck = booleans.generate\\n  if (isLuck)\\n    Some(Leaf(integers.generate)) :: Some(Leaf(integers.generate)) :: acc\\n  else\\n    None :: None :: acc\\n}\\n//依次聚集\\nprivate def aggregate(children: List[Option[Tree]]): List[Option[Tree]] = {\\n  if (children.length == 1) \\n    children\\n  else {\\n    val length = children.length        \\n    val parents = (length to 1 by -2).toList map { i => (children(i - 1), children(i - 2)) match {\\n        case (Some(l), Some(r)) => Some(Node(l, r))\\n        case (Some(l), None) => Some(Node(l, Leaf(integers.generate)))\\n        case (None, Some(r)) => Some(Node(Leaf(integers.generate), r))\\n        case (None, None) => Some(Leaf(integers.generate))\\n      }\\n    }\\n    aggregate(parents)\\n  }\\n}\\n\\ndef generateTree(depth: Int) = aggregate(leafs(depth))(0).get\\n</code></pre>\\n<p>总的思路是：先根据深度生成可能的叶子，然后两两聚集为上一层的父节点，然后递归直到根节点。</p>\\n<p>这个实现里同样没有用<code>可变量</code>。</p>\\n<h4>Bonus: 打印tree</h4>\\n<p>TBD</p>\\n<h2>关于for表达式</h2>\\n<p>如果你平常用for的场合都是在用一些collection的话，会产生一种错觉，以为for表达式智能应用在collection中，其实for表达式可以应用在任何定义了map/flatMap/withFilter/foreach的类型中，正如你在本文中看到的，那么一个问题是：</p>\\n<!-- language:lang-scala -->\\n<pre><code>val booleans = for ( x &#x3C;- integers ) yield x >= 0\\n</code></pre>\\n<p><code>booleans</code>的类型应该是什么呢？</p>\\n<p>如果你经常用for于collection，你可能会觉得是一个List[Boolean]，其实不是，真正的返回值是：<code>Generator[Boolean]</code>，因为for表达式知道<code>integers</code>的类型是Generator所以其返回值也是Generator，这就是for comprehension的含义是“理解力”，人如其名，这个表达式也有很强大的理解力。看文本文希望能够对这个方面有所帮助。</p>\\n<p>那么是如何实现的呢？其实很简单，将for表达式翻译为map你就知道其中玄机了。</p>\\n<!-- language:lang-scala -->\\n<pre><code>val booleans = for ( x &#x3C;- integers ) yield x >= 0 = integers map { _ >= 0 }\\n</code></pre>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/map-flatMap-for.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-12-01T19:16:45.000Z\",\"path\":\"/2013/map-flatmap-for\",\"title\":\"map/flatMap/for in Action\",\"excerpt\":\"前文说过了，高阶函数式函数式语言中的基石，而`map`, `flatMap`更是重要。\",\"tags\":[\"scala\",\"functional programming\"]}}},{\"node\":{\"html\":\"<p>Eric Meijer说：递归是函数式编程的GOTO，应该尽可能避免。如何避免，OO中我们用while循环，FP中我们用<code>fold</code>。</p>\\n<h2>什么是fold</h2>\\n<p>fold就是折纸，给你一张纸条，你可以将其分为若干等份（一个集合），然后从左向右一点一点卷折起来，折成一个你想要的形状，当然也可以从右向左，还可以对半折。</p>\\n<pre><code>+---+---+---+---+---+---+---+---+---+---+---+---+\\n|   |   |   |   |   |   |   |   |   |   |   |   |\\n| --->  |   |   |   |   |   |   |   |   |   |   |\\n|   |   |   |   |   |   |   |   |   |   |   |   |\\n+---+---+---+---+---+---+---+---+---+---+---+---+\\n</code></pre>\\n<p>这里“你想要的形状”，就是最终<code>fold</code>的输出。</p>\\n<p>风向的例子，北风就是从北面吹来的风。同样的，foldRight就是从右向左折叠，操作对象是seed集合，参数是前面集合的最后一个元素。</p>\\n<h2>foldRight</h2>\\n<!-- language:lang-scala -->\\n<pre><code>List(1,2,3).foldRight(seed)(f) = f(1, f(2, f(3, seed)))\\n</code></pre>\\n<p>记住：等式两边各个因子出现的顺序是相同的，都是1 -> 2 -> 3 -> seed，之所以重要，是因为最后一个<code>f(3, seed)</code>接受的参数是一个tuple: (ele, seed)，而不是(seed, ele)。\\n形象化一点，假设<code>f</code>是<code>cons</code>操作，也就是<code>::</code>:</p>\\n<pre><code>    ::\\n  /   \\\\\\n1       ::\\n       /  \\\\\\n      2     ::\\n           /  \\\\\\n          3    seed \\n</code></pre>\\n<p>例子：求整数集合之和。</p>\\n<!-- language:lang-scala run -->\\n<pre><code>val sum = List(1,2,3).foldRight(0) { (ele, seed) => { println(ele); seed + ele } }\\nprintln(sum)\\n</code></pre>\\n<p>点击<code>run</code>，可以看到，输出的<code>ele</code>顺序是<code>3 -> 2 -> 1</code>.</p>\\n<h2>foldLeft</h2>\\n<!-- language:lang-scala -->\\n<pre><code>List(1,2,3).foldLeft(seed)(g) = g(g(g(seed, 1), 2), 3)\\n</code></pre>\\n<p>这里，前面List中元素的处理顺序还是从左向右的，只是seed跑到了最前面，所以tuple变成了：(seed, ele)。</p>\\n<p>树形结构：</p>\\n<pre><code>            g\\n          /   \\\\\\n        g      3\\n      /   \\\\\\n    g       2\\n  /   \\\\\\nseed   1\\n</code></pre>\\n<p>注意：这里我用的函数换成了<code>g</code>，而不是前面的<code>f</code>，就是想提醒大家，这是两个不同的函数，其参数都是tuple，但是seed的顺序不同。这在编程的时候经常搞混。</p>\\n<p>相同的例子：求一个整数集合的和。</p>\\n<!-- language:lang-scala run -->\\n<pre><code>val sum = List(1,2,3).foldLeft(0) { (seed, ele) => { println(ele); seed + ele } }\\nprintln(sum)\\n</code></pre>\\n<p>点击<code>run</code>，可以看到，输出的<code>ele</code>顺序是<code>1 -> 2 -> 3</code>.</p>\\n<h2>助记</h2>\\n<p>foldLeft/foldRight中block的参数tuple顺序经常搞混，为了方便记忆，我们可以这么来看，我们用seed做基准：</p>\\n<ul>\\n<li>foldRight，从右向左，tuple中seed在右<code>(elem, seed)</code></li>\\n<li>foldLeft, 从左向右，tuple中seed在左<code>(seed, elem)</code></li>\\n</ul>\\n<p>有了fold是卷折纸的概念，我们就比较容易理解unfold.</p>\\n<h2>unfold</h2>\\n<p>与<code>fold</code>对应，<code>unfold</code>就是反过来将一个卷折好的纸分解开，变成若干等份（集合），所以unfold是一个集合的构造过程。</p>\\n<h2>例子</h2>\\n<p>我们这里举一个实际的例子。</p>\\n<!-- language:lang-scala -->\\n<pre><code>def retry(n: Int)(block: => Future[T]): Future[T] = {\\n  if (n &#x3C;= 0) {\\n    Future.failed{ new RuntimeException(\\\"failed even if retried\\\") }\\n  } else {\\n    block fallbackTo {\\n      retry(n - 1)(block)\\n    }\\n  }\\n}\\n</code></pre>\\n<p>这里我们用了递归，但是如Erik Meijer所说，递归是FP的GOTO，不容易理解，容易出错，我们来用fold来替换一下。</p>\\n<p>可是一般来说fold都是需要一个集合的，而这里有什么集合？没有条件，创造条件也要上！我们可以将<code>n</code>也就是次数看成是一个集合，因为逻辑上我们要作几次，每次算一个集合元素，那么这不就是一个集合吗？</p>\\n<p>这个集合就是：<code>val attempts = (1 to n) map { _ => () => block }</code>，有了操作的集合，我们就可以开始玩折纸游戏了。</p>\\n<p>我们最终要“折的形状”是：成功的话返回<code>T</code>，否则返回一个Failure。我们可以将一个缺省的failure作为seed开始。</p>\\n<p>而且我们期望的执行顺序是：<code>block1 recoverWith (block2 recoverWith (block3 recoverWith failure))</code>，很明显，这是一个<code>foldRight</code>。</p>\\n<!-- language:lang-scala -->\\n<pre><code>def retry(n: Int)(block: => Future[T]) = {\\n  val ns = (1 to n).iterator\\n  // 注意：这里的map不关心ns中的系数，所以用'_'，后面需要一个by name参数，所以需要一个() => block，否则将会提前计算，达不到重试效果。\\n  val attempts = ns map { _ => () => block }\\n  val failure = Future.failed{ new RuntimeException(\\\"failed even if retried\\\") }\\n  // 这里seed是一个call by name\\n  attempts.foldRight(() => failure) { (attempt, seed) =>\\n    // seed是call by name，这里也需要是call by name\\n    () => attempt() fallbackTo{ seed() }\\n  }\\n}\\n</code></pre>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/fold编程.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-27T19:16:45.000Z\",\"path\":\"/2013/fold\",\"title\":\"折纸的艺术：fold编程\",\"excerpt\":\"Eric Meijer说：递归是函数式编程的GOTO，应该尽可能避免。如何避免，OO中我们用while循环，FP中我们用`fold`。\",\"tags\":[\"scala\",\"functional programming\",\"fold\"]}}},{\"node\":{\"html\":\"<p>函数式语言与OO（确切地讲是指令式编程）的思维方式是完全不同的，很多OO中的经验在函数式语言中不是很匹配，比如设计模式，那就是一个OO中的特定术语，而在FP中，大家常谈的是对于习惯OO思维的程序员来说玄而又玄的Monad。</p>\\n<p>虽然术语不同，其实要解决的问题是相同的，设计模式也好、Monad也好，都是为了如何更好地处理异常、让代码更加简洁易懂、容易扩展等等。【所以透彻地了解问题本身，比学习一个新的技术更加重要。】</p>\\n<p>本系列文章试图能够将Monad这个及其抽象的东东具体化，将其落地，变为能够理解的例子，看看在具体问题下如何使用Monad来抽象问题，简化代码。</p>\\n<h2>什么是Monad</h2>\\n<h3>定义</h3>\\n<p>一个Monad就是一个实现了flatMap, unit等函数，包含某种数据类型的容器，更加术语化一点是参数化类型<code>M[T]</code>.</p>\\n<!-- language:lang-scala -->\\n<pre><code>trait M[T] {\\n  def flatMap[U](f: T => M[U]) : M[U]\\n  def unit[T](x: T) : M[T]\\n}\\n</code></pre>\\n<p>Monad需要满足三个定理（没错，就是定理，感觉回到了小学、初中的数学课堂）。</p>\\n<ul>\\n<li>\\n<p>组合律</p>\\n<p><code>(x flatMap f) flatMap g == x flatMap (y => f(y) flatMap g)</code></p>\\n<p>有些人可能会问，右边为什么不是 <code>x flatMap (f flatMap g)</code>呢？ 你试一下就知道了，编译器报类型匹配错误，这里<code>x</code>是一个monad，<code>f</code>, <code>g</code>都是函数，所以<code>f flatMap g</code>会类型不匹配。</p>\\n</li>\\n<li>\\n<p>左单一</p>\\n<p><code>unit(x) flatMap f == f(x)</code></p>\\n</li>\\n<li>\\n<p>右单一</p>\\n<p><code>x flatMap unit == x</code></p>\\n</li>\\n</ul>\\n<h3>Monad举例</h3>\\n<p>在Scala中Monad不是新鲜玩意，其实只要你学scala，那你就会天天用，常用的Monad有：</p>\\n<ul>\\n<li>Collection类，比如：List, Set, Map</li>\\n<li>描述可能性的Option  (Some, None)</li>\\n<li>异常处理类 Try, scalaz中的Validation等</li>\\n<li>描述未来的 Future</li>\\n<li>封装状态变化的State</li>\\n<li>封装IO的IO</li>\\n</ul>\\n<h2>Monad解决什么问题</h2>\\n<p>正如上面列举的几个Monad，每种Monad都是为了解决某种具体问题而存在的，正如OO中设计模式一样，只不过Monad的侧重点是：</p>\\n<ul>\\n<li>\\n<p>让你只关注代码主流程，而将异常等分支交给flatMap来处理。</p>\\n</li>\\n<li>\\n<p>每个Monad是一个容器或者一个平行空间，让你可以在该容器（空间）中安全地、方便地操作容器中的数据类型，而不用关心相关问题。比如：在Option空间中，你不用考虑是否有返回值的问题，不需要像指令式编程那样<code>if (rtn == null) ... else ...</code>，再比如Future，让你能够在“未来的时空”中对数据进行操作，不用担心同步的问题，因为你的运算都发生在“未来”空间中。</p>\\n</li>\\n<li>\\n<p>结合for表达式，让你的代码更加简洁、易读。</p>\\n<p><code>for { x &#x3C;- monad; y &#x3C;- f(x); ...}</code></p>\\n<p>而前面讲的定律（主要是结合律和右单一），可以确保monad在for表达式中使用的正确性，比如结合律：</p>\\n</li>\\n</ul>\\n<!-- language:lang-scala -->\\n<pre><code>for {\\n  y &#x3C;- for (x &#x3C;- m; y &#x3C;- f(x)) yield y\\n  z &#x3C;- g(y)\\n} yield z\\n</code></pre>\\n<p>因为满足结合律，就可以简化为：</p>\\n<!-- language:lang-scala -->\\n<pre><code>for {\\n  x &#x3C;- m\\n  y &#x3C;- f(x)\\n  z &#x3C;- g(y)\\n} yield z\\n</code></pre>\\n<p>如果翻译为map/flatMap，前者翻译为：<code>m flatMap f flatMap g</code>，后者翻译为：<code>m flatMap (x => f(x) flatMap g)</code>.</p>\\n<p>而右单一定律可以保证：<code>for {x &#x3C;- m} yield x == m</code>，如果你看过scalaz，你就了解为什么scalaz中需要有专门的test case来测试这些定律了。</p>\\n<p>一般来说我们不太需要关注这些定律的问题，但是如果你需要自己开发一个自己的Monad，那么你就得保证你的Monad符合这些定律，因为这样才能让你的Monad安全地应用在for表达式中。</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Monad.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-26T07:16:45.000Z\",\"path\":\"/2013/monad\",\"title\":\"Monad\",\"excerpt\":\"函数式语言与OO（确切地讲是指令式编程）的思维方式是完全不同的，很多OO中的经验在函数式语言中不是很匹配，比如设计模式，那就是一个OO中的特定术语，而在FP中，大家常谈的是对于习惯OO思维的程序员来说玄而又玄的Monad。\",\"tags\":[\"scala\",\"functional programming\",\"monad\"]}}},{\"node\":{\"html\":\"<p>所谓高阶函数（high order function），其实就是可以接受其他函数作为参数的函数。</p>\\n<p>这里其实还有另外一个概念：<em>头等函数</em>（First Class Function），First Class应该是指头等公民的含义。在Java中的一个方法（函数），只能被调用，相比值Value就像个二等公民，不能像值Value一样，既可以在表达式中被引用，又可以作为参数传入其他方法。</p>\\n<p>头等函数也就是可以将其作为一个值进行传递的函数。看上去很简单，可带来的变化是巨大的。</p>\\n<p>头等函数加上高阶函数，可以极大地简化代码，实现DSL。</p>\\n<h2>简化代码</h2>\\n<h3>Java中的匿名类</h3>\\n<!-- language:lang-java -->\\n<pre><code>import java.util.*\\n\\nTimer timer = new Timer();\\nTimerTask helloTimer = new TimerTask(){\\n    public void run(){\\n        System.out.println(\\\"Hello Timer\\\");\\n    }\\n};\\ntimer.schedule(helloTimer, 1);\\n\\nTimerTask helloWorld = new TimerTask(){\\n    public void run(){\\n        System.out.println(\\\"Hello World\\\");\\n    }\\n};\\ntimer.schedule(helloWorld, 1);\\n</code></pre>\\n<p>然后每次都需要new一个TimerTask匿名类，用起来真心不方便，尤其是当你有多个匿名类要一起使用的时候，那代码看起来简直就像一坨翔，丑陋无比！本来正常的、相同抽象层次的代码应该具有相同的缩进层次，这样阅读起来很易懂、顺畅。但是因为引入匿名类，就得放在不同的缩进层次中，加上不必要的类签名定义，方法定义等boilerplate code, 阅读起来那叫一个费劲！</p>\\n<p>看看scala的方式：</p>\\n<h1>Scala</h1>\\n<!-- language:lang-scala run -->\\n<pre><code>import scala.concurrent._\\nimport scala.concurrent.duration._\\nimport scala.concurrent.ExecutionContext.Implicits.global\\n\\nval timer = new java.util.Timer()\\ndef timeout[A](a: => A, duration: Duration)(implicit ec: ExecutionContext): Future[A] = {\\n    val p = Promise[A]()\\n    timer.schedule(new java.util.TimerTask() {\\n        def run() = {\\n            p.success(a)\\n        }\\n    }, duration.toMillis)\\n    p.future\\n}\\n\\ntimeout(println(\\\"Hello World\\\"), 1 millisecond)\\ntimeout(println(\\\"Hello Timer\\\"), 1 millisecond)\\n</code></pre>\\n<p>定义一个timeout高阶函数，接受一个<code>=> A</code>函数作为参数，然后就可以方便地重复调用了。\\n</p>\\n<h2>自定义控制结构+鸭子类型</h2>\\n<h3>try with resources</h3>\\n<p>在Java中，在处理一些资源相关的数据时，经常需要用一个<code>try .... catch ... finally { res.close(); }</code>的结构，同样地，这种结构使得代码的缩进层次和逻辑抽象层次不同而影响阅读。另外更严重的问题是常常忘记关闭资源。</p>\\n<p>Java中的一种解决方案是用<code>template method</code>模式，比如Spring JdbcTemplate，传入一个匿名类，比如：</p>\\n<!-- language: lang-java -->\\n<pre><code>jdbcTemplate.execute(new StatementCallback(){\\n    public Object doInStatement(Statement stmt) throws SQLException, DataAccessException {\\n        // your real logic here\\n    }\\n}\\n</code></pre>\\n<p>可以看到，真正的逻辑被缩进了两层，有很多boilerplate代码。</p>\\n<p>Java 1.7中引入了try with resources的语法，一定程度上解决了这个问题：</p>\\n<!-- language: lang-java -->\\n<pre><code>try (BufferedReader br = new BufferedReader(new FileReader(path))) {\\n    return br.readLine();\\n}\\n</code></pre>\\n<p>但是要求在try里面的资源必须实现<code>AutoCloseable</code>接口。当然了，Java中很多东西都是围绕接口转。接口就意味着规约，要使用try-with-resources语法，就必须符合这个规约。</p>\\n<p>再看看Scala中如何实现：</p>\\n<!-- language: lang-scala run -->\\n<pre><code>def using[T &#x3C;: { def close() }](resource: T)(block: T => Unit) {\\n  try {\\n    block(resource)\\n  }finally {\\n    if (resource != null) resource.close()\\n  }\\n}\\ncase class Resource {\\n    def close() = println(\\\"I'm closing\\\")\\n    def doSomething() = println(\\\"boring\\\")\\n}\\n\\nval res = Resource()\\n\\nusing[Resource](res){ res =>\\n    res.doSomething()\\n}\\n</code></pre>\\n<p>和<code>try-with-resources</code>的语法比较像吧，不过不同的是，<code>using</code>不要求传入的resource必须实现某种接口，只需要该类型定义了一个<code>def close(): Unit</code>方法。这就是所谓的鸭子类型，只要你走起来像鸭子，那你就是鸭子，不是一个很好的比喻，不过将就吧。</p>\\n<h3>break</h3>\\n<p>当你学习scala的时候，你会发现很多java中的关键字在scala中是不支持的，其中一个就是：<code>break</code>。</p>\\n<p>在一个循环的时候，当满足某个条件就退出当前循环，是一个很普遍的用法，为什么scala中会不是一个关键字呢？我自己感觉是scala强调FP，而break有很浓的指令式编程的味道。</p>\\n<p>那我就是想用break怎么办？不要紧，我们可以自己定义一个自己的break。</p>\\n<!-- language: lang-scala run -->\\n<pre><code>class Breaks {\\n  private class BreakControl extends RuntimeException\\n  private val breakException = new BreakControl\\n\\n  // breakable接受一个() => Unit的函数作为参数，是一个高阶函数。\\n  def breakable(op: => Unit) {\\n    try {\\n      op\\n    } catch {\\n      case ex: BreakControl =>\\n        if (ex ne breakException) throw ex\\n    }\\n  }\\n\\n  def break(): Nothing = { throw breakException }\\n}\\nobject Breaks extends Breaks\\n\\n\\nimport Breaks.{break, breakable}\\n// 通过高阶函数来实现break\\nbreakable {\\n  for (i &#x3C;- (1 to 1000)) {\\n    if (i > 10){\\n      break\\n    } else {\\n      println(i)\\n    }\\n  }\\n}\\n</code></pre>\\n<p>是不是很棒？！scala没有我们可以自己造。这就是高阶函数的用处之一。</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/高阶函数.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-21T19:16:45.000Z\",\"path\":\"/2013/high-order-function\",\"title\":\"高阶函数\",\"excerpt\":\"所谓高阶函数（high order function），其实就是可以接受其他函数作为参数的函数。\",\"tags\":[\"scala\",\"functional programming\",\"high order function\"]}}},{\"node\":{\"html\":\"<h2>上下文</h2>\\n<p>很多时候为了提高性能，减少IO操作，都会将数据load出来之后缓存在内存中。本站的实现过程中也遇到类似的问题，不希望每次有人访问的时候就读取一次md文件，或者从MongoDB中查一次，而是直接在内存中读取。</p>\\n<p>带来因减少IO而提升性能的好处的同时，也出现一个人和“缓存”解决方案都会遇到的问题：数据一致性。</p>\\n<p>简单来说，就是你有同样的一份数据，冗余存放在两个地方，如何确保这两个地方的数据是一致的？再具体一点，可能的问题有：</p>\\n<ul>\\n<li>\\n<p>数据更新的原子性</p>\\n<p>更新数据的时候，同时将两个地方的数据都同步更新，任何一个地方更新失败，则整体更新失败。</p>\\n</li>\\n<li>\\n<p>缓存线程安全的问题</p>\\n<p>如果缓存既可以被读取，又可能被更新，那么就又线程安全问题：多个线程同时操作同一个值的时候怎么协调？</p>\\n</li>\\n</ul>\\n<h2>具体问题</h2>\\n<p>开始的时候，我将所有的文章列表放在一个<code>scala.collection.mutable.ListBuffer</code>中：</p>\\n<!-- language:lang-scala -->\\n<pre><code>object Application extends Controller {\\n  lazy val allPosts: ListBuffer[Post] = ...\\n\\n}\\n</code></pre>\\n<p>因为新发布博客会增加集合内数据，所以这里用ListBuffer比较自然。当然用<code>var</code> + immutable collection也可以。</p>\\n<p>对<code>allPost</code>的操作主要有三个：</p>\\n<ol>\\n<li>\\n<p>在线编写一个博客的时候需要添加到集合中</p>\\n</li>\\n<li>\\n<p>该集合本身是无序的，因为排序的规则可能有多种，展现的时候再排序</p>\\n</li>\\n<li>\\n<p>更新一篇博文的时候同时更新集合中内容。</p>\\n</li>\\n</ol>\\n<p>因为本身Application Object是单例的，多个线程共同运行的场景下就会出现线程安全的问题，类似Servlet中instance级别变量的问题。</p>\\n<h2>解决方案</h2>\\n<p>直观地想，理想的解决方案就是将所有对<code>allPost</code>的写操作都串行起来，这样即使有多个线程同时操作，也没问题了。但是如何将实现串行呢？</p>\\n<p>在指令式编程的世界里，这个问题比较难于解答，一般需要通过加锁来解决。而一般的程序员看到<code>lock</code>, <code>synchronized</code>这些关键字就头疼了，即使经过无数次盲试之后侥幸实现了，也会在产品上线的时候出现这样那样、莫名其妙、让你大呼“这不科学”，“WTF”的惊呼！</p>\\n<p>但是在scala中，我们却不用担心，因为我们有<code>Akka Actor</code>。</p>\\n<p>Actor是另外一种并行计算方式，不同于线程共享内存的并发模型，Actor是基于消息的，强调不同Actor之间不共享数据。有了Actor，问题就迎刃而解了。</p>\\n<p>具体思路是：重建一个单例Actor，由该Actor来维护ListBuffer变量，所有的写操作，全部通过该消息提交任务交给其处理，这样就将并发的多个写请求串行起来了。</p>\\n<p>代码片段：</p>\\n<!-- language:lang-scala -->\\n<pre><code>object PostManager {\\n  // 单例manager actor\\n  lazy val manager = Akka.system.actorOf(Props[PostManager])\\n  case class NewPost(post: Post)\\n  \\n  def saveOrUpdate(unsavedPost: Post) = {\\n    manager ! NewPost(unsavedPost)\\n  }\\n}\\n\\nclass PostManager extends Actor {\\n  import PostManager._\\n  // actor是单例的，所以文章集合也是单例的。\\n  // all posts, but not ordered.\\n  lazy val allPosts: ListBuffer[Post] = Post.allPosts\\n  \\n  def receive = {\\n    case NewPost(newPost) =>\\n      // 先更新数据库，这样如果更新失败，就不会运行之后代码。一定程度上实现原子性。\\n      Post.upsert(newPost)\\n      \\n      val idx = allPosts.indexWhere( _.fileName == newPost.fileName )\\n      \\n      if (idx == -1){\\n        allPosts += newPost\\n      } else {\\n        allPosts.update(idx, newPost)\\n      }\\n  }\\n}\\n</code></pre>\\n<p>全站一个文章集合变量感觉有点\\\"玩具\\\"的感觉，不过这个模型其实是可以扩展的，比如将来如果支持多用户、多博客系统，我们可以每个用户创建一个Actor、维护该用户自己的文章列表。这个Actor模型还是可以重用的。</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Actor协调并发场景下的集合操作.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-17T14:16:45.000Z\",\"path\":\"/2013/actor-collection-collabration\",\"title\":\"边建边学-3：Actor协调并发场景下的集合操作\",\"excerpt\":\"很多时候为了提高性能，减少IO操作，都会将数据load出来之后缓存在内存中。本站的实现过程中也遇到类似的问题，不希望每次有人访问的时候就读取一次md文件，或者从MongoDB中查一次，而是直接在内存中读取。\",\"tags\":[\"scala\",\"functional programming\"]}}},{\"node\":{\"html\":\"<h2>Context</h2>\\n<p>插曲：前不久微博上看到一技术“牛人”大V评论Java8的一些特性，引入lambada但没有扩展能力，集合的查询都得靠新stream api而不是Enumerator / Iterator云云。一时手欠回复了下“似乎应该是Enumerator / Iteratee“, 结果引来一身骚，被该大V泼口大骂了一个下午，没错就是像网吧里面无聊的小青年一样无营养地谩骂，实在没搞懂到底是为什么，说我说的Iteratee和他说的没”鸡毛“关系，不懂，也不想搞懂了，还是他玩他的Iterator我介绍我的Iteratee吧。</p>\\n<p>因为我们的内存、磁盘等资源还是有限的，对于一个大的Stream，Collection，我们在处理的时候不应该将其作为整体进行处理，因为这样会带来潜在的风险，比如：内存溢出，降低系统吞吐量等等。</p>\\n<p>正确的方式是将大的不可预见（unpredictable）的stream，Collection进行分解，将其分解为小的，可预见（predictable）的块进行处理。这是流模式的思想，也是Iteratee的设计目标之一。</p>\\n<p>Stream对于指令式编程已经比较成熟了，有大量的类库，丰富的API。但是对于强调不可变量，尽可能无副作用的FP来说，要考虑语言适配的问题，而目前，流行的解决方案就是：Enumerator/Iteratee。</p>\\n<p>另外，就是需要用统一的API来处理所有类型的Stream，就像指令式编程中的<code>InputStream.read</code>, <code>OutputStream.write</code>，无论什么Stream都需要支持这些基本方法。</p>\\n<h2>High Level Concept Model</h2>\\n<p>Enumerator / Iteratee说起来很复杂，其实就是一个生产者 / 消费者模型。 Enumerator是生产者，创建诸多个可控的chunk，Iteratee是消费者，消费任意类型的Input Chunk。</p>\\n<!-- language:lang-scala -->\\n<pre><code>trait Enumerator {\\n  def |>>[A](i: Iteratee[E, A]): Future[Iteratee[E, A]] = apply(i)\\n}\\n</code></pre>\\n<p>Enumerator驱动一个Iteratee，Iteratee处理一个Chunk之后，返回下一个状态的Iteratee. 在构造Enumerator的时候不会真正读取数据，只有在真正消费时才产生IO。</p>\\n<p>而且多个Enumerator之间可以组合，不同类型的消费者（Iteratee）也可以进行组合、变换，简言之，组合的概念就是将每个Enumerator / Iteratee都看成是一个可组合的积木，每个积木相对独立可复用，写代码就是将这些积木组合达成你想要形状的过程。这个说法很常见，OO里提倡“组合优于继承”也是一样的思想，其中的关键是如何找到最小的可复用的component，然后是通过什么样的方式进行灵活地组合。</p>\\n<p>Enumerator / Iteratee / Enumeratee就是一个非常好的例子。</p>\\n<h2>消费者 Iteratee</h2>\\n<!-- language:lang-scala -->\\n<pre><code>class Iteratee &#x3C;&#x3C; (T, #00FF00) >> {\\n  Future[B] fold[B](folder: Step[E, A] => Future[B])\\n}\\nclass ImmediateIteratee &#x3C;&#x3C; (T, #00FF00) >>\\nclass Done &#x3C;&#x3C; (O, #FF0000) >>\\nclass Cont &#x3C;&#x3C; (O, #FF0000) >>\\nclass Error &#x3C;&#x3C; (O, #FF0000) >>\\nclass Step &#x3C;&#x3C; (T, #00FF00) >>\\nclass Input &#x3C;&#x3C; (T, #00FF00) >>\\n\\nIteratee &#x3C;|-- ImmediateIteratee\\nIteratee &#x3C;|-- FutureIteratee\\nIteratee &#x3C;.left.> Step\\nStep .left.> Input\\n\\nImmediateIteratee &#x3C;|-- DoneIteratee\\nDoneIteratee .. Done\\nImmediateIteratee &#x3C;|-- ContIteratee\\nContIteratee .. Cont\\nImmediateIteratee &#x3C;|-- ErrorIteratee\\nErrorIteratee .. Error\\n\\nnote \\\"company objects\\\" as oNote\\nDone .. oNote\\nCont .. oNote\\nError .. oNote\\n</code></pre>\\n<p>Iteratee是一个Input的消费者，注意：这里的Input不是全部输入，而是a chunk of input，这个很重要，没有一个Iteratee来消费所有输入数据，而是每块一个消费者，然后通过函数组合的方式将所有块穿起来。</p>\\n<ul>\\n<li>\\n<p>为什么不是一个完整输入对应一个消费者呢？\\n这是指令式编程的思维方式，因为你需要自己考虑实现细节，设计一些游标，每次读取步进的长度，判断游标的位置来判断下一步如何操作。</p>\\n</li>\\n<li>\\n<p>为什么不是所有的输入chunk共享一个消费者呢？\\n嗯，这个问题我不是很确定，应该是有一部分上面的原因，另外就是副作用的问题，每个Step自己维护自己的状态，可以比较容易地实现“懒加载”，在最后一步（调用<code>run</code>）的时候才真正发生IO，而之前，可以通过函数组合任意对每一步进行transform等操作。</p>\\n</li>\\n</ul>\\n<p>Iteratee还有一个需要注意的地方，fold函数是一个<code>curried function</code>，有一个implicit的参数ExecutionContext，也就是在哪个线程池中执行，这个现象在Play中很普遍。</p>\\n<p>ImmediateIteratee描述了一个已经预先知道其state的Iteratee，而FutureIteratee当然就是未来才能知道其State的Iteratee。[个人感觉这个地方设计有点怪，FutureIteratee似乎应该用Future[Iteratee]更好。] </p>\\n<!-- language:uml -->\\n<pre><code>class Step &#x3C;&#x3C; (T, #00FF00) >> {\\n  Iteratee[E, A] it\\n}\\nclass Iteratee &#x3C;&#x3C; (T, #00FF00) >>\\nclass Input &#x3C;&#x3C; (T, #00FF00) >>\\nStep .left.> Input\\nStep &#x3C;-right-> Iteratee\\nStep &#x3C;|-- Done\\nStep &#x3C;|-- Cont\\nStep &#x3C;|-- Error\\n</code></pre>\\n<p>Step描述的是一个Iteratee的状态，其本身包含一个Iteratee不变量<code>it</code>，而Done、Cont、Error也是简单的<code>case class</code>，所以构造也很简单。</p>\\n<!-- language:uml -->\\n<pre><code>class Input &#x3C;&#x3C; (T, #00FF00) >>\\nInput &#x3C;|-- El\\nInput &#x3C;|-- Empty\\nInput &#x3C;|-- EOF\\n</code></pre>\\n<p>Input[E]描述的是<code>一块</code>输入(a chunk of input，不是全部输入)，构造其实很简单，就是一个简单的case class，可以按照你熟悉的方式来构造。</p>\\n<h2>生产者 Enumerator</h2>\\n<p>先来看看Enumerator的定义：</p>\\n<!-- language:lang-scala -->\\n<pre><code>trait Enumerator[E] {\\n\\n  /**\\n   * Apply this Enumerator to an Iteratee\\n   */\\n  def apply[A](i: Iteratee[E, A]): Future[Iteratee[E, A]]\\n  def |>>[A](i: Iteratee[E, A]): Future[Iteratee[E, A]] = apply(i)\\n  ...\\n\\n}\\n</code></pre>\\n<p>由上面定义可以看到，一个<code>Enumerator</code>接受一个<code>Iteratee[E, A]</code>，并返回一个<code>Future[Iteratee[E, A]]</code>，翻译一下就是：Enumerator驱动一个消费者，消费数据之后产生一个下个状态的消费者。</p>\\n<p>Enumerator提供了大量的工厂方法（在scala中是通过伴生对象来实现），比如，你可以从一个数组创建一个Enumerator:</p>\\n<!-- language:lang-scala -->\\n<pre><code>val enumerateCountries = Enumerator[String] = Enumerator(\\\"China\\\", \\\"America\\\", \\\"Japan\\\", \\\"Russia\\\", \\\"England\\\")\\n</code></pre>\\n<p>可以从一个文件中创建：</p>\\n<!-- language:lang-scala -->\\n<pre><code>val enumerateFile: Enumerator[Array[Byte]] = Enumerator.fromFile(new File(\\\"path/to/some/big/file\\\"))\\n</code></pre>\\n<p>或者从一个Stream中创建：</p>\\n<!-- language:lang-scala -->\\n<pre><code>val enumerateFile: Enumerator[Array[Byte]] = Enumerator.fromStream(new java.io.FileInputStream(new File(\\\"path/to/some/big/file\\\")))    \\n</code></pre>\\n<p>更加通用的方式是从一个<code>e: ()=>Future[Option[E]]</code>函数来创建，因为这个函数声明了：未来可能会产生一个<code>E</code>:</p>\\n<!-- language:lang-scala -->\\n<pre><code>def generateM[E](e: => Future[Option[E]])(implicit ec: ExecutionContext): Enumerator[E] = {\\n    ...\\n}\\n</code></pre>\\n<p>发挥一下你的想象，很多事情都可以看成是Stream，比如时间：</p>\\n<!-- language:lang-scala -->\\n<pre><code>import play.api.libs.concurrent.Promise\\nimport play.api.libs.iteratee._\\nimport scala.concurrent.duration._\\nimport scala.concurrent.ExecutionContext.Implicits.global\\nimport java.util.Date\\n\\n// 截止时间\\nval alertTo = new Date(System.currentTimeMillis + 1000*60)\\n\\n// 一个时间流，截止到alertTo\\nval timeStream = Enumerator.generateM {\\n    Promise.timeout(\\n      if (new Date before alertTo) Some(new Date) else None, \\n      1 seconds)\\n}\\n\\nval printlnSink = Iteratee.foreach[Date](date => println(date))\\n// 每隔一秒钟打印一次，直到alertTo\\ntimeStream |>> printlnSink\\n</code></pre>\\n<p>如果你想再play console里面运行上面的代码，可能会失败，说什么:no application started之类的，这时你需要前面加上：</p>\\n<!-- language:lang-scala -->\\n<pre><code>val app = new play.core.StaticApplication(new java.io.File(\\\".\\\"))\\n</code></pre>\\n<p>创建一个测试用的application，再试一下就OK了。</p>\\n<p>除了这个例子，我觉得也可以将数据库中的游标查询用Enumerator来实现。</p>\\n<p>在Play框架中，还有一个实际的例子是<code>WebSocket</code>，有机会我们再单独介绍。</p>\\n<h2>适配器 Enumeratee</h2>\\n<p>对应OO Design Pattern中的Adaptor模式，<code>Enumeratee</code>就是一个Adaptor，将不同规格的组件适配在一起。比如下面这个例子：</p>\\n<p>我们有一个String类型的Enumerator, <code>Enumerator(\\\"123\\\", \\\"456\\\", \\\"789\\\", \\\"222\\\", \\\"333\\\", \\\"444\\\")</code>，还有一个累加器，<code>Iteratee.fold[Long, Long](0:Long) { (acc, el) => acc + el }</code>，两者的“规格”是不同的，一个是String， 但另外一个是Long，当然我们可以再定义一个新的Iteratee，比如：<code>Iteratee.fold[String, Long](0:Long) { (acc, el) => acc + el.toLong }</code>，但是显然，这里面有重复代码的臭味道。更加合理的方式是做一个适配，用一个适配器来讲两个已经存在的component转接后一起工作。</p>\\n<!-- language:lang-scala run -->\\n<pre><code>import play.api.libs.iteratee._\\nimport scala.concurrent.ExecutionContext.Implicits.global\\n\\nval strings = Enumerator(\\\"123\\\", \\\"456\\\", \\\"789\\\", \\\"222\\\", \\\"333\\\", \\\"444\\\")\\nval sum = Iteratee.fold[Long, Long](0:Long) { (acc, el) => acc + el }\\nval toLong = Enumeratee.map[String]( x => x.toLong )\\n\\nstrings |>> toLong &#x26;>> sum flatMap { x => x.run } onSuccess { case s => println(s) }\\n// Or, transform the Enumerator first.\\nstrings &#x26;> toLong |>> sum flatMap { x => x.run } onSuccess { case s => println(s) }\\n</code></pre>\\n<p>上面例子可以看到，<code>Enumeratee</code>不但可以适配<code>Iteratee</code>，还可以转换<code>Enumerator</code>。</p>\\n<p>留个问题：<code>strings &#x26;> toLong</code>会不会产生memory的问题？ </p>\\n<h2>指令式 VS. 函数式</h2>\\n<p>这里用一个很无聊的例子：遍历一个大文件来统计文件大小。</p>\\n<h3>指令式风格</h3>\\n<p>Use Java FileInputStream, more imperative style:</p>\\n<!-- language:lang-scala -->\\n<pre><code>val fis = new java.io.FileInputStream(new java.io.File(\\\"/Users/leo/Movies/big_file.mkv\\\"))\\n\\n// mutable variables\\nvar readLength = 0\\nvar fileSize: Long = 0\\nvar buf = new Array[Byte](1024 * 8) // chunk size used in Enumerator\\nval begin = System.currentTimeMillis\\ndo {\\n  readLength = fis.read(buf)\\n  if (readLength != -1)\\n    fileSize = fileSize + readLength\\n}while(readLength != -1)\\n\\nprintln(s\\\"File Size: $fileSize, and it took ${System.currentTimeMillis - begin} ms\\\")\\n</code></pre>\\n<p>And output like <code>File Size: 4003885806, and it took 54701 ms</code>, the memory usage is about <code>78Mb</code>.</p>\\n<h3>函数式风格</h3>\\n<p>Use Enumerator / Iteratee to get file size:</p>\\n<!-- language:lang-scala -->\\n<pre><code>import play.api.libs.iteratee._\\n// construct an Enumerator from a file\\nval fileEnum = Enumerator.fromFile(new java.io.File(\\\"/Users/leo/Movies/big_file.mkv\\\")) \\n// create a consumer\\nval counter = Iteratee.fold[Array[Byte], Long](0: Long){ (acc, ele) => ele.size + acc }\\n\\nval begin = System.currentTimeMillis\\n// where the IO really happens.\\nIteratee.flatten(fileEnum |>> counter).run.onSuccess { case x => println(s\\\"File Size: $x, and it took ${System.currentTimeMillis - begin} ms\\\") }\\n</code></pre>\\n<p>Here's the output: <code>File Size: 4003885806, and it took 57213 ms</code>, and max memory usage is about <code>120Mb</code>. </p>\\n<p>Note: If you are running above code with Scala version &#x3C; 2.10.3, you'll run into <code>OutOfMemory</code> Error, it's so funny right? Enumerator / Iteratee suppose to be designed to solve the OutOfMemory issue, actually, it's not Enumerator/Iteratee 's problem, it's a bug of scala, see <a href=\\\"https://issues.scala-lang.org/browse/SI-7336\\\">SI-7336</a></p>\\n<h3>对比</h3>\\n<p>从上面的两种实现来看，从执行时间上，两种方式没有太大差异，但是指令式编程在内存占用方面要优于函数式编程，毕竟var变量可以复用，val变量需要重新生成。但是差别并没有想象中那么大，处理一个4G的文件，差别只是40M左右。但是带来的好处是显而易见的：因为没有mutable变量，没有副作用，并发、代码可读性有提高。</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Enumerator-Iteratee-Enumeratee.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-11T14:16:45.000Z\",\"path\":\"/2013/enumerator-iteratee-enumeratee\",\"title\":\"Enumerator / Iteratee / Enumeratee\",\"excerpt\":\"Stream对于指令式编程已经比较成熟了，有大量的类库，丰富的API。但是对于强调不可变量，尽可能无副作用的FP来说，要考虑语言适配的问题，而目前，流行的解决方案就是：Enumerator/Iteratee。\",\"tags\":[\"scala\",\"playframework\",\"blog\"]}}},{\"node\":{\"html\":\"<p>Markdown是一个很爽的写作格式（或者说语言更合适一点），我们不再需要复杂的富文本编辑器，用纯文本就可以编写出布局漂亮的文章。</p>\\n<p>不过Markdown对于技术类文章来说还有一个不足：我们经常需要画一些图来阐述自己的思路，但是Markdown只能引用已经存在的图。</p>\\n<p>有没有可能用Plain Text来画图呢？AscII艺术图？太原始了。试试PlantUML吧。</p>\\n<h2>PlantUML介绍</h2>\\n<p>从某个角度说，<a href=\\\"http://plantuml.sourceforge.net\\\">PlantUML</a>简直就是Markdown的绝配，也只需要纯文本就可以实现漂亮的效果，只是这里变成更炫的UML图。</p>\\n<p>比如我想画一个类图，Cat和Dog继承Animal，用PlantUML来实现就是：</p>\\n<pre><code>@startuml\\nAnimal &#x3C;|-- Cat\\nAnimal &#x3C;|-- Dog\\n@enduml\\n</code></pre>\\n<p>是不是很简单？来看看效果：</p>\\n<!-- language:uml -->\\n<pre><code>Animal &#x3C;|-- Cat\\nAnimal &#x3C;|-- Dog\\n</code></pre>\\n<p>怎么样？不错吧，这个图片哪里来的？其实在我发布这篇文章的时候，这个类图还不存在，只有在你访问这篇文章的时候才自动生成的。PlantUML有一个jQuery插件，可以在运行时生成图片。</p>\\n<p>PlantUML的jQuery插件用法很简单，你只需要在html中编辑：</p>\\n<!-- language:lang-html -->\\n<pre><code>&#x3C;img uml=\\\"\\n  Animal &#x3C;|-- Cat\\n  Animal &#x3C;|-- Dog\\n\\\">\\n</code></pre>\\n<p>jQuery插件会自动增强这个img元素，具体实现还挺有意思，这里不细说了。</p>\\n<p>可这还不够，怎么在Markdown中写<code>img</code>呢？如果你照抄上面的img代码，pegdown解析器会抛错，'&#x3C;'不匹配云云。</p>\\n<h2>解决方案</h2>\\n<p>基本上这种问题可以从两个方面想办法，一个是服务器端，实现一个markdown parser plugin，来定制一个特殊语法，另一个方向是从浏览器端想办法。</p>\\n<p>从上面的介绍中我们知道，已经有jQuery插件了，那从前端做似乎更加容易一些。此外，从<a href=\\\"http://www.learn-scala.net/blogs/2013-11-01_14.md\\\">上一篇</a>我们已经知道，在<code>pre code</code>前面加上一个<code>&#x3C;!-- language:lang-scala --></code>来实现语法高亮显示问题。</p>\\n<p>PlantUML的内容也可以认为是一种code，很自然地，我们可以用<code>pre code</code>来封装。比如我们可以用：</p>\\n<!-- language:lang-html -->\\n<pre><code>&#x3C;!-- language:uml -->\\n    Animal &#x3C;|-- Cat\\n    Animal &#x3C;|-- Dog\\n</code></pre>\\n<p>这里我们自定义了一种language类型<code>uml</code>，在前端解析的时候，就能知道这个代码块是用来画图的了。</p>\\n<p>好，我们来看前端JS代码的实现：</p>\\n<!-- language:lang-javascript -->\\n<pre><code>function init() {\\n  var plantuml = false;\\n  var blocks = document.querySelectorAll('pre code');\\n  // 遍历所有pre code\\n  for (var i = 0; i &#x3C; blocks.length; i += 1) {\\n    var code = blocks[i];\\n    //code.className += ' prettyprint';\\n    var pre = code.parentNode;\\n    var above = pre;\\n    do {\\n      above = above.previousSibling;\\n    } while (above.nodeType == Node.TEXT_NODE)\\n    // 检查注释元素据\\n    if (above.nodeType == Node.COMMENT_NODE) {\\n      var comment = above.data;\\n      // 正则表达式，获取语言类型\\n      var pattern = /^\\\\s*language:\\\\s*([\\\\w\\\\-]+)\\\\s*(\\\\w+)?\\\\s*$/i;\\n      var match = pattern.exec(comment);\\n      if (match != null) {\\n        var lang = match[1];\\n        // 如果是uml，动态生成一个img元素，并设置uml属性值为pre code的内容。\\n        if (lang &#x26;&#x26; lang == \\\"uml\\\") {\\n          var container = document.createElement(\\\"div\\\");          \\n          var img = document.createElement(\\\"img\\\");\\n          img.setAttribute(\\\"uml\\\", code.innerText || code.textContent);\\n\\n          container.appendChild(img);\\n          container.className = \\\"text-center\\\";\\n\\n          pre.insertAdjacentElement('afterEnd', container);\\n          // 将pre code隐藏起来，只显示图片\\n          pre.style.display = \\\"none\\\";\\n          plantuml = true;\\n        }\\n      }\\n    }\\n  }\\n  // 调用jQuery插件生成图片。\\n  if (plantuml) {\\n    plantuml_runonce();\\n  }\\n}\\n</code></pre>\\n<p>然后，在html中调用：</p>\\n<!-- language:lang-html -->\\n<pre><code>&#x3C;script type='text/javascript'>\\n  window.onload = init;    \\n&#x3C;/script>  \\n</code></pre>\\n<p>搞定，收工！！写作、布局编排、画图全部纯文本，爽！</p>\\n<p>附上一个PlantUML的参考文档，原本上sourceforge网站就可以了，可惜被墙了，点击<a href=\\\"http://www.learn-scala.net/assets/ebooks/PlantUML_Language_Reference_Guide.pdf.zip\\\">这里</a>下载吧。</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/集成PlantUML和Markdown.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-07T19:16:45.000Z\",\"path\":\"/2013/markdown-plantuml-integration\",\"title\":\"边建边学-2：集成PlantUML和Markdown\",\"excerpt\":\"如何用Markdown+PlantUML结合来写图文并茂的博客。\",\"tags\":[\"markdown\",\"plantuml\",\"blog\"]}}},{\"node\":{\"html\":\"<h2>Play!框架的核心</h2>\\n<p>Play!的内核其实非常简单，简单地说，Play框架所实现的可以用一个函数表达式来描述：</p>\\n<p><code>RequestHeader -> Array[Byte] -> Result</code></p>\\n<p>具体讲，就是接受一个<code>RequestHeader</code>，然后读入类型为<code>Array[Byte]</code>的Request Body，计算完毕之后返回一个<code>Result</code>。</p>\\n<p>注：函数式语言的表达就是高度抽象，但异常简洁。</p>\\n<h2>问题及优化</h2>\\n<h3>文件上传</h3>\\n<p>上面的描述有一个问题：我们假定要把请求内容<em>全部</em>读入内存（或者写入磁盘），对于简单应用不是什么问题，但是对于文件上传等场景，这肯定是有问题的，所以，Play开发者做了优化。</p>\\n<p>注：此处可以看出函数式语言的一个优点：仅需要了解你的函数定义，就能分析出潜在的问题。而如果面向对象的方式一般关注在对象之间的通信、方法调用，从方法签名上往往会忽略这些细节。</p>\\n<p>优化的思路当然是将请求内容一部分一部分地读入（chunk），所以这个函数就变成了：</p>\\n<p><code>RequestHeader -> Iteratee[Array[Byte], Result]</code></p>\\n<p><code>Iteratee</code>是个什么东东？简单讲就是一个<code>Monad</code>，什么是Monad？可以类比为OO世界中的设计模式：专门为了解决某类问题的特定方法。Iteratee可以将输入（Input）分步(Step)读入，而且可以进行精细控制遇到EOF、Empty、El(chunk)的时候应该如何处理，是继续（Cont），结束（Done）还是抛错（Error）。这里不做详细介绍。有兴趣的可以参见：<a href=\\\"http://apocalisp.wordpress.com/2010/10/17/scalaz-tutorial-enumeration-based-io-with-iteratees/\\\">这篇博客</a></p>\\n<p>Iteratee本身也是一个<code>Arrow</code>（简单理解为函数），所以如果我们定义一个新类型：</p>\\n<!-- language:lang-scala -->\\n<pre><code>type ==>[E, R] = Iteratee[E, R]\\n</code></pre>\\n<p>上面的函数用scala来写就会变为：</p>\\n<!-- language:lang-scala -->\\n<pre><code>RequestHeader => Array[Byte] ==> Result\\n</code></pre>\\n<p>注：<code>==>[E, R]</code>和<code>E ==> R</code>是等价的，是scala的一个语法糖。</p>\\n<p>上面的表达式看上去更简洁，更有趣了。</p>\\n<h3>文件下载</h3>\\n<p>有了<code>Iteratee</code>我们就可以分块处理请求了，但是响应呢？同样地，如果响应中的数据量很大，比如文件下载，从上面的函数定义看，依旧会把文件完全读入到内存中，同样的问题。</p>\\n<p>解决的思路也是一样的。我们可以将<code>Result</code>看做下面的数据结构：</p>\\n<!-- language:lang-scala -->\\n<pre><code>case class Result(header: ResponseHeader, body: Array[Byte])\\n</code></pre>\\n<p>问题主要在<code>body</code>上，类型是Array[Byte]，需要有一个新的数据类型将起封装，可以分块地处理输出内容，这就是<code>Enumerator</code>，一个用来将响应数据分块(chunk)的东东。</p>\\n<p>所以最终Play框架核心可以看做下面的API：</p>\\n<!-- language:lang-scala -->\\n<pre><code>case class Result[E](headers:ResponseHeaders, body:Enumerator[E])(implicit writeable:Writeable[E])\\ntype ==>[E, R] = Iteratee[E, R]\\nRequestHeader => Array[Byte] ==> Result\\n</code></pre>\\n<p>下面我们来看看Request和Result各自的类图，了解一下都有哪些实现。</p>\\n<!-- language:uml -->\\n<pre><code>title Request Class Hierarchy\\nclass RequestHeader &#x3C;&#x3C; (T, #00FF00)>>\\nclass Request &#x3C;&#x3C; (T, #00FF00)>>\\n\\nRequestHeader &#x3C;|-- Request\\nRequest &#x3C;|-- WrappedRequest\\nRequest &#x3C;|-- FakeRequest\\nWrappedRequest &#x3C;|-- AuthenticatedRequest\\n\\ncenter footer 图一：Request 类图\\n</code></pre>\\n<p>真简单啊，比OO世界里面的一些MVC框架中的类层次结构少多了。</p>\\n<!-- language:uml -->\\n<pre><code>title Result Class Hierarchy\\nclass WithHeaders &#x3C;&#x3C; (T, #00FF00) >>\\nclass Result &#x3C;&#x3C; (T, #00FF00) >>\\n\\nclass PlainResult &#x3C;&#x3C; (T, #FF0000) deprecated>>\\nclass AsyncResult &#x3C;&#x3C; (C, #FF0000) deprecated>>\\nclass ChunkedResult &#x3C;&#x3C; (D, #FF0000) deprecated>>\\n\\nWithHeaders &#x3C;|-- Result\\nResult &#x3C;|-- PlainResult\\nResult &#x3C;|-- AsyncResult\\nPlainResult &#x3C;|-- SimpleResult\\nSimpleResult &#x3C;|-- ChunkedResult\\nSimpleResult &#x3C;|-- Status\\n\\ncenter footer 图二：Result 类图\\n</code></pre>\\n<p>目前Play2.2中Result有两个子类：PlainResult和AsyncResult，但这两个Result已经被标记为deprecated了，从2.3开始，Play将只支持SimpleResult。为什么呢？ 想想其实很简单：单一职责原则。所谓<code>AsyncResult</code>其实本身职责不单一，有异步和Result两个，而直接使用：<code>Future[SimpleResult]</code>则清晰很多。另外ChunkedResult被废弃的原因也一样。</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/EssentialAction-in-Playframework.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-05T09:16:45.000Z\",\"path\":\"/2013/essential-action-in-play\",\"title\":\"EssentialAction in Playframework\",\"excerpt\":\"Playframework中EssentialAction理解\",\"tags\":[\"scala\",\"playframework\"]}}},{\"node\":{\"html\":\"<p>本文将是一个系列文章，循序渐进地介绍本站的构建过程，不只是简单的技术介绍，重点是建站过程遇到的问题分析，以及解决的过程，所以起名<strong>“边建边学”</strong>系列。</p>\\n<p>希望对学习<code>Scala</code>+<code>Playframework</code>的童鞋有所启发。</p>\\n<p>本篇重点介绍如何用markdown来写技术文章，以及如何优化代码片段。</p>\\n<h2>需求</h2>\\n<ul>\\n<li>用markdown来写博客，对不同代码类型能够进行美化</li>\\n<li>技术博客一般会在文中包含部分代码片段，在看文章的时候，如果能运行一下这个代码片段，看看执行结果是什么，会对理解技术有所帮助，所以这里需要一个Web REPL (Read Eval Print Loop)</li>\\n<li>博文列表中只显示博文头</li>\\n</ul>\\n<h2>实现</h2>\\n<h3>markdown</h3>\\n<p>用Markdown写文章的流程是这样的：</p>\\n<ol>\\n<li>\\n<p>在本地创建md文件，用markdown语法写文章</p>\\n<p>markdown语法不是本文的介绍重点，需要温习的童鞋请查看<a href=\\\"http://zh.wikipedia.org/zh-cn/Markdown\\\">维基百科</a>，编辑工具可以考虑使用：<a href=\\\"http://mouapp.com\\\">Mou</a>，或者chrome插件stackedit。</p>\\n</li>\\n<li>\\n<p>将文章发布到网站。</p>\\n<p>发布的最终目的是将文章上传到网站，可以是存到数据库中，可以是上传为一个文件，因为文章的特殊性，创作过程需要跟踪记录，而且md文章本身也是一个文件，所以直接将文件上传搞定。</p>\\n<p>具体上传途径是通过git。其实从版本管理的角度，md文件和其他源代码文件没有什么不同。</p>\\n</li>\\n<li>\\n<p>mardkown解析成为HTML</p>\\n<p>这个解析有两种选择，一个是在服务器端解析，另外一个是在浏览器端通过javascript来解析。个人觉得没有太大不同，这里选择一个github上开源的工具来实现：<a href=\\\"https://github.com/sirthias/pegdown\\\">Pegdown</a>。</p>\\n<p>具体代码非常简单：</p>\\n</li>\\n</ol>\\n<!-- language:lang-scala -->\\n<pre><code>val processor = new PegDownProcessor()\\nval markdownContent = \\\"##title2\\\\n*item1\\\"\\nval htmlContent = processor.markdownToHtml(markdownContent)\\n</code></pre>\\n<ol start=\\\"4\\\">\\n<li>\\n<p>代码美化</p>\\n<p>将MD转换为html之后，代码片段只是被转换为：<code>&#x3C;pre>&#x3C;code> .... &#x3C;/code>&#x3C;/pre></code>，但是如何按照相应语言的语法进行高亮显示呢？其实任何Web效果的东西都没有什么神秘的，只是应用CSS而已。</p>\\n<p>这里我们选用的是<a href=\\\"https://code.google.com/p/google-code-prettify/\\\">prettify.js</a>，当然，还可以选择其他方案，比如<a href=\\\"http://highlightjs.org\\\">highlight.js</a>.</p>\\n<p>具体方案如下：</p>\\n</li>\\n</ol>\\n<!-- language:lang-javascript -->\\n<pre><code>&#x3C;script type='text/javascript'>\\n    function init() {\\n        var prettify = false;\\n        var blocks = document.querySelectorAll('pre code')\\n        for (var i = 0; i &#x3C; blocks.length ; i++) {\\n            blocks[i].className += 'prettyprint';\\n            prettify = true;\\n        }\\n        if (prettify) {\\n          prettyPrint();\\n        }\\n    }\\n    window.onload = init;\\n&#x3C;/script>\\n</code></pre>\\n<p>简单说，就是在页面（dom）加载完成之后，查找所有的pre+code元素，然后给该元素class添加<code>prettyprint</code>，这样有了预定义的样式表，代码语法高亮特性就实现了。\\n<br>\\n代码片段执行的部分将有专门的章节介绍，此处略过。\\n</p>\\n<h3>博文列表只显示文章头</h3>\\n<p>在列表页面，将在一个页面列出大量的内容，如果将每篇文章都完整地列出来，那么页面将变得很长，而且也不方便用户查找，而如果能够只显示文章的开头部分，就可以让读者快速地了解文章大致内容，并且快速浏览近期文章，有选择性地查看文章。</p>\\n<p>这个说起来其实很简单，展示部分内容逻辑上也很简单，只是简单截取文章开头的前N个字符而已。总体上是这个思路，可实际上会比这个稍微复杂一些。原因在于博文不是简单的plain text，而是HTML代码，如果只简单截取前面N个字符，极有可能会造成HTML片段不完整导致页面错误。</p>\\n<p>知道问题所在之后，解决办法其实也就简单了。我们可以简单分析一下markdown转换为html之后的代码结构，比如：</p>\\n<!-- language:lang-html -->\\n<pre><code>&#x3C;h1>手工打造博客站点-1: 用Markdown写博文&#x3C;/h1>\\n&#x3C;p>本文将是一个系列文章，循序渐进地介绍本站的构建过程，不只是简单的技术介绍，重点是建站过程遇到的问题分析，以及解决的过程。&#x3C;/p>\\n&#x3C;p>希望对学习&#x3C;code>Scala&#x3C;/code>+&#x3C;code>Playframework&#x3C;/code>的童鞋有所启发。&#x3C;/p>\\n&#x3C;p>本篇重点介绍如何用markdown来写技术文章，以及如何优化代码片段。&#x3C;/p>\\n&#x3C;h2>需求&#x3C;/h2>\\n……\\n</code></pre>\\n<p>很明显，标题、段落等html元素都是同级的，所以我们只需要一次计算每个html元素所包含内容的长度，当叠加到超过阀值时，将前面元素内容输出就好了。具体的办法是：先将html字符串解析为XML DOM，然后迭代每个一级children节点。</p>\\n<!-- language:lang-scala -->\\n<pre><code>val content = Source.fromFile(file, \\\"UTF-8\\\", 1024).mkString\\nval htmlContent = \\\"&#x3C;article>\\\" + processor.markdownToHtml(content) + \\\"&#x3C;/article>\\\"\\n// only show part of the article\\nval xml = scala.xml.XML.loadString(htmlContent)\\nvar i: Long = 0L\\nval elemList = xml.child.takeWhile( el => { i += el.toString().length; i &#x3C; ConfigUtils.BLOG_HEAD_LENGTH } )\\nval part = \\\"&#x3C;article>\\\" + elemList.mkString + s\\\"\\\"\\\"&#x3C;p>&#x3C;a href=\\\"/blogs/${file.getName}\\\">[...]&#x3C;/a>&#x3C;/p>&#x3C;/article>\\\"\\\"\\\"\\n</code></pre>\\n<p>备注：</p>\\n<ul>\\n<li>在转换为html之后，需要在外面包一个<code>&#x3C;article></code>容器元素。</li>\\n<li>从一个Seq容器元素中截取前面部分元素用<code>takeWhile</code>，此处有一个<code>var</code>可变参数的使用，其实也可以不用，只是用在这里容易一些。</li>\\n<li>在最后添加一个指向文章全文的链接。</li>\\n</ul>\\n<h2>预告</h2>\\n<p>下篇，将介绍如何将网页中的代码片段提交到服务器端执行并返回执行结果，也就是Web GUI REPL，敬请关注。</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/用markdown写博客.markdown absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-01T14:06:45.000Z\",\"path\":\"/2013/blogging-with-markdown\",\"title\":\"边建边学-1: 用Markdown写博文\",\"excerpt\":\"本文将是一个系列文章，循序渐进地介绍本站的构建过程，不只是简单的技术介绍，重点是建站过程遇到的问题分析，以及解决的过程，所以起名**“边建边学”**系列。\",\"tags\":[\"markdown\",\"blog\"]}}},{\"node\":{\"html\":\"<h2>引子</h2>\\n<p>从有了博客这个东西开始，就一直开始找各种好用的博客站点，csdn、新浪、搜狐、博客大巴、点点、google site、Github，甚至自己定制内容管理系统（CMS）Liferay，来建立自己的博客站点。免费的、收费的，都尝试了，可总觉得这里或者那里有点不满意。</p>\\n<p>所以就有一个小心愿能实现一个自己喜欢的站点。</p>\\n<p>这个站点应该可以：</p>\\n<ul>\\n<li>用比较“极客”的方式来写，符合我们这种工科IT男的作风。</li>\\n<li>可以很灵活地定制，想加什么功能就加什么功能。</li>\\n<li>最好有个主题，不是一个记流水账的地方。</li>\\n</ul>\\n<p>近来学习scala这门语言，对于我这个多年在OO世界中打拼的程序员在思维方式上的触动很大，有了找一个地方写一些关于scala学习方面的专题文章。</p>\\n<p>两者一结合，就有了这个网站。</p>\\n<h2>站点简介</h2>\\n<p>这个网站是用下列技术构建的：</p>\\n<ul>\\n<li>Scala</li>\\n<li>Playframework</li>\\n<li>Markdown</li>\\n<li>Websockets</li>\\n<li>Redis</li>\\n<li>MongoDB</li>\\n<li>Twitter Bootstrap</li>\\n</ul>\\n<p>运行在Heroku上，除了域名，一切免费。</p>\\n<h2>博客内容预告</h2>\\n<p>这一系列文章将包括，但不限于：</p>\\n<ul>\\n<li>\\n<p>构建本站技术介绍\\n如何一步一步地搭建一个完整的网站。</p>\\n</li>\\n<li>\\n<p>Scala语言特性</p>\\n</li>\\n<li>\\n<p>一些Scala世界的常用工具，比如Akka、Scalaz的介绍等等。</p>\\n</li>\\n</ul>\\n<p>你可以方便地在网站上直接测试一些小的代码，比如：</p>\\n<!-- language:lang-scala run -->\\n<pre><code>val i = 10\\nprintln(i + 2)\\nval j = 10\\nprintln(j - i)\\n</code></pre>\\n<p>点击<code>Run</code>你就能看到执行结果。</p>\\n<h2>TODO LIST</h2>\\n<ul>\\n<li>简单的搜索</li>\\n<li>分页</li>\\n<li>评论功能</li>\\n</ul>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/开篇.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-10-25T17:06:45.000Z\",\"path\":\"/2013/start\",\"title\":\"开篇\",\"excerpt\":\"网络博客\",\"tags\":[]}}}],\"pathPrefix\":\"/\",\"first\":false,\"last\":true,\"index\":2,\"pageCount\":2}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/2.json\n// module id = 341\n// module chunks = 157285553617042"],"sourceRoot":""}