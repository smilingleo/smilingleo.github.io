{"version":3,"sources":["webpack:///path---3-e35ffe9ef2b199f82bb7.js","webpack:///./.cache/json/3.json"],"names":["webpackJsonp","402","module","exports","data","allMarkdownRemark","totalCount","edges","node","id","frontmatter","title","date","path","tags","excerpt","pathContext","group","html","pathPrefix","first","last","index","pageCount"],"mappings":"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","file":"path---3-e35ffe9ef2b199f82bb7.js","sourcesContent":["webpackJsonp([182981024786761],{\n\n/***/ 402:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"allMarkdownRemark\":{\"totalCount\":22,\"edges\":[{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/微服务架构下的开发环境问题.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"微服务架构下的开发环境问题\",\"date\":\"March 16, 2018\",\"path\":\"/2018/development-environment-for-microservices\",\"tags\":[\"微服务\",\"架构\",\"开发环境\",\"microservices\"],\"excerpt\":\"本文介绍如何在微服务架构下解决开发环境的搭建、共享的问题。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/为Gatsby博客添加分页功能.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"为Gatsby博客添加分页功能\",\"date\":\"March 12, 2018\",\"path\":\"/2018/support-pagination-for-gatsby-blog\",\"tags\":[\"blog\",\"gatsby\"],\"excerpt\":\"根据Egghead上的教程，做出的博客站点有个缺陷，那就是没有分页功能，对于勤奋的博主来说，在一个页面上显示所有文章列表有点不完美，这里我们改造一下，加入分页功能。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/为你的Gatsby博客添加评论功能.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"为你的Gatsby博客添加评论功能\",\"date\":\"March 12, 2018\",\"path\":\"/2018/enable-comments-for-gatsby-blog\",\"tags\":[\"blog\"],\"excerpt\":\"Gatsby打造的博客已经很不错了，但是缺少一个评论功能。本文简单介绍如何集成Disqus评论服务到你的博客站点。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/转用Gatsby搭建博客.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"转用Gatsby打造基于github的博客站点\",\"date\":\"March 08, 2018\",\"path\":\"/2018/blog-with-gatsby\",\"tags\":[\"blog\",\"github\",\"gatsby\"],\"excerpt\":\"如何用Gatsby打造一个博客\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/一则奇怪的Toubleshooting.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"记一次奇怪的troubleshooting\",\"date\":\"March 08, 2018\",\"path\":\"/2018/skipper-sni-domain-fronting\",\"tags\":[\"skipper\",\"SNI\",\"domain fronting\"],\"excerpt\":\"在Skipper转发请求到一个https站点的时候，返回莫名404.\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2016/JSON解析利器JQ.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"JSON解析利器---JQ\",\"date\":\"March 25, 2016\",\"path\":\"/2013/jq\",\"tags\":[\"bash\",\"jq\",\"json\"],\"excerpt\":\"在API first的时代，json作为最常用的格式，充斥着程序猿的屏幕各个角落，掌握一门解析、过滤、转换json输出的工具，已经成为程序猿们安身立命的必要技能。 这里隆重向大家介绍[jq](https://stedolan.github.io/jq/).\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2016/Function的协变.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Function的协、逆变\",\"date\":\"February 04, 2016\",\"path\":\"/2016/function-covariant-contravariant\",\"tags\":[\"scala\",\"functional programming\"],\"excerpt\":\"泛型编程的时候，协变(covariant)还是逆变(contravariant)很重要，在设计上层API接口的时候，正确的使用协变、逆变可以更好地约束程序员的行为，让实现变得安全、一致。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/如何在Scala中实现AOP.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"用Mixin组合实现Scala中的AOP\",\"date\":\"August 13, 2015\",\"path\":\"/2015/aop-by-mixin-in-scala\",\"tags\":[\"scala\",\"functional programming\",\"AOP\",\"mixin\"],\"excerpt\":\"在Java世界，AOP（Aspect Oriented Programming， 面向方面编程)是很多框架的基础。这种将关注点按照“方面”来切分的编程模型极大地简化了编程的复杂度，尤其是在多维度因子交织在一起的时候的各种场景。对于代码的可读性、可维护性、可重用性都是极大的帮助。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Scala雾里看花.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Scala雾里看花\",\"date\":\"April 23, 2015\",\"path\":\"/2015/scala-trouble-shooting\",\"tags\":[\"scala\",\"trouble shooting\"],\"excerpt\":\"Scala的学习过程中，经常会碰到一些莫名其妙的现象，很多时候，这些语言层面的“怪象”都与scala编译器或者scala的类型系统有关。本文不是对编译器和类型系统的介绍，而是重点介绍遇到这些现象的时候，用什么样的方式，拨开云雾见蓝天，通过这些工具获取一些细节帮你了解编译器和类型系统如何工作。工欲善其事，必先利其器。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Docker创建MySQL主从复制以及CDC测试.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"MySQL Master/Slave Replication on Docker\",\"date\":\"April 21, 2015\",\"path\":\"/2015/mysql-replication-on-docker\",\"tags\":[\"docker\",\"mysql\"],\"excerpt\":\"How to setup Mysql master/slave replication.\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2014/Scala函数式异常处理.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Scala函数式异常处理\",\"date\":\"May 04, 2014\",\"path\":\"/2014/scala-error-handling-in-fp-style\",\"tags\":[\"scala\",\"functional programming\",\"exception handling\"],\"excerpt\":\"经常看到很多示例代码，简洁的让人爱不释手，可是真正自己实现的时候，不得不添加各种各样的异常处理逻辑，最后发现代码总量的80%都是再做异常处理，而真正的代码逻辑只有很少的一部分。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2014/高种泛型.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"高种泛型 (Generics of a Higher Kind)\",\"date\":\"January 08, 2014\",\"path\":\"/2014/generics-of-a-higher-kind\",\"tags\":[\"scala\",\"functional programming\",\"Generics\"],\"excerpt\":\"Generics of a Higher Kind翻译加自我理解。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/map-flatMap-for.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"map/flatMap/for in Action\",\"date\":\"December 01, 2013\",\"path\":\"/2013/map-flatmap-for\",\"tags\":[\"scala\",\"functional programming\"],\"excerpt\":\"前文说过了，高阶函数式函数式语言中的基石，而`map`, `flatMap`更是重要。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/fold编程.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"折纸的艺术：fold编程\",\"date\":\"November 27, 2013\",\"path\":\"/2013/fold\",\"tags\":[\"scala\",\"functional programming\",\"fold\"],\"excerpt\":\"Eric Meijer说：递归是函数式编程的GOTO，应该尽可能避免。如何避免，OO中我们用while循环，FP中我们用`fold`。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Monad.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Monad\",\"date\":\"November 26, 2013\",\"path\":\"/2013/monad\",\"tags\":[\"scala\",\"functional programming\",\"monad\"],\"excerpt\":\"函数式语言与OO（确切地讲是指令式编程）的思维方式是完全不同的，很多OO中的经验在函数式语言中不是很匹配，比如设计模式，那就是一个OO中的特定术语，而在FP中，大家常谈的是对于习惯OO思维的程序员来说玄而又玄的Monad。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/高阶函数.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"高阶函数\",\"date\":\"November 21, 2013\",\"path\":\"/2013/high-order-function\",\"tags\":[\"scala\",\"functional programming\",\"high order function\"],\"excerpt\":\"所谓高阶函数（high order function），其实就是可以接受其他函数作为参数的函数。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Actor协调并发场景下的集合操作.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"边建边学-3：Actor协调并发场景下的集合操作\",\"date\":\"November 17, 2013\",\"path\":\"/2013/actor-collection-collabration\",\"tags\":[\"scala\",\"functional programming\"],\"excerpt\":\"很多时候为了提高性能，减少IO操作，都会将数据load出来之后缓存在内存中。本站的实现过程中也遇到类似的问题，不希望每次有人访问的时候就读取一次md文件，或者从MongoDB中查一次，而是直接在内存中读取。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Enumerator-Iteratee-Enumeratee.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Enumerator / Iteratee / Enumeratee\",\"date\":\"November 11, 2013\",\"path\":\"/2013/enumerator-iteratee-enumeratee\",\"tags\":[\"scala\",\"playframework\",\"blog\"],\"excerpt\":\"Stream对于指令式编程已经比较成熟了，有大量的类库，丰富的API。但是对于强调不可变量，尽可能无副作用的FP来说，要考虑语言适配的问题，而目前，流行的解决方案就是：Enumerator/Iteratee。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/集成PlantUML和Markdown.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"边建边学-2：集成PlantUML和Markdown\",\"date\":\"November 07, 2013\",\"path\":\"/2013/markdown-plantuml-integration\",\"tags\":[\"markdown\",\"plantuml\",\"blog\"],\"excerpt\":\"如何用Markdown+PlantUML结合来写图文并茂的博客。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/EssentialAction-in-Playframework.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"EssentialAction in Playframework\",\"date\":\"November 05, 2013\",\"path\":\"/2013/essential-action-in-play\",\"tags\":[\"scala\",\"playframework\"],\"excerpt\":\"Playframework中EssentialAction理解\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/用markdown写博客.markdown absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"边建边学-1: 用Markdown写博文\",\"date\":\"November 01, 2013\",\"path\":\"/2013/blogging-with-markdown\",\"tags\":[\"markdown\",\"blog\"],\"excerpt\":\"本文将是一个系列文章，循序渐进地介绍本站的构建过程，不只是简单的技术介绍，重点是建站过程遇到的问题分析，以及解决的过程，所以起名**“边建边学”**系列。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/开篇.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"开篇\",\"date\":\"October 25, 2013\",\"path\":\"/2013/start\",\"tags\":[],\"excerpt\":\"网络博客\"}}}]}},\"pathContext\":{\"group\":[{\"node\":{\"html\":\"<p>本文将是一个系列文章，循序渐进地介绍本站的构建过程，不只是简单的技术介绍，重点是建站过程遇到的问题分析，以及解决的过程，所以起名<strong>“边建边学”</strong>系列。</p>\\n<p>希望对学习<code>Scala</code>+<code>Playframework</code>的童鞋有所启发。</p>\\n<p>本篇重点介绍如何用markdown来写技术文章，以及如何优化代码片段。</p>\\n<h2>需求</h2>\\n<ul>\\n<li>用markdown来写博客，对不同代码类型能够进行美化</li>\\n<li>技术博客一般会在文中包含部分代码片段，在看文章的时候，如果能运行一下这个代码片段，看看执行结果是什么，会对理解技术有所帮助，所以这里需要一个Web REPL (Read Eval Print Loop)</li>\\n<li>博文列表中只显示博文头</li>\\n</ul>\\n<h2>实现</h2>\\n<h3>markdown</h3>\\n<p>用Markdown写文章的流程是这样的：</p>\\n<ol>\\n<li>\\n<p>在本地创建md文件，用markdown语法写文章</p>\\n<p>markdown语法不是本文的介绍重点，需要温习的童鞋请查看<a href=\\\"http://zh.wikipedia.org/zh-cn/Markdown\\\">维基百科</a>，编辑工具可以考虑使用：<a href=\\\"http://mouapp.com\\\">Mou</a>，或者chrome插件stackedit。</p>\\n</li>\\n<li>\\n<p>将文章发布到网站。</p>\\n<p>发布的最终目的是将文章上传到网站，可以是存到数据库中，可以是上传为一个文件，因为文章的特殊性，创作过程需要跟踪记录，而且md文章本身也是一个文件，所以直接将文件上传搞定。</p>\\n<p>具体上传途径是通过git。其实从版本管理的角度，md文件和其他源代码文件没有什么不同。</p>\\n</li>\\n<li>\\n<p>mardkown解析成为HTML</p>\\n<p>这个解析有两种选择，一个是在服务器端解析，另外一个是在浏览器端通过javascript来解析。个人觉得没有太大不同，这里选择一个github上开源的工具来实现：<a href=\\\"https://github.com/sirthias/pegdown\\\">Pegdown</a>。</p>\\n<p>具体代码非常简单：</p>\\n</li>\\n</ol>\\n<!-- language:lang-scala -->\\n<pre><code>val processor = new PegDownProcessor()\\nval markdownContent = \\\"##title2\\\\n*item1\\\"\\nval htmlContent = processor.markdownToHtml(markdownContent)\\n</code></pre>\\n<ol start=\\\"4\\\">\\n<li>\\n<p>代码美化</p>\\n<p>将MD转换为html之后，代码片段只是被转换为：<code>&#x3C;pre>&#x3C;code> .... &#x3C;/code>&#x3C;/pre></code>，但是如何按照相应语言的语法进行高亮显示呢？其实任何Web效果的东西都没有什么神秘的，只是应用CSS而已。</p>\\n<p>这里我们选用的是<a href=\\\"https://code.google.com/p/google-code-prettify/\\\">prettify.js</a>，当然，还可以选择其他方案，比如<a href=\\\"http://highlightjs.org\\\">highlight.js</a>.</p>\\n<p>具体方案如下：</p>\\n</li>\\n</ol>\\n<!-- language:lang-javascript -->\\n<pre><code>&#x3C;script type='text/javascript'>\\n    function init() {\\n        var prettify = false;\\n        var blocks = document.querySelectorAll('pre code')\\n        for (var i = 0; i &#x3C; blocks.length ; i++) {\\n            blocks[i].className += 'prettyprint';\\n            prettify = true;\\n        }\\n        if (prettify) {\\n          prettyPrint();\\n        }\\n    }\\n    window.onload = init;\\n&#x3C;/script>\\n</code></pre>\\n<p>简单说，就是在页面（dom）加载完成之后，查找所有的pre+code元素，然后给该元素class添加<code>prettyprint</code>，这样有了预定义的样式表，代码语法高亮特性就实现了。\\n<br>\\n代码片段执行的部分将有专门的章节介绍，此处略过。\\n</p>\\n<h3>博文列表只显示文章头</h3>\\n<p>在列表页面，将在一个页面列出大量的内容，如果将每篇文章都完整地列出来，那么页面将变得很长，而且也不方便用户查找，而如果能够只显示文章的开头部分，就可以让读者快速地了解文章大致内容，并且快速浏览近期文章，有选择性地查看文章。</p>\\n<p>这个说起来其实很简单，展示部分内容逻辑上也很简单，只是简单截取文章开头的前N个字符而已。总体上是这个思路，可实际上会比这个稍微复杂一些。原因在于博文不是简单的plain text，而是HTML代码，如果只简单截取前面N个字符，极有可能会造成HTML片段不完整导致页面错误。</p>\\n<p>知道问题所在之后，解决办法其实也就简单了。我们可以简单分析一下markdown转换为html之后的代码结构，比如：</p>\\n<!-- language:lang-html -->\\n<pre><code>&#x3C;h1>手工打造博客站点-1: 用Markdown写博文&#x3C;/h1>\\n&#x3C;p>本文将是一个系列文章，循序渐进地介绍本站的构建过程，不只是简单的技术介绍，重点是建站过程遇到的问题分析，以及解决的过程。&#x3C;/p>\\n&#x3C;p>希望对学习&#x3C;code>Scala&#x3C;/code>+&#x3C;code>Playframework&#x3C;/code>的童鞋有所启发。&#x3C;/p>\\n&#x3C;p>本篇重点介绍如何用markdown来写技术文章，以及如何优化代码片段。&#x3C;/p>\\n&#x3C;h2>需求&#x3C;/h2>\\n……\\n</code></pre>\\n<p>很明显，标题、段落等html元素都是同级的，所以我们只需要一次计算每个html元素所包含内容的长度，当叠加到超过阀值时，将前面元素内容输出就好了。具体的办法是：先将html字符串解析为XML DOM，然后迭代每个一级children节点。</p>\\n<!-- language:lang-scala -->\\n<pre><code>val content = Source.fromFile(file, \\\"UTF-8\\\", 1024).mkString\\nval htmlContent = \\\"&#x3C;article>\\\" + processor.markdownToHtml(content) + \\\"&#x3C;/article>\\\"\\n// only show part of the article\\nval xml = scala.xml.XML.loadString(htmlContent)\\nvar i: Long = 0L\\nval elemList = xml.child.takeWhile( el => { i += el.toString().length; i &#x3C; ConfigUtils.BLOG_HEAD_LENGTH } )\\nval part = \\\"&#x3C;article>\\\" + elemList.mkString + s\\\"\\\"\\\"&#x3C;p>&#x3C;a href=\\\"/blogs/${file.getName}\\\">[...]&#x3C;/a>&#x3C;/p>&#x3C;/article>\\\"\\\"\\\"\\n</code></pre>\\n<p>备注：</p>\\n<ul>\\n<li>在转换为html之后，需要在外面包一个<code>&#x3C;article></code>容器元素。</li>\\n<li>从一个Seq容器元素中截取前面部分元素用<code>takeWhile</code>，此处有一个<code>var</code>可变参数的使用，其实也可以不用，只是用在这里容易一些。</li>\\n<li>在最后添加一个指向文章全文的链接。</li>\\n</ul>\\n<h2>预告</h2>\\n<p>下篇，将介绍如何将网页中的代码片段提交到服务器端执行并返回执行结果，也就是Web GUI REPL，敬请关注。</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/用markdown写博客.markdown absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-01T14:06:45.000Z\",\"path\":\"/2013/blogging-with-markdown\",\"title\":\"边建边学-1: 用Markdown写博文\",\"excerpt\":\"本文将是一个系列文章，循序渐进地介绍本站的构建过程，不只是简单的技术介绍，重点是建站过程遇到的问题分析，以及解决的过程，所以起名**“边建边学”**系列。\",\"tags\":[\"markdown\",\"blog\"]}}},{\"node\":{\"html\":\"<h2>引子</h2>\\n<p>从有了博客这个东西开始，就一直开始找各种好用的博客站点，csdn、新浪、搜狐、博客大巴、点点、google site、Github，甚至自己定制内容管理系统（CMS）Liferay，来建立自己的博客站点。免费的、收费的，都尝试了，可总觉得这里或者那里有点不满意。</p>\\n<p>所以就有一个小心愿能实现一个自己喜欢的站点。</p>\\n<p>这个站点应该可以：</p>\\n<ul>\\n<li>用比较“极客”的方式来写，符合我们这种工科IT男的作风。</li>\\n<li>可以很灵活地定制，想加什么功能就加什么功能。</li>\\n<li>最好有个主题，不是一个记流水账的地方。</li>\\n</ul>\\n<p>近来学习scala这门语言，对于我这个多年在OO世界中打拼的程序员在思维方式上的触动很大，有了找一个地方写一些关于scala学习方面的专题文章。</p>\\n<p>两者一结合，就有了这个网站。</p>\\n<h2>站点简介</h2>\\n<p>这个网站是用下列技术构建的：</p>\\n<ul>\\n<li>Scala</li>\\n<li>Playframework</li>\\n<li>Markdown</li>\\n<li>Websockets</li>\\n<li>Redis</li>\\n<li>MongoDB</li>\\n<li>Twitter Bootstrap</li>\\n</ul>\\n<p>运行在Heroku上，除了域名，一切免费。</p>\\n<h2>博客内容预告</h2>\\n<p>这一系列文章将包括，但不限于：</p>\\n<ul>\\n<li>\\n<p>构建本站技术介绍\\n如何一步一步地搭建一个完整的网站。</p>\\n</li>\\n<li>\\n<p>Scala语言特性</p>\\n</li>\\n<li>\\n<p>一些Scala世界的常用工具，比如Akka、Scalaz的介绍等等。</p>\\n</li>\\n</ul>\\n<p>你可以方便地在网站上直接测试一些小的代码，比如：</p>\\n<!-- language:lang-scala run -->\\n<pre><code>val i = 10\\nprintln(i + 2)\\nval j = 10\\nprintln(j - i)\\n</code></pre>\\n<p>点击<code>Run</code>你就能看到执行结果。</p>\\n<h2>TODO LIST</h2>\\n<ul>\\n<li>简单的搜索</li>\\n<li>分页</li>\\n<li>评论功能</li>\\n</ul>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/开篇.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-10-25T17:06:45.000Z\",\"path\":\"/2013/start\",\"title\":\"开篇\",\"excerpt\":\"网络博客\",\"tags\":[]}}}],\"pathPrefix\":\"\",\"first\":false,\"last\":true,\"index\":3,\"pageCount\":3}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---3-e35ffe9ef2b199f82bb7.js","module.exports = {\"data\":{\"allMarkdownRemark\":{\"totalCount\":22,\"edges\":[{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/微服务架构下的开发环境问题.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"微服务架构下的开发环境问题\",\"date\":\"March 16, 2018\",\"path\":\"/2018/development-environment-for-microservices\",\"tags\":[\"微服务\",\"架构\",\"开发环境\",\"microservices\"],\"excerpt\":\"本文介绍如何在微服务架构下解决开发环境的搭建、共享的问题。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/为Gatsby博客添加分页功能.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"为Gatsby博客添加分页功能\",\"date\":\"March 12, 2018\",\"path\":\"/2018/support-pagination-for-gatsby-blog\",\"tags\":[\"blog\",\"gatsby\"],\"excerpt\":\"根据Egghead上的教程，做出的博客站点有个缺陷，那就是没有分页功能，对于勤奋的博主来说，在一个页面上显示所有文章列表有点不完美，这里我们改造一下，加入分页功能。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/为你的Gatsby博客添加评论功能.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"为你的Gatsby博客添加评论功能\",\"date\":\"March 12, 2018\",\"path\":\"/2018/enable-comments-for-gatsby-blog\",\"tags\":[\"blog\"],\"excerpt\":\"Gatsby打造的博客已经很不错了，但是缺少一个评论功能。本文简单介绍如何集成Disqus评论服务到你的博客站点。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/转用Gatsby搭建博客.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"转用Gatsby打造基于github的博客站点\",\"date\":\"March 08, 2018\",\"path\":\"/2018/blog-with-gatsby\",\"tags\":[\"blog\",\"github\",\"gatsby\"],\"excerpt\":\"如何用Gatsby打造一个博客\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2018/一则奇怪的Toubleshooting.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"记一次奇怪的troubleshooting\",\"date\":\"March 08, 2018\",\"path\":\"/2018/skipper-sni-domain-fronting\",\"tags\":[\"skipper\",\"SNI\",\"domain fronting\"],\"excerpt\":\"在Skipper转发请求到一个https站点的时候，返回莫名404.\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2016/JSON解析利器JQ.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"JSON解析利器---JQ\",\"date\":\"March 25, 2016\",\"path\":\"/2013/jq\",\"tags\":[\"bash\",\"jq\",\"json\"],\"excerpt\":\"在API first的时代，json作为最常用的格式，充斥着程序猿的屏幕各个角落，掌握一门解析、过滤、转换json输出的工具，已经成为程序猿们安身立命的必要技能。 这里隆重向大家介绍[jq](https://stedolan.github.io/jq/).\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2016/Function的协变.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Function的协、逆变\",\"date\":\"February 04, 2016\",\"path\":\"/2016/function-covariant-contravariant\",\"tags\":[\"scala\",\"functional programming\"],\"excerpt\":\"泛型编程的时候，协变(covariant)还是逆变(contravariant)很重要，在设计上层API接口的时候，正确的使用协变、逆变可以更好地约束程序员的行为，让实现变得安全、一致。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/如何在Scala中实现AOP.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"用Mixin组合实现Scala中的AOP\",\"date\":\"August 13, 2015\",\"path\":\"/2015/aop-by-mixin-in-scala\",\"tags\":[\"scala\",\"functional programming\",\"AOP\",\"mixin\"],\"excerpt\":\"在Java世界，AOP（Aspect Oriented Programming， 面向方面编程)是很多框架的基础。这种将关注点按照“方面”来切分的编程模型极大地简化了编程的复杂度，尤其是在多维度因子交织在一起的时候的各种场景。对于代码的可读性、可维护性、可重用性都是极大的帮助。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Scala雾里看花.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Scala雾里看花\",\"date\":\"April 23, 2015\",\"path\":\"/2015/scala-trouble-shooting\",\"tags\":[\"scala\",\"trouble shooting\"],\"excerpt\":\"Scala的学习过程中，经常会碰到一些莫名其妙的现象，很多时候，这些语言层面的“怪象”都与scala编译器或者scala的类型系统有关。本文不是对编译器和类型系统的介绍，而是重点介绍遇到这些现象的时候，用什么样的方式，拨开云雾见蓝天，通过这些工具获取一些细节帮你了解编译器和类型系统如何工作。工欲善其事，必先利其器。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2015/Docker创建MySQL主从复制以及CDC测试.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"MySQL Master/Slave Replication on Docker\",\"date\":\"April 21, 2015\",\"path\":\"/2015/mysql-replication-on-docker\",\"tags\":[\"docker\",\"mysql\"],\"excerpt\":\"How to setup Mysql master/slave replication.\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2014/Scala函数式异常处理.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Scala函数式异常处理\",\"date\":\"May 04, 2014\",\"path\":\"/2014/scala-error-handling-in-fp-style\",\"tags\":[\"scala\",\"functional programming\",\"exception handling\"],\"excerpt\":\"经常看到很多示例代码，简洁的让人爱不释手，可是真正自己实现的时候，不得不添加各种各样的异常处理逻辑，最后发现代码总量的80%都是再做异常处理，而真正的代码逻辑只有很少的一部分。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2014/高种泛型.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"高种泛型 (Generics of a Higher Kind)\",\"date\":\"January 08, 2014\",\"path\":\"/2014/generics-of-a-higher-kind\",\"tags\":[\"scala\",\"functional programming\",\"Generics\"],\"excerpt\":\"Generics of a Higher Kind翻译加自我理解。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/map-flatMap-for.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"map/flatMap/for in Action\",\"date\":\"December 01, 2013\",\"path\":\"/2013/map-flatmap-for\",\"tags\":[\"scala\",\"functional programming\"],\"excerpt\":\"前文说过了，高阶函数式函数式语言中的基石，而`map`, `flatMap`更是重要。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/fold编程.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"折纸的艺术：fold编程\",\"date\":\"November 27, 2013\",\"path\":\"/2013/fold\",\"tags\":[\"scala\",\"functional programming\",\"fold\"],\"excerpt\":\"Eric Meijer说：递归是函数式编程的GOTO，应该尽可能避免。如何避免，OO中我们用while循环，FP中我们用`fold`。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Monad.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Monad\",\"date\":\"November 26, 2013\",\"path\":\"/2013/monad\",\"tags\":[\"scala\",\"functional programming\",\"monad\"],\"excerpt\":\"函数式语言与OO（确切地讲是指令式编程）的思维方式是完全不同的，很多OO中的经验在函数式语言中不是很匹配，比如设计模式，那就是一个OO中的特定术语，而在FP中，大家常谈的是对于习惯OO思维的程序员来说玄而又玄的Monad。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/高阶函数.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"高阶函数\",\"date\":\"November 21, 2013\",\"path\":\"/2013/high-order-function\",\"tags\":[\"scala\",\"functional programming\",\"high order function\"],\"excerpt\":\"所谓高阶函数（high order function），其实就是可以接受其他函数作为参数的函数。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Actor协调并发场景下的集合操作.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"边建边学-3：Actor协调并发场景下的集合操作\",\"date\":\"November 17, 2013\",\"path\":\"/2013/actor-collection-collabration\",\"tags\":[\"scala\",\"functional programming\"],\"excerpt\":\"很多时候为了提高性能，减少IO操作，都会将数据load出来之后缓存在内存中。本站的实现过程中也遇到类似的问题，不希望每次有人访问的时候就读取一次md文件，或者从MongoDB中查一次，而是直接在内存中读取。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/Enumerator-Iteratee-Enumeratee.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"Enumerator / Iteratee / Enumeratee\",\"date\":\"November 11, 2013\",\"path\":\"/2013/enumerator-iteratee-enumeratee\",\"tags\":[\"scala\",\"playframework\",\"blog\"],\"excerpt\":\"Stream对于指令式编程已经比较成熟了，有大量的类库，丰富的API。但是对于强调不可变量，尽可能无副作用的FP来说，要考虑语言适配的问题，而目前，流行的解决方案就是：Enumerator/Iteratee。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/集成PlantUML和Markdown.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"边建边学-2：集成PlantUML和Markdown\",\"date\":\"November 07, 2013\",\"path\":\"/2013/markdown-plantuml-integration\",\"tags\":[\"markdown\",\"plantuml\",\"blog\"],\"excerpt\":\"如何用Markdown+PlantUML结合来写图文并茂的博客。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/EssentialAction-in-Playframework.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"EssentialAction in Playframework\",\"date\":\"November 05, 2013\",\"path\":\"/2013/essential-action-in-play\",\"tags\":[\"scala\",\"playframework\"],\"excerpt\":\"Playframework中EssentialAction理解\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/用markdown写博客.markdown absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"边建边学-1: 用Markdown写博文\",\"date\":\"November 01, 2013\",\"path\":\"/2013/blogging-with-markdown\",\"tags\":[\"markdown\",\"blog\"],\"excerpt\":\"本文将是一个系列文章，循序渐进地介绍本站的构建过程，不只是简单的技术介绍，重点是建站过程遇到的问题分析，以及解决的过程，所以起名**“边建边学”**系列。\"}}},{\"node\":{\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/开篇.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"title\":\"开篇\",\"date\":\"October 25, 2013\",\"path\":\"/2013/start\",\"tags\":[],\"excerpt\":\"网络博客\"}}}]}},\"pathContext\":{\"group\":[{\"node\":{\"html\":\"<p>本文将是一个系列文章，循序渐进地介绍本站的构建过程，不只是简单的技术介绍，重点是建站过程遇到的问题分析，以及解决的过程，所以起名<strong>“边建边学”</strong>系列。</p>\\n<p>希望对学习<code>Scala</code>+<code>Playframework</code>的童鞋有所启发。</p>\\n<p>本篇重点介绍如何用markdown来写技术文章，以及如何优化代码片段。</p>\\n<h2>需求</h2>\\n<ul>\\n<li>用markdown来写博客，对不同代码类型能够进行美化</li>\\n<li>技术博客一般会在文中包含部分代码片段，在看文章的时候，如果能运行一下这个代码片段，看看执行结果是什么，会对理解技术有所帮助，所以这里需要一个Web REPL (Read Eval Print Loop)</li>\\n<li>博文列表中只显示博文头</li>\\n</ul>\\n<h2>实现</h2>\\n<h3>markdown</h3>\\n<p>用Markdown写文章的流程是这样的：</p>\\n<ol>\\n<li>\\n<p>在本地创建md文件，用markdown语法写文章</p>\\n<p>markdown语法不是本文的介绍重点，需要温习的童鞋请查看<a href=\\\"http://zh.wikipedia.org/zh-cn/Markdown\\\">维基百科</a>，编辑工具可以考虑使用：<a href=\\\"http://mouapp.com\\\">Mou</a>，或者chrome插件stackedit。</p>\\n</li>\\n<li>\\n<p>将文章发布到网站。</p>\\n<p>发布的最终目的是将文章上传到网站，可以是存到数据库中，可以是上传为一个文件，因为文章的特殊性，创作过程需要跟踪记录，而且md文章本身也是一个文件，所以直接将文件上传搞定。</p>\\n<p>具体上传途径是通过git。其实从版本管理的角度，md文件和其他源代码文件没有什么不同。</p>\\n</li>\\n<li>\\n<p>mardkown解析成为HTML</p>\\n<p>这个解析有两种选择，一个是在服务器端解析，另外一个是在浏览器端通过javascript来解析。个人觉得没有太大不同，这里选择一个github上开源的工具来实现：<a href=\\\"https://github.com/sirthias/pegdown\\\">Pegdown</a>。</p>\\n<p>具体代码非常简单：</p>\\n</li>\\n</ol>\\n<!-- language:lang-scala -->\\n<pre><code>val processor = new PegDownProcessor()\\nval markdownContent = \\\"##title2\\\\n*item1\\\"\\nval htmlContent = processor.markdownToHtml(markdownContent)\\n</code></pre>\\n<ol start=\\\"4\\\">\\n<li>\\n<p>代码美化</p>\\n<p>将MD转换为html之后，代码片段只是被转换为：<code>&#x3C;pre>&#x3C;code> .... &#x3C;/code>&#x3C;/pre></code>，但是如何按照相应语言的语法进行高亮显示呢？其实任何Web效果的东西都没有什么神秘的，只是应用CSS而已。</p>\\n<p>这里我们选用的是<a href=\\\"https://code.google.com/p/google-code-prettify/\\\">prettify.js</a>，当然，还可以选择其他方案，比如<a href=\\\"http://highlightjs.org\\\">highlight.js</a>.</p>\\n<p>具体方案如下：</p>\\n</li>\\n</ol>\\n<!-- language:lang-javascript -->\\n<pre><code>&#x3C;script type='text/javascript'>\\n    function init() {\\n        var prettify = false;\\n        var blocks = document.querySelectorAll('pre code')\\n        for (var i = 0; i &#x3C; blocks.length ; i++) {\\n            blocks[i].className += 'prettyprint';\\n            prettify = true;\\n        }\\n        if (prettify) {\\n          prettyPrint();\\n        }\\n    }\\n    window.onload = init;\\n&#x3C;/script>\\n</code></pre>\\n<p>简单说，就是在页面（dom）加载完成之后，查找所有的pre+code元素，然后给该元素class添加<code>prettyprint</code>，这样有了预定义的样式表，代码语法高亮特性就实现了。\\n<br>\\n代码片段执行的部分将有专门的章节介绍，此处略过。\\n</p>\\n<h3>博文列表只显示文章头</h3>\\n<p>在列表页面，将在一个页面列出大量的内容，如果将每篇文章都完整地列出来，那么页面将变得很长，而且也不方便用户查找，而如果能够只显示文章的开头部分，就可以让读者快速地了解文章大致内容，并且快速浏览近期文章，有选择性地查看文章。</p>\\n<p>这个说起来其实很简单，展示部分内容逻辑上也很简单，只是简单截取文章开头的前N个字符而已。总体上是这个思路，可实际上会比这个稍微复杂一些。原因在于博文不是简单的plain text，而是HTML代码，如果只简单截取前面N个字符，极有可能会造成HTML片段不完整导致页面错误。</p>\\n<p>知道问题所在之后，解决办法其实也就简单了。我们可以简单分析一下markdown转换为html之后的代码结构，比如：</p>\\n<!-- language:lang-html -->\\n<pre><code>&#x3C;h1>手工打造博客站点-1: 用Markdown写博文&#x3C;/h1>\\n&#x3C;p>本文将是一个系列文章，循序渐进地介绍本站的构建过程，不只是简单的技术介绍，重点是建站过程遇到的问题分析，以及解决的过程。&#x3C;/p>\\n&#x3C;p>希望对学习&#x3C;code>Scala&#x3C;/code>+&#x3C;code>Playframework&#x3C;/code>的童鞋有所启发。&#x3C;/p>\\n&#x3C;p>本篇重点介绍如何用markdown来写技术文章，以及如何优化代码片段。&#x3C;/p>\\n&#x3C;h2>需求&#x3C;/h2>\\n……\\n</code></pre>\\n<p>很明显，标题、段落等html元素都是同级的，所以我们只需要一次计算每个html元素所包含内容的长度，当叠加到超过阀值时，将前面元素内容输出就好了。具体的办法是：先将html字符串解析为XML DOM，然后迭代每个一级children节点。</p>\\n<!-- language:lang-scala -->\\n<pre><code>val content = Source.fromFile(file, \\\"UTF-8\\\", 1024).mkString\\nval htmlContent = \\\"&#x3C;article>\\\" + processor.markdownToHtml(content) + \\\"&#x3C;/article>\\\"\\n// only show part of the article\\nval xml = scala.xml.XML.loadString(htmlContent)\\nvar i: Long = 0L\\nval elemList = xml.child.takeWhile( el => { i += el.toString().length; i &#x3C; ConfigUtils.BLOG_HEAD_LENGTH } )\\nval part = \\\"&#x3C;article>\\\" + elemList.mkString + s\\\"\\\"\\\"&#x3C;p>&#x3C;a href=\\\"/blogs/${file.getName}\\\">[...]&#x3C;/a>&#x3C;/p>&#x3C;/article>\\\"\\\"\\\"\\n</code></pre>\\n<p>备注：</p>\\n<ul>\\n<li>在转换为html之后，需要在外面包一个<code>&#x3C;article></code>容器元素。</li>\\n<li>从一个Seq容器元素中截取前面部分元素用<code>takeWhile</code>，此处有一个<code>var</code>可变参数的使用，其实也可以不用，只是用在这里容易一些。</li>\\n<li>在最后添加一个指向文章全文的链接。</li>\\n</ul>\\n<h2>预告</h2>\\n<p>下篇，将介绍如何将网页中的代码片段提交到服务器端执行并返回执行结果，也就是Web GUI REPL，敬请关注。</p>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/用markdown写博客.markdown absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-11-01T14:06:45.000Z\",\"path\":\"/2013/blogging-with-markdown\",\"title\":\"边建边学-1: 用Markdown写博文\",\"excerpt\":\"本文将是一个系列文章，循序渐进地介绍本站的构建过程，不只是简单的技术介绍，重点是建站过程遇到的问题分析，以及解决的过程，所以起名**“边建边学”**系列。\",\"tags\":[\"markdown\",\"blog\"]}}},{\"node\":{\"html\":\"<h2>引子</h2>\\n<p>从有了博客这个东西开始，就一直开始找各种好用的博客站点，csdn、新浪、搜狐、博客大巴、点点、google site、Github，甚至自己定制内容管理系统（CMS）Liferay，来建立自己的博客站点。免费的、收费的，都尝试了，可总觉得这里或者那里有点不满意。</p>\\n<p>所以就有一个小心愿能实现一个自己喜欢的站点。</p>\\n<p>这个站点应该可以：</p>\\n<ul>\\n<li>用比较“极客”的方式来写，符合我们这种工科IT男的作风。</li>\\n<li>可以很灵活地定制，想加什么功能就加什么功能。</li>\\n<li>最好有个主题，不是一个记流水账的地方。</li>\\n</ul>\\n<p>近来学习scala这门语言，对于我这个多年在OO世界中打拼的程序员在思维方式上的触动很大，有了找一个地方写一些关于scala学习方面的专题文章。</p>\\n<p>两者一结合，就有了这个网站。</p>\\n<h2>站点简介</h2>\\n<p>这个网站是用下列技术构建的：</p>\\n<ul>\\n<li>Scala</li>\\n<li>Playframework</li>\\n<li>Markdown</li>\\n<li>Websockets</li>\\n<li>Redis</li>\\n<li>MongoDB</li>\\n<li>Twitter Bootstrap</li>\\n</ul>\\n<p>运行在Heroku上，除了域名，一切免费。</p>\\n<h2>博客内容预告</h2>\\n<p>这一系列文章将包括，但不限于：</p>\\n<ul>\\n<li>\\n<p>构建本站技术介绍\\n如何一步一步地搭建一个完整的网站。</p>\\n</li>\\n<li>\\n<p>Scala语言特性</p>\\n</li>\\n<li>\\n<p>一些Scala世界的常用工具，比如Akka、Scalaz的介绍等等。</p>\\n</li>\\n</ul>\\n<p>你可以方便地在网站上直接测试一些小的代码，比如：</p>\\n<!-- language:lang-scala run -->\\n<pre><code>val i = 10\\nprintln(i + 2)\\nval j = 10\\nprintln(j - i)\\n</code></pre>\\n<p>点击<code>Run</code>你就能看到执行结果。</p>\\n<h2>TODO LIST</h2>\\n<ul>\\n<li>简单的搜索</li>\\n<li>分页</li>\\n<li>评论功能</li>\\n</ul>\",\"id\":\"/Users/lliu/github/smilingleo.github.io/src/pages/2013/开篇.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2013-10-25T17:06:45.000Z\",\"path\":\"/2013/start\",\"title\":\"开篇\",\"excerpt\":\"网络博客\",\"tags\":[]}}}],\"pathPrefix\":\"\",\"first\":false,\"last\":true,\"index\":3,\"pageCount\":3}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/3.json\n// module id = 402\n// module chunks = 182981024786761"],"sourceRoot":""}