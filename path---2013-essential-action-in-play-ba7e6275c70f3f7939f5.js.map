{"version":3,"sources":["webpack:///path---2013-essential-action-in-play-ba7e6275c70f3f7939f5.js","webpack:///./.cache/json/2013-essential-action-in-play.json"],"names":["webpackJsonp","345","module","exports","data","markdownRemark","html","frontmatter","title","date","path","tags","excerpt","pathContext","slug"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,2tGAAg7FC,aAAmUC,MAAA,mCAAAC,KAAA,oBAAAC,KAAA,iCAAAC,MAAA,yBAAAC,QAAA,qCAA6LC,aAAgBC,KAAA","file":"path---2013-essential-action-in-play-ba7e6275c70f3f7939f5.js","sourcesContent":["webpackJsonp([242031673056639],{\n\n/***/ 345:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h2>Play!框架的核心</h2>\\n<p>Play!的内核其实非常简单，简单地说，Play框架所实现的可以用一个函数表达式来描述：</p>\\n<p><code>RequestHeader -> Array[Byte] -> Result</code></p>\\n<p>具体讲，就是接受一个<code>RequestHeader</code>，然后读入类型为<code>Array[Byte]</code>的Request Body，计算完毕之后返回一个<code>Result</code>。</p>\\n<p>注：函数式语言的表达就是高度抽象，但异常简洁。</p>\\n<h2>问题及优化</h2>\\n<h3>文件上传</h3>\\n<p>上面的描述有一个问题：我们假定要把请求内容<em>全部</em>读入内存（或者写入磁盘），对于简单应用不是什么问题，但是对于文件上传等场景，这肯定是有问题的，所以，Play开发者做了优化。</p>\\n<p>注：此处可以看出函数式语言的一个优点：仅需要了解你的函数定义，就能分析出潜在的问题。而如果面向对象的方式一般关注在对象之间的通信、方法调用，从方法签名上往往会忽略这些细节。</p>\\n<p>优化的思路当然是将请求内容一部分一部分地读入（chunk），所以这个函数就变成了：</p>\\n<p><code>RequestHeader -> Iteratee[Array[Byte], Result]</code></p>\\n<p><code>Iteratee</code>是个什么东东？简单讲就是一个<code>Monad</code>，什么是Monad？可以类比为OO世界中的设计模式：专门为了解决某类问题的特定方法。Iteratee可以将输入（Input）分步(Step)读入，而且可以进行精细控制遇到EOF、Empty、El(chunk)的时候应该如何处理，是继续（Cont），结束（Done）还是抛错（Error）。这里不做详细介绍。有兴趣的可以参见：<a href=\\\"http://apocalisp.wordpress.com/2010/10/17/scalaz-tutorial-enumeration-based-io-with-iteratees/\\\">这篇博客</a></p>\\n<p>Iteratee本身也是一个<code>Arrow</code>（简单理解为函数），所以如果我们定义一个新类型：</p>\\n<!-- language:lang-scala -->\\n<pre><code>type ==>[E, R] = Iteratee[E, R]\\n</code></pre>\\n<p>上面的函数用scala来写就会变为：</p>\\n<!-- language:lang-scala -->\\n<pre><code>RequestHeader => Array[Byte] ==> Result\\n</code></pre>\\n<p>注：<code>==>[E, R]</code>和<code>E ==> R</code>是等价的，是scala的一个语法糖。</p>\\n<p>上面的表达式看上去更简洁，更有趣了。</p>\\n<h3>文件下载</h3>\\n<p>有了<code>Iteratee</code>我们就可以分块处理请求了，但是响应呢？同样地，如果响应中的数据量很大，比如文件下载，从上面的函数定义看，依旧会把文件完全读入到内存中，同样的问题。</p>\\n<p>解决的思路也是一样的。我们可以将<code>Result</code>看做下面的数据结构：</p>\\n<!-- language:lang-scala -->\\n<pre><code>case class Result(header: ResponseHeader, body: Array[Byte])\\n</code></pre>\\n<p>问题主要在<code>body</code>上，类型是Array[Byte]，需要有一个新的数据类型将起封装，可以分块地处理输出内容，这就是<code>Enumerator</code>，一个用来将响应数据分块(chunk)的东东。</p>\\n<p>所以最终Play框架核心可以看做下面的API：</p>\\n<!-- language:lang-scala -->\\n<pre><code>case class Result[E](headers:ResponseHeaders, body:Enumerator[E])(implicit writeable:Writeable[E])\\ntype ==>[E, R] = Iteratee[E, R]\\nRequestHeader => Array[Byte] ==> Result\\n</code></pre>\\n<p>下面我们来看看Request和Result各自的类图，了解一下都有哪些实现。</p>\\n<!-- language:uml -->\\n<pre><code>title Request Class Hierarchy\\nclass RequestHeader &#x3C;&#x3C; (T, #00FF00)>>\\nclass Request &#x3C;&#x3C; (T, #00FF00)>>\\n\\nRequestHeader &#x3C;|-- Request\\nRequest &#x3C;|-- WrappedRequest\\nRequest &#x3C;|-- FakeRequest\\nWrappedRequest &#x3C;|-- AuthenticatedRequest\\n\\ncenter footer 图一：Request 类图\\n</code></pre>\\n<p>真简单啊，比OO世界里面的一些MVC框架中的类层次结构少多了。</p>\\n<!-- language:uml -->\\n<pre><code>title Result Class Hierarchy\\nclass WithHeaders &#x3C;&#x3C; (T, #00FF00) >>\\nclass Result &#x3C;&#x3C; (T, #00FF00) >>\\n\\nclass PlainResult &#x3C;&#x3C; (T, #FF0000) deprecated>>\\nclass AsyncResult &#x3C;&#x3C; (C, #FF0000) deprecated>>\\nclass ChunkedResult &#x3C;&#x3C; (D, #FF0000) deprecated>>\\n\\nWithHeaders &#x3C;|-- Result\\nResult &#x3C;|-- PlainResult\\nResult &#x3C;|-- AsyncResult\\nPlainResult &#x3C;|-- SimpleResult\\nSimpleResult &#x3C;|-- ChunkedResult\\nSimpleResult &#x3C;|-- Status\\n\\ncenter footer 图二：Result 类图\\n</code></pre>\\n<p>目前Play2.2中Result有两个子类：PlainResult和AsyncResult，但这两个Result已经被标记为deprecated了，从2.3开始，Play将只支持SimpleResult。为什么呢？ 想想其实很简单：单一职责原则。所谓<code>AsyncResult</code>其实本身职责不单一，有异步和Result两个，而直接使用：<code>Future[SimpleResult]</code>则清晰很多。另外ChunkedResult被废弃的原因也一样。</p>\",\"frontmatter\":{\"title\":\"EssentialAction in Playframework\",\"date\":\"November 05, 2013\",\"path\":\"/2013/essential-action-in-play\",\"tags\":[\"scala\",\"playframework\"],\"excerpt\":\"Playframework中EssentialAction理解\"}}},\"pathContext\":{\"slug\":\"/2013/essential-action-in-play\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---2013-essential-action-in-play-ba7e6275c70f3f7939f5.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h2>Play!框架的核心</h2>\\n<p>Play!的内核其实非常简单，简单地说，Play框架所实现的可以用一个函数表达式来描述：</p>\\n<p><code>RequestHeader -> Array[Byte] -> Result</code></p>\\n<p>具体讲，就是接受一个<code>RequestHeader</code>，然后读入类型为<code>Array[Byte]</code>的Request Body，计算完毕之后返回一个<code>Result</code>。</p>\\n<p>注：函数式语言的表达就是高度抽象，但异常简洁。</p>\\n<h2>问题及优化</h2>\\n<h3>文件上传</h3>\\n<p>上面的描述有一个问题：我们假定要把请求内容<em>全部</em>读入内存（或者写入磁盘），对于简单应用不是什么问题，但是对于文件上传等场景，这肯定是有问题的，所以，Play开发者做了优化。</p>\\n<p>注：此处可以看出函数式语言的一个优点：仅需要了解你的函数定义，就能分析出潜在的问题。而如果面向对象的方式一般关注在对象之间的通信、方法调用，从方法签名上往往会忽略这些细节。</p>\\n<p>优化的思路当然是将请求内容一部分一部分地读入（chunk），所以这个函数就变成了：</p>\\n<p><code>RequestHeader -> Iteratee[Array[Byte], Result]</code></p>\\n<p><code>Iteratee</code>是个什么东东？简单讲就是一个<code>Monad</code>，什么是Monad？可以类比为OO世界中的设计模式：专门为了解决某类问题的特定方法。Iteratee可以将输入（Input）分步(Step)读入，而且可以进行精细控制遇到EOF、Empty、El(chunk)的时候应该如何处理，是继续（Cont），结束（Done）还是抛错（Error）。这里不做详细介绍。有兴趣的可以参见：<a href=\\\"http://apocalisp.wordpress.com/2010/10/17/scalaz-tutorial-enumeration-based-io-with-iteratees/\\\">这篇博客</a></p>\\n<p>Iteratee本身也是一个<code>Arrow</code>（简单理解为函数），所以如果我们定义一个新类型：</p>\\n<!-- language:lang-scala -->\\n<pre><code>type ==>[E, R] = Iteratee[E, R]\\n</code></pre>\\n<p>上面的函数用scala来写就会变为：</p>\\n<!-- language:lang-scala -->\\n<pre><code>RequestHeader => Array[Byte] ==> Result\\n</code></pre>\\n<p>注：<code>==>[E, R]</code>和<code>E ==> R</code>是等价的，是scala的一个语法糖。</p>\\n<p>上面的表达式看上去更简洁，更有趣了。</p>\\n<h3>文件下载</h3>\\n<p>有了<code>Iteratee</code>我们就可以分块处理请求了，但是响应呢？同样地，如果响应中的数据量很大，比如文件下载，从上面的函数定义看，依旧会把文件完全读入到内存中，同样的问题。</p>\\n<p>解决的思路也是一样的。我们可以将<code>Result</code>看做下面的数据结构：</p>\\n<!-- language:lang-scala -->\\n<pre><code>case class Result(header: ResponseHeader, body: Array[Byte])\\n</code></pre>\\n<p>问题主要在<code>body</code>上，类型是Array[Byte]，需要有一个新的数据类型将起封装，可以分块地处理输出内容，这就是<code>Enumerator</code>，一个用来将响应数据分块(chunk)的东东。</p>\\n<p>所以最终Play框架核心可以看做下面的API：</p>\\n<!-- language:lang-scala -->\\n<pre><code>case class Result[E](headers:ResponseHeaders, body:Enumerator[E])(implicit writeable:Writeable[E])\\ntype ==>[E, R] = Iteratee[E, R]\\nRequestHeader => Array[Byte] ==> Result\\n</code></pre>\\n<p>下面我们来看看Request和Result各自的类图，了解一下都有哪些实现。</p>\\n<!-- language:uml -->\\n<pre><code>title Request Class Hierarchy\\nclass RequestHeader &#x3C;&#x3C; (T, #00FF00)>>\\nclass Request &#x3C;&#x3C; (T, #00FF00)>>\\n\\nRequestHeader &#x3C;|-- Request\\nRequest &#x3C;|-- WrappedRequest\\nRequest &#x3C;|-- FakeRequest\\nWrappedRequest &#x3C;|-- AuthenticatedRequest\\n\\ncenter footer 图一：Request 类图\\n</code></pre>\\n<p>真简单啊，比OO世界里面的一些MVC框架中的类层次结构少多了。</p>\\n<!-- language:uml -->\\n<pre><code>title Result Class Hierarchy\\nclass WithHeaders &#x3C;&#x3C; (T, #00FF00) >>\\nclass Result &#x3C;&#x3C; (T, #00FF00) >>\\n\\nclass PlainResult &#x3C;&#x3C; (T, #FF0000) deprecated>>\\nclass AsyncResult &#x3C;&#x3C; (C, #FF0000) deprecated>>\\nclass ChunkedResult &#x3C;&#x3C; (D, #FF0000) deprecated>>\\n\\nWithHeaders &#x3C;|-- Result\\nResult &#x3C;|-- PlainResult\\nResult &#x3C;|-- AsyncResult\\nPlainResult &#x3C;|-- SimpleResult\\nSimpleResult &#x3C;|-- ChunkedResult\\nSimpleResult &#x3C;|-- Status\\n\\ncenter footer 图二：Result 类图\\n</code></pre>\\n<p>目前Play2.2中Result有两个子类：PlainResult和AsyncResult，但这两个Result已经被标记为deprecated了，从2.3开始，Play将只支持SimpleResult。为什么呢？ 想想其实很简单：单一职责原则。所谓<code>AsyncResult</code>其实本身职责不单一，有异步和Result两个，而直接使用：<code>Future[SimpleResult]</code>则清晰很多。另外ChunkedResult被废弃的原因也一样。</p>\",\"frontmatter\":{\"title\":\"EssentialAction in Playframework\",\"date\":\"November 05, 2013\",\"path\":\"/2013/essential-action-in-play\",\"tags\":[\"scala\",\"playframework\"],\"excerpt\":\"Playframework中EssentialAction理解\"}}},\"pathContext\":{\"slug\":\"/2013/essential-action-in-play\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/2013-essential-action-in-play.json\n// module id = 345\n// module chunks = 242031673056639"],"sourceRoot":""}