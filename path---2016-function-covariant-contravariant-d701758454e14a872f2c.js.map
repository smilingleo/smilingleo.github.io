{"version":3,"sources":["webpack:///path---2016-function-covariant-contravariant-d701758454e14a872f2c.js","webpack:///./.cache/json/2016-function-covariant-contravariant.json"],"names":["webpackJsonp","358","module","exports","data","markdownRemark","html","frontmatter","title","date","path","tags","excerpt","pathContext","slug"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,ugFAAixCC,aAAwxCC,MAAA,gBAAAC,KAAA,oBAAAC,KAAA,yCAAAC,MAAA,kCAAAC,QAAA,mGAAyPC,aAAgBC,KAAA","file":"path---2016-function-covariant-contravariant-d701758454e14a872f2c.js","sourcesContent":["webpackJsonp([80471449016911],{\n\n/***/ 358:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>泛型编程的时候，协变(covariant)还是逆变(contravariant)很重要，在设计上层API接口的时候，正确的使用协变、逆变可以更好地约束程序员的行为，让实现变得安全、一致。</p>\\n<p>协变、逆变在一般时候是比较容易理解的，但是来到FP世界之后，Function的协变、逆变就变得比较复杂。</p>\\n<p>比如： 对于<code>trait List[+T]</code></p>\\n<!-- language:uml -->\\n<pre><code>class Animal\\nclass Dog\\nclass \\\"List[Animal]\\\" as LA\\nclass \\\"List[Dog]\\\" as LD\\n\\nAnimal &#x3C;|-- Dog\\nLA &#x3C;|-- LD\\n</code></pre>\\n<p>那对于<code>trait CList[-T]</code></p>\\n<!-- language:uml -->\\n<pre><code>class Animal\\nclass Dog\\nclass \\\"CList[Animal]\\\" as LA\\nclass \\\"CList[Dog]\\\" as LD\\n\\nAnimal &#x3C;|-- Dog\\nLA --|> LD\\n</code></pre>\\n<p>这些还都容易理解，对于<code>trait Func[-I, +O]</code>的理解就比较费劲了。</p>\\n<!-- language:lang-scala -->\\n<pre><code>import scala.reflect.runtime.universe._\\n\\nclass Animal\\ncase class Dog(name: String) extends Animal\\n\\nclass Material\\ncase class Wood(color: String) extends Material\\n\\ntrait Func[-I, +O] {\\n  def apply(input: I): O\\n}\\n\\ntypeOf[Dog] &#x3C;:&#x3C; typeOf[Animal]  // return true\\ntypeOf[Func[Material, Dog]] &#x3C;:&#x3C; typeOf[Func[Wood, Animal]]    // retrun true\\n</code></pre>\\n<!-- language:uml -->\\n<pre><code>class Animal\\nclass Dog\\nclass Wood\\nclass Material\\n\\nclass \\\"Func[Wood, Animal]\\\" as LA\\nclass \\\"Func[Material, Dog]\\\" as LD\\n\\n\\nWood --|> Material\\nLA &#x3C;|-- LD\\nAnimal &#x3C;|-- Dog\\n</code></pre>\\n<p>理解这个的关键是理解“里氏替换原则”，也就是，任何父类出现的地方，如果用其子类来替换都应该是安全的。从这个角度看，这个<code>Func</code>完成的工作是用某种材料来制作某种动物，<code>Func[Wood, Animal]</code>是输入木头制作任何动物，<code>Func[Material, Dog]</code>是输入任何材料来制作狗。考虑下面的应用场景：</p>\\n<!-- language:lang-scala -->\\n<pre><code>val woods: List[Wood] = ...         //给定一堆木头\\n\\nval makeAnimalWithWood: Func[Wood, Animal] = ...\\nval makeDogWithMaterial: Func[Material, Dog] = ...\\n\\nval describer: Animal -> String = ...\\n\\nwoods.map(makeAnimalWithWood)       // return List[Animal]\\n     .map(describer)                // 接受Animal返回String\\n</code></pre>\\n<p>根据里氏替换原则，用<code>makeDogWithMaterial</code>替换<code>makeAnimalWithWood</code>是安全的。反过来，看下面代码：</p>\\n<!-- language:lang-scala -->\\n<pre><code>val materials: List[Material] = ...           // 给定一堆材料\\n\\nval makeAnimalWithWood: Func[Wood, Animal] = ...\\nval makeDogWithMaterial: Func[Material, Dog] = ...\\n\\nval describer: Dog -> String = ...\\n\\nmaterials.map(makeDogWithMaterial)       // return List[Dog]\\n     .map(describer)                // 接受Dog返回String\\n</code></pre>\\n<p>这时候，用<code>makeAnimalWithWood</code>来替换<code>makeDogWithMaterial</code>就不行了，因为<code>materials.map(makeAnimalWithWood)</code>就会编译错误了，因为<code>makeAnimalWithWood</code>只接受<code>Wood</code>，而代码传递过来的是<code>Material</code>.</p>\",\"frontmatter\":{\"title\":\"Function的协、逆变\",\"date\":\"February 04, 2016\",\"path\":\"/2016/function-covariant-contravariant\",\"tags\":[\"scala\",\"functional programming\"],\"excerpt\":\"泛型编程的时候，协变(covariant)还是逆变(contravariant)很重要，在设计上层API接口的时候，正确的使用协变、逆变可以更好地约束程序员的行为，让实现变得安全、一致。\"}}},\"pathContext\":{\"slug\":\"/2016/function-covariant-contravariant\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---2016-function-covariant-contravariant-d701758454e14a872f2c.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>泛型编程的时候，协变(covariant)还是逆变(contravariant)很重要，在设计上层API接口的时候，正确的使用协变、逆变可以更好地约束程序员的行为，让实现变得安全、一致。</p>\\n<p>协变、逆变在一般时候是比较容易理解的，但是来到FP世界之后，Function的协变、逆变就变得比较复杂。</p>\\n<p>比如： 对于<code>trait List[+T]</code></p>\\n<!-- language:uml -->\\n<pre><code>class Animal\\nclass Dog\\nclass \\\"List[Animal]\\\" as LA\\nclass \\\"List[Dog]\\\" as LD\\n\\nAnimal &#x3C;|-- Dog\\nLA &#x3C;|-- LD\\n</code></pre>\\n<p>那对于<code>trait CList[-T]</code></p>\\n<!-- language:uml -->\\n<pre><code>class Animal\\nclass Dog\\nclass \\\"CList[Animal]\\\" as LA\\nclass \\\"CList[Dog]\\\" as LD\\n\\nAnimal &#x3C;|-- Dog\\nLA --|> LD\\n</code></pre>\\n<p>这些还都容易理解，对于<code>trait Func[-I, +O]</code>的理解就比较费劲了。</p>\\n<!-- language:lang-scala -->\\n<pre><code>import scala.reflect.runtime.universe._\\n\\nclass Animal\\ncase class Dog(name: String) extends Animal\\n\\nclass Material\\ncase class Wood(color: String) extends Material\\n\\ntrait Func[-I, +O] {\\n  def apply(input: I): O\\n}\\n\\ntypeOf[Dog] &#x3C;:&#x3C; typeOf[Animal]  // return true\\ntypeOf[Func[Material, Dog]] &#x3C;:&#x3C; typeOf[Func[Wood, Animal]]    // retrun true\\n</code></pre>\\n<!-- language:uml -->\\n<pre><code>class Animal\\nclass Dog\\nclass Wood\\nclass Material\\n\\nclass \\\"Func[Wood, Animal]\\\" as LA\\nclass \\\"Func[Material, Dog]\\\" as LD\\n\\n\\nWood --|> Material\\nLA &#x3C;|-- LD\\nAnimal &#x3C;|-- Dog\\n</code></pre>\\n<p>理解这个的关键是理解“里氏替换原则”，也就是，任何父类出现的地方，如果用其子类来替换都应该是安全的。从这个角度看，这个<code>Func</code>完成的工作是用某种材料来制作某种动物，<code>Func[Wood, Animal]</code>是输入木头制作任何动物，<code>Func[Material, Dog]</code>是输入任何材料来制作狗。考虑下面的应用场景：</p>\\n<!-- language:lang-scala -->\\n<pre><code>val woods: List[Wood] = ...         //给定一堆木头\\n\\nval makeAnimalWithWood: Func[Wood, Animal] = ...\\nval makeDogWithMaterial: Func[Material, Dog] = ...\\n\\nval describer: Animal -> String = ...\\n\\nwoods.map(makeAnimalWithWood)       // return List[Animal]\\n     .map(describer)                // 接受Animal返回String\\n</code></pre>\\n<p>根据里氏替换原则，用<code>makeDogWithMaterial</code>替换<code>makeAnimalWithWood</code>是安全的。反过来，看下面代码：</p>\\n<!-- language:lang-scala -->\\n<pre><code>val materials: List[Material] = ...           // 给定一堆材料\\n\\nval makeAnimalWithWood: Func[Wood, Animal] = ...\\nval makeDogWithMaterial: Func[Material, Dog] = ...\\n\\nval describer: Dog -> String = ...\\n\\nmaterials.map(makeDogWithMaterial)       // return List[Dog]\\n     .map(describer)                // 接受Dog返回String\\n</code></pre>\\n<p>这时候，用<code>makeAnimalWithWood</code>来替换<code>makeDogWithMaterial</code>就不行了，因为<code>materials.map(makeAnimalWithWood)</code>就会编译错误了，因为<code>makeAnimalWithWood</code>只接受<code>Wood</code>，而代码传递过来的是<code>Material</code>.</p>\",\"frontmatter\":{\"title\":\"Function的协、逆变\",\"date\":\"February 04, 2016\",\"path\":\"/2016/function-covariant-contravariant\",\"tags\":[\"scala\",\"functional programming\"],\"excerpt\":\"泛型编程的时候，协变(covariant)还是逆变(contravariant)很重要，在设计上层API接口的时候，正确的使用协变、逆变可以更好地约束程序员的行为，让实现变得安全、一致。\"}}},\"pathContext\":{\"slug\":\"/2016/function-covariant-contravariant\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/2016-function-covariant-contravariant.json\n// module id = 358\n// module chunks = 80471449016911"],"sourceRoot":""}